<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2018/10/22/vim-IDE/"/>
      <url>/2018/10/22/vim-IDE/</url>
      
        <content type="html"><![CDATA[<p>当你不知从哪里听过Vim的鼎鼎大名而信心满满的去安装它后，你打开Vim的界面后是这样的：什么也没有，就是一个黑框框。然后你想尝试打几个字，结果发现终端一直在嘟嘟的响。这时你的心里一定会大失所望，这都是什么啊。<br><a id="more"></a></p><p><img src="https://github.com/yaomer/pictures/blob/master/v2.png?raw=true" alt=""></p><p>但请不要就此放弃，你可以把Vim看作一匹充满野性的烈马，需要你付出许多努力去驯服它，从而让它乖乖地为你服务，成为你的好帮手。</p><p>实际上，Vim最大的特性就是它的<code>可定制性和可扩展性</code>。因此，当你与它初次相遇时，它就是一块未经打磨的璞玉，一柄未经开封的利刃。你需要自己去打磨它，磨亮它。让它成为一把编辑器中的<code>瑞士军刀</code>。真正的无愧于它编辑器之神的称号。</p><p>之后我推荐你去看Vim最好的入门教程，它只需花费你半小时不到的时间，然后就可以进入下面的打造之路了。</p><p><code>$ vimtutor</code></p><hr><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>我们写代码的基本需求就是要有一点语法高亮，最起码不能是那样的丑陋吧，然后可能还要有对应的行号等等这样一些基本的需求，然后我们写代码可能就会好受一些了。</p><p>这些基本配置包括后面提到的所有插件都需要用到一个叫做<code>.vimrc</code>的文件，顾名思义，这就是Vim的配置文件。在Unix/Linux系统中，它一般在家目录下，你可以使用<code>$ ls -a | grep &quot;.vimrc&quot;</code>命令检查一下，如果没有的话，就自己创建一个。</p><p>然后我们加入一些最简单、最基本的配置，Vim的模样就会变得不一样了，最起码是有点颜色了。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">filetype</span> <span class="keyword">on</span>           <span class="comment">" 开启文件类型检测</span></span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="keyword">on</span>.   <span class="comment">" 设置加载对应文件类型的插件              </span></span><br><span class="line"><span class="keyword">colorscheme</span> desert    <span class="comment">" 语法高亮主题</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>             <span class="comment">" 开启语法高亮</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>            <span class="comment">" 显示行号</span></span><br><span class="line"><span class="keyword">set</span> noerrorbells      <span class="comment">" 关闭出错响铃</span></span><br><span class="line"><span class="keyword">set</span> autoindent        <span class="comment">" 自动缩进</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span>           <span class="comment">" 使用C/C++的自动缩进方式</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span>         <span class="comment">" 将tab设置为4个空格</span></span><br><span class="line"><span class="keyword">set</span> expandtab         <span class="comment">" 将tab扩展为空格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>      <span class="comment">" 每一级缩进为4个空格</span></span><br></pre></td></tr></table></figure><p>然后在重新打开你的Vim，你就会感到有所惊喜了。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v1.png?raw=true" alt=""></p><p>当然这些配置只是最基本的，Vim还有许多别的有用的配置，这就要根据你自己的需要去配置了。在本文最后，我会给出我的<code>.vimrc</code>，大家可以略作参考。</p><p>然后我们正式进入主题。</p><hr><h3 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h3><p>在谈下面的内容之前，我们首先需要选择一款插件管理器，随着我们安装插件数量的增多，为了方便我们管理也为了以后更方便地安装新插件，这都是我们必须要做的。</p><p>我极力推荐大家使用<code>Plug</code>，它是一款极简主义的Vim插件管理器，与老旧的<code>Vundle</code>相比，它的最大优点是超高速并行安装。除此之外，它还可以延迟加载插件，从而加快Vim的启动速度，这个我们最后会提到的。</p><p><img src="https://raw.githubusercontent.com/junegunn/i/master/vim-plug/installer.gif" alt=""></p><p>运行如下命令安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>它的用法也很简单。首先在你的vimrc中加入以下两行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">'~/.vim/plugged'</span>)</span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure><p>如果你要安装一个插件，就<code>Plug &#39;插件名&#39;</code>，然后把这行加到那两行中间即可，之后在Vim中运行<code>:PlugInstall</code>即可自动安装。</p><p>因此，以下提到的插件我不再说明安装方法，都是以这种方式安装的。</p><hr><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><h4 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h4><p>Vim本身自带了一些语法高亮主题，这些主题文件一般在<code>/usr/share/vim/vim80/colors/</code>目录下。你可以自己分别尝试下，不过这些高亮都相对来说比较简单，对于函数、运算符之类的都无法高亮。</p><p>这里我想推荐大家使用的是<code>monokai</code>主题，用过sublime的人应该会对它印象深刻。这个主题用的人应该来说相当多，你也可以根据自己的审美喜好对它进行个性化的定制。</p><p>定制非常简单。比如说monokai中函数默认的配色是<code>green</code>。如果你想更换为别的颜色，你只需修改对应的颜色字段即可。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> <span class="variable">s:h</span>(<span class="string">"Function"</span>, &#123; <span class="string">"fg"</span>: <span class="variable">s:green</span> &#125;)</span><br></pre></td></tr></table></figure><p>如果你想要除了已有的颜色之外的其他颜色，那么你只需要根据自己的需要查询<code>Vim颜色表</code>去修改诸如<code>&quot;186&quot;</code>这样的颜色值即可。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s:yellow</span> = &#123; <span class="string">"gui"</span>: <span class="string">"#E6DB74"</span>, <span class="string">"cterm"</span>: <span class="string">"186"</span> &#125;</span><br></pre></td></tr></table></figure><p>对于monokai主题，我推荐大家安装<code>crusoexia/vim-monokai</code>这个插件，因为vim-monokai可能不止一个。这个插件的代码结构是比较清晰的，易于我们阅读，也易于修改。</p><h4 id="语法高亮增强"><a href="#语法高亮增强" class="headerlink" title="语法高亮增强"></a>语法高亮增强</h4><p>对于C的语法高亮，这个主题是足以胜任的。但对于C++的一些STL，它还不能够高亮。但通过一个插件，就可以弥补这个缺陷。</p><p>这个插件是<code>&#39;octol/vim-cpp-enhanced-highlight&#39;</code>，它提供了对C++语法高亮的增强。除此之外，还可以高亮运算符，只不过需要简单的设置。</p><p>找到<code>c.vim</code>这个文件，取消下面这些行的注释即可。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">"  Additional optional highlighting</span></span><br><span class="line"><span class="comment">" -----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Operators</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>\(&lt;&lt;\|&gt;&gt;\|[-+*/%&amp;^|&lt;&gt;!=]\)=<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>&lt;&lt;\|&gt;&gt;\|&amp;&amp;\|||\|++\|--\|-&gt;<span class="comment">"</span></span><br><span class="line">" syn match cOperator"[.!~*&amp;%&lt;&gt;^|=,;?:+-]"</span><br><span class="line"><span class="string">" syn match cOperator"</span>/[^/*=]<span class="comment">"me=e-1</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>/$<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator  "</span>&amp;&amp;\|||<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>[][]<span class="comment">"</span></span><br></pre></td></tr></table></figure><h4 id="彩虹括号"><a href="#彩虹括号" class="headerlink" title="彩虹括号"></a>彩虹括号</h4><p>当代码中出现多级嵌套的时候，<code>kien/rainbow_parentheses.vim</code>这个插件会很有用。它可以很明显的显示出不同括号内的代码层次。</p><p>这里我上一张我修改过的代码高亮配色的图吧。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v3.png?raw=true" alt=""></p><p>配置如下。其中我删除了几种不太易辨认的颜色，如深蓝色、黑色。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:rbpt_colorpairs</span> = [</span><br><span class="line">    \ [<span class="string">'darkgreen'</span>,   <span class="string">'firebrick3'</span>],</span><br><span class="line">    \ [<span class="string">'red'</span>,         <span class="string">'firebrick3'</span>],</span><br><span class="line">    \ [<span class="string">'darkmagenta'</span>, <span class="string">'DarkOrchid3'</span>],</span><br><span class="line">    \ [<span class="string">'darkcyan'</span>,    <span class="string">'RoyalBlue3'</span>],</span><br><span class="line">    \ [<span class="string">'darkgreen'</span>,   <span class="string">'RoyalBlue3'</span>],</span><br><span class="line">    \ [<span class="string">'darkmagenta'</span>, <span class="string">'DarkOrchid3'</span>],</span><br><span class="line">    \ [<span class="string">'darkcyan'</span>,    <span class="string">'SeaGreen3'</span>],</span><br><span class="line">    \ ]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:rbpt_max</span> = <span class="number">16</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:rbpt_loadcmd_toggle</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">au</span> VimEnter * RainbowParenthesesToggle</span><br><span class="line"><span class="keyword">au</span> Syntax * RainbowParenthesesLoadRound</span><br><span class="line"><span class="keyword">au</span> Syntax * RainbowParenthesesLoadSquare</span><br><span class="line"><span class="keyword">au</span> Syntax * RainbowParenthesesLoadBraces</span><br></pre></td></tr></table></figure><hr><h3 id="漂亮的状态栏"><a href="#漂亮的状态栏" class="headerlink" title="漂亮的状态栏"></a>漂亮的状态栏</h3><p>作为一名颜值党，暂且不提Vim别的功能，最起码要看来漂亮动人才行吧。那么没有一个好看的状态栏怎么行呢！而<code>vim-airline/vim-airline</code>正是这样一款优秀的状态栏插件，现在它基本上已经取代了<code>powerline</code>。</p><p>它的配色非常多，可以说是只要你想要的，应该都能找到，我这里给出几个我觉得漂亮的吧。</p><p><img src="https://github.com/vim-airline/vim-airline/wiki/screenshots/demo.gif" alt=""></p><p><img src="https://user-images.githubusercontent.com/9622/45275524-52f45c00-b48b-11e8-8b83-a66240b10747.gif" alt=""></p><p>更多的大家自己去看吧。</p><p>还有一个需要顺带下载的插件是它的主题<code>&#39;vim-airline/vim-airline-themes&#39;</code>，我当初就是把它主题下的所有主题都试了一遍，才找到自己喜欢的。<code>^0^</code>希望大家不要像我一样o。</p><p>airline由于要显示一些图形字符，所以它需要使用一些<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">特定的字体</a>。</p><hr><h3 id="自动补全括号"><a href="#自动补全括号" class="headerlink" title="自动补全括号"></a>自动补全括号</h3><p>当我们码代码的时候，如果每次输入一个<code>(</code>之后，稍后还得记得输入另一个配对的<code>)</code>是不是很麻烦，而且有时候还会忘记另一个<code>)</code>。</p><p><code>jiangmiao/auto-pairs</code>插件的作用就是自动补全另一个配对的括号。</p><hr><h3 id="代码自动补全"><a href="#代码自动补全" class="headerlink" title="代码自动补全"></a>代码自动补全</h3><p>代码自动补全首推YCM了，具体的安装配置过程可以参照我的另一篇博客<a href="https://yaoer.me/2018/10/21/YCM/#more" target="_blank" rel="noopener">Mac安装配置YCM</a>，在Unix/Linux下过程应该是差不多的。</p><hr><h3 id="函数参数列表补全"><a href="#函数参数列表补全" class="headerlink" title="函数参数列表补全"></a>函数参数列表补全</h3><p>如果你YCM安装成功了，在你体验着它便利的同时，你应该会有另一个棘手的问题：<strong><em>对于函数参数无法补全</em></strong>。</p><p>在补全列表中是可以看到参数列表的，当当你键入<code>(</code>后，参数列表就消失了。对于一些常见的函数，我们可能不依赖于函数参数补全。但对于一个稍显生僻的函数或者参数表特别长的函数，我们显而易见需要参数补全，因为我们可能会忘掉参数或者搞错参数顺序。</p><p><code>tenfyzhong/CompleteParameter.vim</code>正是这样一个与YCM完美配合的插件。</p><p><img src="https://camo.githubusercontent.com/5ff72790ae3d6bf6c964cf3b59bdc0985268b190/687474703a2f2f7778342e73696e61696d672e636e2f6d773639302f36393437323232336779316668796a76726a68723367323068733061307162792e676966" alt=""></p><p>一旦你键入<code>(</code>后，它会将该函数的参数列表显示出来，和一般IDE的补全是没有什么两样的，填完一个参数后，你可以使用<code>ctr + j</code>跳转到下一个参数，直到填完所有参数，最后跳到<code>)</code>外面。</p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;expr&gt;</span> ( complete_parameter#pre_complete(<span class="string">"()"</span>)</span><br><span class="line"><span class="keyword">smap</span> <span class="symbol">&lt;c-j&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_next_parameter)</span><br><span class="line"><span class="keyword">imap</span> <span class="symbol">&lt;c-j&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_next_parameter)</span><br><span class="line"><span class="keyword">smap</span> <span class="symbol">&lt;c-k&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_previous_parameter)</span><br><span class="line"><span class="keyword">imap</span> <span class="symbol">&lt;c-k&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_previous_parameter)</span><br></pre></td></tr></table></figure><hr><h3 id="跳转到声明或定义处"><a href="#跳转到声明或定义处" class="headerlink" title="跳转到声明或定义处"></a>跳转到声明或定义处</h3><p>这里我们不使用<code>ctags</code>，因为对于C/C++来说，YCM原生支持这些操作，而且使用起来非常方便。</p><p>在你的vimrc中加入下面这一句：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" 跳转到声明或定义处</span></span><br><span class="line"><span class="string">nnoremap &lt;silent&gt;&lt;leader&gt;j :YcmCompleter GoToDefinitionElseDeclaration&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><p>具体的键位映射需要你根据自己的方便设置。</p><hr><h3 id="树形目录"><a href="#树形目录" class="headerlink" title="树形目录"></a>树形目录</h3><p><code>scrooloose/nerdtree</code>插件可以显示树形目录。</p><p><code>tiagofumo/vim-nerdtree-syntax-highlight</code>插件可以高亮nerdtree显示的文件类型。</p><p><code>xuyuanp/nerdtree-git-plugin</code>插件可以显示git状态。</p><p>这三个插件大家可以一起配套下载使用。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v4.png?raw=true" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" nerdtree</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span>n :NERDTreeToggle<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeFileExtensionHighlightFullName</span>    = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeExactMatchHighlightFullName</span>       = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreePatternMatchHighlightFullName</span>     = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeHighlightFolders</span>                  = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeHighlightFoldersFullName</span>          = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeDirArrowExpandable</span>                = <span class="string">'▷'</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeDirArrowCollapsible</span>               = <span class="string">'▼'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" nerdtree-git-plugin</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeIndicatorMapCustom</span> = &#123;</span><br><span class="line">            \ <span class="string">"Modified"</span>  : <span class="string">"✹"</span>,</span><br><span class="line">            \ <span class="string">"Staged"</span>    : <span class="string">"✚"</span>,</span><br><span class="line">            \ <span class="string">"Untracked"</span> : <span class="string">"✭"</span>,</span><br><span class="line">            \ <span class="string">"Renamed"</span>   : <span class="string">"➜"</span>,</span><br><span class="line">            \ <span class="string">"Unmerged"</span>  : <span class="string">"═"</span>,</span><br><span class="line">            \ <span class="string">"Deleted"</span>   : <span class="string">"✖"</span>,</span><br><span class="line">            \ <span class="string">"Dirty"</span>     : <span class="string">"✗"</span>,</span><br><span class="line">            \ <span class="string">"Clean"</span>     : <span class="string">"✔︎"</span>,</span><br><span class="line">            \ <span class="string">'Ignored'</span>   : <span class="string">'☒'</span>,</span><br><span class="line">            \ <span class="string">"Unknown"</span>   : <span class="string">"?"</span></span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="显示类、方法、变量"><a href="#显示类、方法、变量" class="headerlink" title="显示类、方法、变量"></a>显示类、方法、变量</h3><p><code>majutsushi/tagbar</code>插件可以让我们整体把握整个文件的结构。</p><p><img src="https://camo.githubusercontent.com/fc85311154723793776aed28488befdfaab36c42/68747470733a2f2f692e696d6775722e636f6d2f5366394c7332722e706e67" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:tagbar_width</span> = <span class="number">30</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span>t :TagbarToggle<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="快速代码注释"><a href="#快速代码注释" class="headerlink" title="快速代码注释"></a>快速代码注释</h3><p>当我们在debug时，经常需要注释一段可能会出错的代码来查看程序的运行行为，这个时候，<code>scrooloose/nerdcommenter</code>插件就非常有用，它可以让我们非常方便的注释或者反注释代码段。</p><p>它的简单用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;leader&gt;cc         注释一行</span><br><span class="line">&lt;leader&gt;cu         取消注释</span><br><span class="line">&lt;leader&gt;cm         注释(Visual)选中的一段代码</span><br></pre></td></tr></table></figure><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDSpaceDelims</span>               = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDCompactSexyComs</span>           = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDDefaultAlign</span>              = <span class="string">'left'</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDCommentEmptyLines</span>         = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTrimTrailingWhitespace</span>    = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDToggleCheckAllLines</span>       = <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h3 id="文件模糊搜索"><a href="#文件模糊搜索" class="headerlink" title="文件模糊搜索"></a>文件模糊搜索</h3><p>文件模糊查找在我们日常工作应该经常要用到，与其使用速度较慢的<code>find</code>命令，<code>Yggdroot/LeaderF</code>插件可以帮助我们在大型项目中快速定位文件。而且除过模糊查找之外，它还有很多其他功能，我这里就不多说了。</p><p><img src="https://github.com/Yggdroot/Images/raw/master/leaderf/leaderf_1.gif" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> :LeaderfFile<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_WildIgnore</span> = &#123;</span><br><span class="line">            \ <span class="string">'dir'</span>: [<span class="string">'.svn'</span>,<span class="string">'.git'</span>,<span class="string">'.hg'</span>,<span class="string">'.vscode'</span>,<span class="string">'.wine'</span>,<span class="string">'.deepinwine'</span>,<span class="string">'.oh-my-zsh'</span>],</span><br><span class="line">            \ <span class="string">'file'</span>: [<span class="string">'*.sw?'</span>,<span class="string">'~$*'</span>,<span class="string">'*.bak'</span>,<span class="string">'*.exe'</span>,<span class="string">'*.o'</span>,<span class="string">'*.so'</span>,<span class="string">'*.py[co]'</span>]</span><br><span class="line">            \&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_UseCache</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h3 id="更快速高效地移动"><a href="#更快速高效地移动" class="headerlink" title="更快速高效地移动"></a>更快速高效地移动</h3><p>Vim本身已经为我们提供了许多有用的组合键来帮助我们快速高效的移动，但那些大多是小范围的局部移动，而且也并不太准确。</p><p><code>easymotion/vim-easymotion</code>插件可以帮助我们快速准确的定位，让我们的移动一击即中。</p><p><img src="https://camo.githubusercontent.com/d5f800b9602faaeccc2738c302776a8a11797a0e/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f333739373036322f323033393335392f61386539333864362d383939662d313165332d383738392d3630303235656138333635362e676966" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;Leader&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-prefix)</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:EasyMotion_do_mapping</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">j</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">j</span>)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">k</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">k</span>)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>h <span class="symbol">&lt;Plug&gt;</span>(easymotion-linebackward)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">l</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-lineforward)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>s <span class="symbol">&lt;Plug&gt;</span>(easymotion-s)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">w</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">bd</span>-<span class="keyword">w</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="延迟加载Vim插件"><a href="#延迟加载Vim插件" class="headerlink" title="延迟加载Vim插件"></a>延迟加载Vim插件</h3><p>随着我们安装插件的增多，Vim的启动速度不可避免的会变慢，当达到某个临界点之后，这种略显卡顿的启动就不是我们能接受的了。它会非常影响我们编辑文本的心情。</p><p>当幸运的是，Vim的最新版本提供了延迟加载插件的机制，这可以帮助我们将那些在初打开文件时不用的且较重的插件延迟加载，即打开文件后再加载。这样就能显著提高Vim的启动速度了。</p><p>具体操作如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" 延迟加载YCM</span></span><br><span class="line"><span class="string">Plug 'Valloric/YouCompleteMe', &#123; 'on': [] &#125;             </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 100ms后调用LoadPlug，且只调用一次</span><br><span class="line">call timer_start(100, <span class="string">'LoadPlug'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>! LoadPlug(timer) abort</span><br><span class="line">    call plug<span class="comment">#load('YouCompleteMe')</span></span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Mac安装配置YCM</title>
      <link href="/2018/10/21/YCM/"/>
      <url>/2018/10/21/YCM/</url>
      
        <content type="html"><![CDATA[<p>YCM的大名在这里就不消多说了。下面我们就来说说如何安装吧。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>YCM算是Vim插件中比较重的了，而且与其他插件不同的是，它是一个带有编译组件的插件。因此也就导致了在安装过程可能会出现各种意想不到的问题。<br><a id="more"></a></p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>在正式安装YCM之前需要安装一些依赖工具。</p><h4 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h4><p>可以说是homebrew使得Mac的软件生态变得完整，因为它是一个非常好用的包管理工具。我们下面提到的一些依赖都可以通过它很方便地安装。</p><p>可以在终端运行以下ruby脚本安装brew:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>它的用法很简单，比如说安装Vim。</p><p><code>$ brew install vim</code></p><p>运行<code>brew uninstall vim</code>即可卸载。</p><h4 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h4><p>确保你的Vim版本是最新的，且要支持py2或py3。Mac系统自带的Vim版本比较老，你最好使用brew安装最新的版本。可以通过以下命令查看：</p><p><code>$ vim --version</code></p><p>如果输出中包含<code>+python或+python3</code>，就说明你的Vim支持py2或py3。</p><p>如果你的Vim不支持python，那么你可能就需要<a href="https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source" target="_blank" rel="noopener">从源码编译安装Vim</a>了，不过别担心，它的过程很简单。</p><h4 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h4><p><code>$ brew install CMake</code></p><h4 id="Command-Line-Tools"><a href="#Command-Line-Tools" class="headerlink" title="Command Line Tools"></a>Command Line Tools</h4><p>如果你需要C-Family语言补全的话，你就需要安装以上命令行工具。它们在你第一次运行clang时自动安装，也可以通过手工安装：</p><p><code>$ xcode-select --install</code></p><h4 id="pythen-dev"><a href="#pythen-dev" class="headerlink" title="pythen-dev"></a>pythen-dev</h4><p>Mac系统已经默认安装。不过这里需要注意的是：</p><blockquote><p><strong><em>你千万不要在私下去安装一个新的python2，不然会导致YCM在安装和编译中使用不同的python2版本，从而会产生冲突。</em></strong></p></blockquote><p>如果你已经使用brew安装了，那么你可能需要卸载它。这或许会使你的问题得到解决。</p><p><code>$ brew uninstall python@2</code></p><h3 id="YCM"><a href="#YCM" class="headerlink" title="YCM"></a>YCM</h3><p>安装YCM这里推荐使用Plug安装，当然你使用Vundle也可以。</p><p>在你的.vimrc中加入以下代码段。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call plug<span class="comment">#begin('~/.vim/plugged')</span></span><br><span class="line">Plug <span class="string">'Valloric/YouCompleteMe'</span></span><br><span class="line">call plug<span class="comment">#end()</span></span><br></pre></td></tr></table></figure><p>然后在Vim中输入<code>:PlugInstall</code>等待自动安装结束即可。这个过程可能会有点久，需要耐心等待。</p><p>如果你不是使用Plug或Vundle安装的，那么你就需要保证YCM安装包的完整性。可以运行下列命令检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>安装成功后，接下来就需要进入编译环节了。编译过程实际上很简单，运行一个脚本就行了。但如果在脚本运行过程中出了点问题，那么你可能就需要完整地一步一步地编译YCM了。</p><hr><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="直接运行安装脚本"><a href="#直接运行安装脚本" class="headerlink" title="直接运行安装脚本"></a>直接运行安装脚本</h3><p>如果你需要C-Family语言补全，则运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.vim/Plug/YouCompleteMe</span><br><span class="line">$ ./install.py --clang-completer</span><br></pre></td></tr></table></figure><p>否则，直接运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.vim/Plug/YouCompleteMe</span><br><span class="line">$ ./install.py</span><br></pre></td></tr></table></figure><p>如果你幸运的编译成功了，那么直接跳转到配置过程中。否则，进入下一步。</p><h3 id="一步一步编译"><a href="#一步一步编译" class="headerlink" title="一步一步编译"></a>一步一步编译</h3><p>如果你和我当初一样失败了，那么可能就需要进行下面这些比较繁琐的安装过程了。</p><p>如果你关心C-Family语言语义支持，完成下面步骤：</p><h4 id="下载最新版本的libclang"><a href="#下载最新版本的libclang" class="headerlink" title="下载最新版本的libclang"></a>下载最新版本的libclang</h4><p>libclang它提供的库用于为这些语言提供YCM语义完成引擎。</p><p>只有在你确定它是3.9或更高版本时才可以使用系统libclang，否则不能。但即使它是，YCM官方也建议尽可能使用<a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener">llvm.org</a>的官方二进制文件。这确保为你的操作系统下载正确的存档文件。</p><h4 id="编译ycm-core"><a href="#编译ycm-core" class="headerlink" title="编译ycm_core"></a>编译ycm_core</h4><p>这个库是YCM用来获得快速补全的C++引擎。</p><p>在这里，我假设你使用Plug安装了YCM。这意味着YCM的顶级目录在<code>~/.vim/Plug/YouCompleteMe</code>。</p><p>我们将创建一个新文件夹，其中将放置构建文件。运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ mkdir ycm_build</span><br><span class="line">$ cd ycm_build</span><br></pre></td></tr></table></figure><p>现在我们需要生成Makefile。如果你不关心C-Family语言的语义支持，就请在ycm_build 目录中运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -G &quot;Unix Makefiles&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</span><br></pre></td></tr></table></figure><p>如果你关心C-Family语言的语义支持，那么CMake的调用就会更复杂些。我们假设你在llvm.org中下载的LLVM + Clang的二进制发行版，你提取的存档文件放到了文件夹<code>~/ycm_temp/llvm_root_dir</code>中。</p><p>然后在<code>ycm_build</code>目录中运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -G &quot;Unix Makefiles&quot; -DPATH_TO_LLVM_ROOT=~/ycm_temp/llvm_root_dir . ~/.vim/Plug/YouCompleteMe/third_party/ycmd/cpp</span><br></pre></td></tr></table></figure><p>现在已经生成了配置文件，使用以下命令编译库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build . --target ycm_core</span><br></pre></td></tr></table></figure><p>至此YCM就已经安装完成了，<code>ycm_build</code>和<code>ycm_temp</code>目录都可以删除了，不影响使用。</p><p>如果你中间还是出现了一些问题，那么请你仔细按照以上过程重新尝试安装。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置过程需要编辑两个文件：<code>vimrc</code>和<code>.ycm_extra_conf.py</code>。</p><p>在你的终端运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo | clang -v -E -x c++ -</span><br></pre></td></tr></table></figure><p>将输出结果中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;...&quot; search starts here:</span><br><span class="line">#include &lt;...&gt; search starts here:</span><br></pre></td></tr></table></figure><p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">End of search list.z</span><br></pre></td></tr></table></figure></p><p>之间的部分添加到<code>.ycm_extra_conf.py</code>中的<code>-isystem</code>后。</p><p>然后将一下代码段加入到你的vimrc中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> g:ycm_server_python_interpreter=<span class="string">'/usr/bin/python'</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_global_ycm_extra_conf = <span class="string">'~/.vim/plugged/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py'</span></span><br><span class="line"><span class="string">" 让vim的补全菜单行为与一般IDE一致</span></span><br><span class="line"><span class="string">set completeopt=longest,menu</span></span><br><span class="line"><span class="string">"</span> 触发(符号)补全时需要键入的字符数</span><br><span class="line"><span class="built_in">let</span> g:ycm_min_num_of_chars_for_completion = 1</span><br><span class="line"><span class="string">" 补全候选项的最小字符数</span></span><br><span class="line"><span class="string">let g:ycm_min_num_identifier_candidate_chars = 0</span></span><br><span class="line"><span class="string">"</span> 关闭诊断显示功能(已经使用了ale进行异步语法检查)</span><br><span class="line"><span class="built_in">let</span> g:ycm_show_diagnostics_ui = 0</span><br><span class="line"><span class="string">" 在字符串和注释中仍会触发补全</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_comments = 1</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_strings = 1</span></span><br><span class="line"><span class="string">"</span> 禁止缓存匹配项，每次重新生成匹配项</span><br><span class="line"><span class="built_in">let</span> g:ycm_cache_omnifunc = 0</span><br><span class="line"><span class="string">" 在用户接受提供的完成字符串后自动关闭窗口</span></span><br><span class="line"><span class="string">let g:ycm_autoclose_preview_window_after_completion = 0</span></span><br><span class="line"><span class="string">"</span> 跳转到声明或定义处</span><br><span class="line">nnoremap &lt;silent&gt;&lt;leader&gt;gj :YcmCompleter GoToDefinitionElseDeclaration&lt;cr&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">" 自动触发语义补全</span></span><br><span class="line"><span class="string">let g:ycm_semantic_triggers =  &#123;</span></span><br><span class="line"><span class="string">            \ 'c,cpp,python,java,go,erlang,perl': ['re!\w&#123;1&#125;'],</span></span><br><span class="line"><span class="string">            \ 'cs,lua,javascript': ['re!\w&#123;1&#125;'],</span></span><br><span class="line"><span class="string">            \ &#125;</span></span><br><span class="line"><span class="string">"</span> 遇到下列文件时才会开启YCM</span><br><span class="line"><span class="built_in">let</span> g:ycm_filetype_whitelist = &#123;</span><br><span class="line">            \ <span class="string">"c"</span>:1,</span><br><span class="line">            \ <span class="string">"cpp"</span>:1,</span><br><span class="line">            \ <span class="string">"python"</span>:1,</span><br><span class="line">            \ <span class="string">"sh"</span>:1,</span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure><p>接下来你就可以享受YCM带来的如丝般柔滑地补全了。</p>]]></content>
      
      
      <categories>
          
          <category> vim </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>巧判机器的大小端</title>
      <link href="/2018/10/21/endian/"/>
      <url>/2018/10/21/endian/</url>
      
        <content type="html"><![CDATA[<p>大小端的命名来自于《格列佛游记》中一个有关吃鸡蛋先磕鸡蛋的大端还是小端的故事，大家有兴趣的话可以去了解一下。</p><p>那么什么是大端、什么是小端呢？</p><blockquote><ul><li>大端：即高位有效字节在低位地址，低位有效字节在高位地址。</li><li>小端：即高位有效字节在高位地址，低位有效字节在低位地址。</li></ul></blockquote><a id="more"></a><p>我们举个例子来说明一下：<code>char a = 1;</code></p><p>它在内存中的表示如下图：</p><blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/endian.png?raw=true" alt=""></p></blockquote><p>那么如何用C语言来判断自己所使用机器的大小端呢？<br>通常有两种方法，其本质都是依赖于<strong><em>大小端的概念。</em></strong></p><p>一种方法是借助联合的特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125; port;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    port.a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (port.b == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们知道，在联合中 <strong><em>多个成员变量共用一段内存</em></strong>。在执行完<code>port.a = 1</code>后，内存中的情况是这样的：<code>00000000 00000000 00000000 00000001</code>。它到底是如何存放的，我们目前并不清楚。当我们访问<code>port.b</code>时，我们只会访问到位于该段内存中最低地址的那一字节的内容。如果<code>port.b == 1</code>，显然我们访问到的是<code>00000001</code>这一字节的内容，即低位有效字节在低位地址，所以是<code>little-endian</code>模式。<code>big-endian</code>模式同理。</p></blockquote><p>另一种方法就是根据大小端的概念直接判断了，相比于第一种更直接点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endian</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">char</span> *)&amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (endian())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>a是一个<code>int</code>类型的整数，所以<code>&amp;a</code>可以看作一个<code>int *</code>类型的指针。如果对<code>&amp;a</code>进行解引用操作，则编译器会将其解释为：<strong><em>从当前地址开始往后数4个字节，然后取出这4个字节中的内容</em></strong>。如果我们将<code>&amp;a</code>强制类型转换为<code>char *</code>类型后再进行解引用操作，那么编译器就会将其解释为：<strong><em>取出当前地址所在的那个字节中的内容</em></strong>。这个地址一定是之前那4个内存地址中的最低位地址。通过查看该地址中的值是什么我们就能确定该机器的大小端了。</p></blockquote><p>显然，两种方法的本质都是相同的，都是通过<strong><em>查看低位地址中的内容</em></strong>来判断大小端模式的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机系统 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>二叉树的基本操作</title>
      <link href="/2018/10/21/bst/"/>
      <url>/2018/10/21/bst/</url>
      
        <content type="html"><![CDATA[<p>顾名思义，二叉搜索树就是以二叉树来组织的。而二叉树是一颗有根树，它的每个节点至多有两个子节点。</p><p>二叉搜索树的每个节点通常是这样组织的：<strong><em>一个指向左子树的指针、一个指向右子树的指针、关键字以及卫星数据</em></strong>。在某些情况下，还可以对树节点作一些更改，比如增加一个指向父节点的指针，这样做的目的是有助于更好地完成某些操作。<br><a id="more"></a><br>二叉搜索树也叫二叉排序树，它具有如下性质：</p><blockquote><p>设x是二叉搜索树中的一个节点。如果y是x的左子树中的一个节点，那么总有y.key &lt; x.key；如果y是x的右子树中的一个节点，那么总有y.key &gt; x.key。</p></blockquote><p>换句话说，就是<strong><em>对于任意一个节点来说，它的左子树中的所有节点的关键字都小于它自身的关键字，它的右子树中的所有节点的关键字都大于它自身的关键字。</em></strong></p><p>还有一点需要注意的就是 <strong><em>树中具有相同关键字的节点不能重复出现</em></strong>。要想解决这个问题其实也很容易，只需在树节点中增加一个<strong>count域</strong>，插入时如果遇见相同的节点，就将count加1，删除时类似。我们下面的讨论假设所有的元素都是互异的。</p><p>接下来，我们会发现二叉搜索树和快排是多么的相似。<font color="purple">^o\^</font></p><p><img src="https://github.com/yaomer/pictures/blob/master/bst.png?raw=true" alt=""></p><hr><p>下面我们给出一些二叉搜索树的基本操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> &#123;</span>     <span class="comment">/*  树节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; Tnode;</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><blockquote><p>查找操作通常需要返回指向树中具有某个关键字的节点的指针，如果不存在则返回NULL。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  search_tree函数（递归版本）：在树中查找某个值  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">search_tree</span><span class="params">(Tnode *p, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || val == p-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; p-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> search_tree(p-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> search_tree(p-&gt;right, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于树本身是递归定义的，所以这种递归操作是如此的容易，以至于让很多人不厌其烦地使用它。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  search_tree函数（迭代版本）：在树中查找某个值  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">search_tree</span><span class="params">(Tnode *p, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; val != p-&gt;val)</span><br><span class="line">        <span class="keyword">if</span> (val &lt; p-&gt;val)</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; p-&gt;val)</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>迭代版本也是简单而直接的，只需展开递归即可。对于绝大多数计算机来说，迭代版本的效率要更高一些。</p></blockquote><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>二叉搜索树的遍历根据何时输出子树根的关键字可分为三种：</p><blockquote><ul><li>先序遍历：输出的子树根的关键字在其左右子树的关键字之前</li><li>中序遍历：输出的子树根的关键字在其左右子树的关键字之间</li><li>后序遍历：输出的子树根的关键字在其左右子树的关键字之后</li></ul></blockquote><p><strong><em>所谓中序遍历，就是先遍历左子树，然后是当前结点(子树根节点)，最后是右子树</em></strong>。其他两种遍历操作类似。不过中序遍历常常是有用的，因为它从小到大输出树中所有节点的关键字。</p><p>在表达式树中，这三种遍历方法通常产生三种表达式：即前缀表达式、中缀表达式和后缀表达式。</p><blockquote><p><code>应当注意的是</code>：<strong><em>树的遍历需要花费O(n)的时间，而不是像其他操作一样花费O(log n)的时间。这是因为它需要遍历树的每一个节点。</em></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  travel_pre函数：先序遍历  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel_pre</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;val);</span><br><span class="line">        travel_pre(p-&gt;left);</span><br><span class="line">        travel_pre(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  travel_in函数：中序遍历  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel_in</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        travel_in(p-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;val);</span><br><span class="line">        travel_in(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  travel_post函数：后序遍历  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel_post</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        travel_post(p-&gt;left);</span><br><span class="line">        travel_post(p-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回最大关键字元素和最小关键字元素"><a href="#返回最大关键字元素和最小关键字元素" class="headerlink" title="返回最大关键字元素和最小关键字元素"></a>返回最大关键字元素和最小关键字元素</h3><blockquote><p>由于二叉搜索树自身的性质，这两种操作也是相当简单的。我们一种用递归实现，一种用迭代实现。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  mintree函数：返回树中的最小节点  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">mintree</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> mintree(p-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  maxtree函数：返回树中的最大节点  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">maxtree</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><blockquote><p>插入和删除操作会引起由二叉搜索树表示的动态集合的变化，因此我们要对树做一些修改来维护树本身的性质。插入一个节点要相对简单些，而删除的处理则有些复杂。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  addtree函数：在树中插入一个节点  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">addtree</span><span class="params">(Tnode *p, <span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;   <span class="comment">/*  找到了插入位置  */</span></span><br><span class="line">        <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tnode))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;val = new_val;</span><br><span class="line">        p-&gt;left = p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (new_val &lt; p-&gt;val)</span><br><span class="line">        p-&gt;left = addtree(p-&gt;left, new_val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (new_val &gt; p-&gt;val)</span><br><span class="line">        p-&gt;right = addtree(p-&gt;right, new_val);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>对于删除二叉搜索树中的一个节点，可能有如下三种情况：</p><blockquote><ul><li>没有子节点，它可以立即被删除</li><li>只有一个子节点，可以通过调整其父节点中的指针，使指针绕过该节点后而被删除</li><li>有两个子节点，下面作详细说明</li></ul></blockquote><p>第一种情况其实是可以归结到第二种情况中的。比较令人棘手的问题就是第三种情况的处理了。虽然它看起来是比较复杂的，但是由于二叉搜索树本身的性质，我们可以用一种简单的方法来处理它。即 <strong><em><font color="red">用待删除节点的后继节点中的数据来替换待删除节点中的数据，然后再删除其后继节点。</font></em></strong><br><strong><em>由于在这种情况下，待删除节点的右子树非空，所以其后继节点即为其右子树中的最小节点。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tnode *<span class="title">deltree</span><span class="params">(Tnode *p, <span class="keyword">int</span> old_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tnode *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (old_val &lt; p-&gt;val)</span><br><span class="line">        p-&gt;left = deltree(p-&gt;left, old_val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (old_val &gt; p-&gt;val)</span><br><span class="line">        p-&gt;right = deltree(p-&gt;right, old_val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;left &amp;&amp; p-&gt;right) &#123;   <span class="comment">/*  待删除节点有两个孩子  */</span></span><br><span class="line">        tmp = mintree(p-&gt;right);   <span class="comment">/*  找到其后继节点  */</span></span><br><span class="line">        p-&gt;val = tmp-&gt;val;    <span class="comment">/*  用后继节点中的数据来替换待删除节点中的数据  */</span></span><br><span class="line">        p-&gt;right = deltree(p-&gt;right, p-&gt;val);    <span class="comment">/*  删除后继节点  */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">/*  待删除节点有0个或1个孩子  */</span></span><br><span class="line">        tmp = p;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        tmp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们用图解详细说明一下删除过程：</p><blockquote><p><code>case 1：有0个或1个子节点</code></p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/bst1.png?raw=true" alt=""></p><blockquote><p>4是要待删除的节点，我们只需要把指针绕过4，然后释放该节点即可完成删除。</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/bst2.png?raw=true" alt=""></p><blockquote><p><code>case 2：有2个子节点</code></p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/bst3.png?raw=true" alt=""></p><blockquote><p>2是要待删除的节点，我们从节点2开始，找到它的后继节点3， 然后用3来替代2，然后我们删除其后继节点3。即这种方法并不是真正的删除想要删除的节点，只是间接删除。要想真正删除待删除节点，情况就比较复杂了，算法导论中有相关的描述，大家可以去看看。</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/bst4.png?raw=true" alt=""></p><p>我们上面描述的删除算法将会使得左子树比右子树更深，因为我们总是用右子树中的一个节点来代替需要删除的节点。在进行大量随机的<strong>insert / delete</strong>操作后，树或许会变得很不平衡。<br>如果输入的数据是已排好序的，那么二叉搜索树就会退化为线性表，多次<strong>insert</strong>操作将会花费O(n^2)的时间。这无疑不是我们所期望的。</p><p><img src="https://github.com/yaomer/pictures/blob/master/bst5.png?raw=true" alt=""><br>有一些二叉搜索树的变种可以解决这些问题，我们以后会提到的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>队列的基本操作</title>
      <link href="/2018/10/20/queue/"/>
      <url>/2018/10/20/queue/</url>
      
        <content type="html"><![CDATA[<p>和栈一样，队列也是一种操作受限制的表。<strong><em>它只允许在表头（队头）执行删除操作（出队），在表尾（队尾）执行插入操作（入队）。</em></strong> 同样的，队列也可以分别由数组和链表实现。</p><p>队列的链表实现正如我们所描述的那样是直接而鲜明的，这里就不多加描述了。而队列的数组实现是有几点需要说明的。<br><a id="more"></a><br>关于顺序队列中的溢出问题</p><blockquote><ul><li>对空队列执行出队操作，称为下溢，是一种正常现象，常用作程序控制转移的条件</li><li>对满队列执行入队操作，称为“真上溢“，这是一种错误，应设法避免</li><li>由于入队和出队操作中， <strong><em><font color="red">头尾指针只增加不减小，致使被删除元素的空间永远无法重新利用。当队列中实际的元素个数远远小于队列空间的规模时，也可能是由于尾指针已超越队列空间的上界而不能做入队操作，就会发生“假上溢“</font></em></strong> </li></ul></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/a.png?raw=true" alt=""></p><blockquote><p>如上图所示，浅蓝色区域中的元素是被删除过的，它们所占有的空间本来是能够重新利用的，但对于顺序队列却无法做到。<strong><em>因为我们无法访问到之前被删除的元素所占有的空间。我们只能向队尾走，队列很快就会满，这样会导致队列中也许只存在很少的元素。</em></strong> 例如上述顺序队列再入队一次就会满，而队列中的实际元素只有3个。</p></blockquote><p>避免上述假上溢问题的简单的解决方法是：<strong><em>只要head或tail指针到达数组末尾，就让它们又绕回开头，</em></strong> 即队列的循环数组实现，也称为<font color="red">循环队列</font></p><p>当然，对于队列的链表实现，是不存在溢出问题的。</p><hr><h4 id="队列的链表实现"><a href="#队列的链表实现" class="headerlink" title="队列的链表实现"></a>队列的链表实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>    <span class="comment">/*  队列节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Queue *front;</span><br><span class="line"><span class="keyword">static</span> Queue *rear;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initqueue函数：初始化队列  */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initqueue</span><span class="params">(<span class="keyword">int</span> new_val)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Queue *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    p-&gt;val = new_val; </span><br><span class="line">    front = rear = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* enqueue函数：入队操作 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> new_val)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Queue *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    p-&gt;val = new_val;</span><br><span class="line">    rear-&gt;next = p;</span><br><span class="line">    rear = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* dequeue函数：出队操作 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dequeue</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Queue *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isempty()) &#123;</span><br><span class="line">        tmp = front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(front);</span><br><span class="line">        front = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  headqueue函数：返回队头元素  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">headqueue</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> front-&gt;val;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* isfull函数：判断队列是否已满 */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">/*  因为是用链表实现的，所以队列不会满 */</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* isempty函数：判断队列是否为空 */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> front == <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* clear函数：销毁队列 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (!isempty()) </span><br><span class="line">        dequeue(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h4><p>对于队列的数组实现我们需要说明几个问题：</p><blockquote><ul><li>如何实现回绕呢？<ul><li>很简单，就是利用取余运算的特性</li></ul></li><li>如何判断队列为空，如何判断队列已满呢？<ul><li>队列为空很简单，头尾指针重合时即表明队列为空</li><li><strong><em>我们初始化队列时，让head和tail都指向数组的第一个元素的位置。当进行若干次入队和出队操作后，队头和队尾只相差一个位置，如果再进行一次入队操作后，tail和head重合，这就表明队列中已没有可用的空间了，说明队列已满</em></strong></li></ul></li></ul></blockquote><hr><p>下图所展示的队列就已满了，当再进行一次入队操作后，tail就和head重合了。所以判断队列是否已满的条件是：<code>head == (tail + 1) % MAXVAL</code></p><p><img src="https://github.com/yaomer/pictures/blob/master/b.png?raw=true" alt=""></p><p>很显然，这样会浪费一个空间，但是这样保证了判断队列为空和队列已满的条件是不同的。</p><p>入队和出队操作都很简单，这里就不多说了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val[MAXVAL];    <span class="comment">/*  队列空间  */</span></span><br><span class="line">    <span class="keyword">int</span> head;     <span class="comment">/*  头指针  */</span></span><br><span class="line">    <span class="keyword">int</span> tail;     <span class="comment">/*  尾指针  */</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  initqueue函数：初始化队列  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initqueue</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;head = Q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  enqueue函数：入队  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Queue *Q, <span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull(Q)) &#123;</span><br><span class="line">    Q-&gt;val[Q-&gt;tail] = new_val;</span><br><span class="line">        Q-&gt;tail = (Q-&gt;tail + <span class="number">1</span>) % MAXVAL;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  dequeue函数：出队  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isempty(Q)) &#123;</span><br><span class="line">        tmp = Q-&gt;val[Q-&gt;head];</span><br><span class="line">        Q-&gt;head = (Q-&gt;head + <span class="number">1</span>) % MAXVAL;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  headqueue函数：返回队头元素  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">headqueue</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty(Q))</span><br><span class="line">        <span class="keyword">return</span> Q-&gt;val[Q-&gt;head];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isfull函数：检查队列是否已满  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;head == (Q-&gt;tail + <span class="number">1</span>) % MAXVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isempty函数：检查队列是否为空  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;head == Q-&gt;tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>栈的基本操作</title>
      <link href="/2018/10/20/stack/"/>
      <url>/2018/10/20/stack/</url>
      
        <content type="html"><![CDATA[<p>栈是限制插入和删除只能在一个位置上进行的表，这个位置叫做栈顶。对空栈进行<strong>pop或top</strong>操作一般被认为是栈ADT的错误，而当运行<strong>push</strong>时栈空间用尽则是一个实现错误，不是栈ADT的错误。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Data_stack.svg/200px-Data_stack.svg.png" alt=""><br><a id="more"></a><br>栈的特点是 <strong><em>后进先出</em></strong>，因此栈特别适用于 <strong><em>保存和恢复调用现场</em></strong>。栈有许多重要应用，我们简单列举几例：</p><blockquote><ul><li>函数调用（尤其是递归的实现）</li><li>平衡符号</li><li>表达式转换</li><li>……</li></ul></blockquote><p>栈的基本操作很简单，主要有如下几种</p><blockquote><ul><li>push操作（入栈）</li><li>pop操作（出栈）</li><li>top操作（访问栈顶值）</li></ul></blockquote><p>根据你自身的需要，你还可以添加别的操作。比如：清空栈等。</p><p>下面我们给出栈的两种实现方法：数组和链表。</p><hr><h4 id="栈的数组实现"><a href="#栈的数组实现" class="headerlink" title="栈的数组实现"></a>栈的数组实现</h4><p>数组实现的唯一缺点就是：<strong><em>栈空间可能会用尽。</em></strong> 但在绝大多数情况下，只要稍加注意，是不会出现栈空间用尽的情况的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val[MAXVAL];    <span class="comment">/*  值栈  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;    <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将c压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull())</span><br><span class="line">        val[++sp] = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出并返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp--];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  clear函数：清空栈  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sp = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isfull函数：判断栈是否已满  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isempty函数：判断栈是否为空  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="栈的链表实现"><a href="#栈的链表实现" class="headerlink" title="栈的链表实现"></a>栈的链表实现</h4><p>由于栈自身的特点，特别适合于用单链表去实现。我们只需在表头进行<strong>push和pop</strong>操作即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>    <span class="comment">/*  表节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Node *sp;   <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将new_val压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    p-&gt;val = new_val;</span><br><span class="line">    p-&gt;next = sp;</span><br><span class="line">    sp = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isempty()) &#123;</span><br><span class="line">        tmp = sp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(sp);</span><br><span class="line">        sp = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> sp-&gt;val;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  clear函数：清空栈  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!isempty())</span><br><span class="line">pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isfull函数：判断栈是否已满  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isempty函数：判断栈是否为空  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>单链表的基本操作</title>
      <link href="/2018/10/20/sll/"/>
      <url>/2018/10/20/sll/</url>
      
        <content type="html"><![CDATA[<p>由于单链表是链表的一种，所以我们首先来介绍一下链表。</p><p>链表是一种线性表，通常由一连串节点组成，每个节点包含任意的实例数据，和一个或两个用于指向上一个或下一个节点的指针。</p><p>使用链表的优点是：</p><blockquote><ul><li>克服了数组需要预先知道数据大小的缺点</li><li>可以充分利用计算机的内存空间，实现灵活的动态内存管理</li></ul></blockquote><a id="more"></a><p>缺点是：</p><blockquote><ul><li>失去了数组随机读取的优点</li><li>由于增加了节点的指针域，空间开销比较大。</li></ul></blockquote><p>单链表是一种单向链接的链表，对链表的访问只能从表头开始，在表的末尾有一个特殊的结束标记，通常为NULL。</p><p>下面我们给出单链表的具体实现，涉及到它的一些基本操作，如创建、插入、删除等。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> &#123;</span>    <span class="comment">/*  表节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">next</span>;</span>    <span class="comment">/*  指向下一个节点的指针  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建一个单链表通常有两种方法：<strong><em>头插法和尾插法</em></strong></p><blockquote><ul><li>所谓头插法：就是将最先创建的那个节点作为尾节点，然后不断向前延伸。这种方法对数据的存储顺序和你的输入顺序是相反的。</li><li>所谓尾插法：与头插法相反，它将最先创建的那个节点作为头节点，然后不断向后延伸，这应该比较符合我们一般的思维习惯。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  create_head_sll函数：用头插法创建一个长度为size的单链表  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">create_head_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((head = <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="keyword">new</span>-&gt;val);</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;head-&gt;val);</span><br><span class="line">        head-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span> = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  create_tail_sll函数：用尾插法创建一个长度为size的单链表  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">create_tail_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">pre</span>, *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pre = head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist ))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre-&gt;val);</span><br><span class="line">    pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="keyword">new</span>-&gt;val);</span><br><span class="line">        pre-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pre = <span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><blockquote><p>单链表的插入操作通常要分好几种情况讨论，但只要我们细心观察它们，就会发现它们之间的共性，即<font color="red">每个节点都有一个指向它的指针</font>，头节点也不例外。从这种角度来看，头指针也不过是指向一个节点的普通指针而已。因此，我们在这里使用二级指针，能极大地简化操作，并使代码简洁优雅。<font color="red">而在遍历单链表的过程中，我们只需要保存每个指向next域的指针即可，这样就将所有可能的情况转化成一种通用的情况。</font></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  insert_sll函数：在有序单链表中插入一个节点，这里假定是按升序排列的  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sll</span><span class="params">(struct nlist **nextp, <span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;val = new_val;</span><br><span class="line">    <span class="comment">/*  寻找插入位置  */</span></span><br><span class="line">    <span class="keyword">while</span> (*nextp != <span class="literal">NULL</span> &amp;&amp; (*nextp)-&gt;val &lt; new_val)</span><br><span class="line">        nextp = &amp;(*nextp)-&gt;next;   <span class="comment">/*  每次得到指向next域的指针  */</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = *nextp;</span><br><span class="line">    *nextp = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>删除操作同插入操作的方法类似，每次也只需保存指向前一个节点的next域的指针即可，原因也很简单，因为前一个节点中的next指针指向当前节点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  delete_sll函数：在单链表中删除一个节点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_sll</span><span class="params">(struct nlist **nextp, <span class="keyword">int</span> old_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*nextp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*nextp)-&gt;val == old_val) &#123;</span><br><span class="line">            tmp = (*nextp)-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(*nextp);</span><br><span class="line">            *nextp = tmp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextp = &amp;(*nextp)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆置"><a href="#逆置" class="headerlink" title="逆置"></a>逆置</h3><p>单链表的逆置通常有三种方法：</p><blockquote><ol><li>利用头插法创建一个单链表的思想，我们从头遍历整个链表，然后用头插法重新链接每个节点，自然就将链表逆置过来了</li><li>就地逆置，也叫三指针法，改变每个节点的next域，完成逆置过程</li><li>递归的方法</li></ol></blockquote><h4 id="头插法逆置"><a href="#头插法逆置" class="headerlink" title="头插法逆置"></a>头插法逆置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct nlist * <span class="title">reverse_cll</span><span class="params">(struct nlist *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">head</span>, *<span class="title">pre</span>;</span></span><br><span class="line"></span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        head = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="就地逆置"><a href="#就地逆置" class="headerlink" title="就地逆置"></a>就地逆置</h4><blockquote><p>我们用pre指向前一个节点，new指向后一个节点，而*nextp则是head指针，指向当前需要改变的节点，我们用它来遍历整个链表。<strong><em>每次我们先让new指向下一个需要改变的节点，然后再让当前结点的next指针指向之前的节点，最后我们更新pre的值。</em></strong> 至于这里用不用二级指针就随你喜欢了。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_sll</span><span class="params">(struct nlist **nextp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">pre</span>, *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (pre = <span class="literal">NULL</span>; *nextp != <span class="literal">NULL</span>; *nextp = <span class="keyword">new</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> = (*nextp)-&gt;next;</span><br><span class="line">        (*nextp)-&gt;next = pre;</span><br><span class="line">        pre = *nextp;</span><br><span class="line">    &#125;</span><br><span class="line">    *nextp = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找、求长、打印"><a href="#查找、求长、打印" class="headerlink" title="查找、求长、打印"></a>查找、求长、打印</h3><blockquote><p>单链表的查找、求长以及打印操作主要涉及到的都只是 <strong><em>遍历链表的方法</em></strong>，所以应该都很简单。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  search_sll函数：在单链表中查找一个值  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">search_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; head != <span class="literal">NULL</span>; head = head-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == val)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  length_sll函数：计算单链表的长度  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_sll</span><span class="params">(struct nlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; head != <span class="literal">NULL</span>; len++)</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  print_sll函数：打印单链表  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sll</span><span class="params">(struct nlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; head != <span class="literal">NULL</span>; head = head-&gt;next)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, head-&gt;val);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>这里销毁单链表之所以使用二级指针，我是这么想的：</p><blockquote><p><strong><em>如果我们只是简单的传回head指针，虽然它指向的节点被释放了，但它本身的值是不会改变的。</em></strong> 为了避免之后错误地引用已经被释放的head指针，我们需要将它置空，使用二级指针可以很容易做到这一点，虽然在main函数中我们可以在destruct之后手动置空head，但我认为这样更好一些。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  destruct_sll函数：销毁单链表  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destruct_sll</span><span class="params">(struct nlist **nextp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( ; *nextp != <span class="literal">NULL</span>; *nextp = tmp) &#123;</span><br><span class="line">        tmp = (*nextp)-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(*nextp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
