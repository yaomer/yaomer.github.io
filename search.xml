<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>栈的基本操作</title>
      <link href="/2018/10/19/stack/"/>
      <url>/2018/10/19/stack/</url>
      
        <content type="html"><![CDATA[<hr><p>栈是限制插入和删除只能在一个位置上进行的表，这个位置叫做栈顶。对空栈进行<strong>pop或top</strong>操作一般被认为是栈ADT的错误，而当运行<strong>push</strong>时栈空间用尽则是一个实现错误，不是栈ADT的错误。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Data_stack.svg/200px-Data_stack.svg.png" alt=""><br><a id="more"></a><br>栈的特点是 <strong><em>后进先出</em></strong>，因此栈特别适用于 <strong><em>保存和恢复调用现场</em></strong>。栈有许多重要应用，我们简单列举几例：</p><blockquote><ul><li>函数调用（尤其是递归的实现）</li><li>平衡符号</li><li>表达式转换</li><li>……</li></ul></blockquote><p>栈的基本操作很简单，主要有如下几种</p><blockquote><ul><li>push操作（入栈）</li><li>pop操作（出栈）</li><li>top操作（访问栈顶值）</li></ul></blockquote><p>根据你自身的需要，你还可以添加别的操作。比如：清空栈等。</p><p>下面我们给出栈的两种实现方法：数组和链表。</p><hr><h4 id="栈的数组实现"><a href="#栈的数组实现" class="headerlink" title="栈的数组实现"></a>栈的数组实现</h4><p>数组实现的唯一缺点就是：<strong><em>栈空间可能会用尽。</em></strong> 但在绝大多数情况下，只要稍加注意，是不会出现栈空间用尽的情况的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val[MAXVAL];    <span class="comment">/*  值栈  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;    <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将c压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull())</span><br><span class="line">        val[++sp] = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出并返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp--];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  clear函数：清空栈  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sp = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isfull函数：判断栈是否已满  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isempty函数：判断栈是否为空  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="栈的链表实现"><a href="#栈的链表实现" class="headerlink" title="栈的链表实现"></a>栈的链表实现</h4><p>由于栈自身的特点，特别适合于用单链表去实现。我们只需在表头进行<strong>push和pop</strong>操作即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>    <span class="comment">/*  表节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Node *sp;   <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将new_val压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    p-&gt;val = new_val;</span><br><span class="line">    p-&gt;next = sp;</span><br><span class="line">    sp = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isempty()) &#123;</span><br><span class="line">        tmp = sp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(sp);</span><br><span class="line">        sp = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> sp-&gt;val;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  clear函数：清空栈  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!isempty())</span><br><span class="line">pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isfull函数：判断栈是否已满  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isempty函数：判断栈是否为空  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>单链表的基本操作</title>
      <link href="/2018/10/18/sll/"/>
      <url>/2018/10/18/sll/</url>
      
        <content type="html"><![CDATA[<hr><p>由于单链表是链表的一种，所以我们首先来介绍一下链表。</p><p>链表是一种线性表，通常由一连串节点组成，每个节点包含任意的实例数据，和一个或两个用于指向上一个或下一个节点的指针。</p><p>使用链表的优点是：</p><blockquote><ul><li>克服了数组需要预先知道数据大小的缺点</li><li>可以充分利用计算机的内存空间，实现灵活的动态内存管理<a id="more"></a>缺点是：</li></ul></blockquote><blockquote><ul><li>失去了数组随机读取的优点</li><li>由于增加了节点的指针域，空间开销比较大。</li></ul></blockquote><p>单链表是一种单向链接的链表，对链表的访问只能从表头开始，在表的末尾有一个特殊的结束标记，通常为NULL。</p><p>下面我们给出单链表的具体实现，涉及到它的一些基本操作，如创建、插入、删除等。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> &#123;</span>    <span class="comment">/*  表节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">next</span>;</span>    <span class="comment">/*  指向下一个节点的指针  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建一个单链表通常有两种方法：<strong><em>头插法和尾插法</em></strong></p><blockquote><ul><li>所谓头插法：就是将最先创建的那个节点作为尾节点，然后不断向前延伸。这种方法对数据的存储顺序和你的输入顺序是相反的。</li><li>所谓尾插法：与头插法相反，它将最先创建的那个节点作为头节点，然后不断向后延伸，这应该比较符合我们一般的思维习惯。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  create_head_sll函数：用头插法创建一个长度为size的单链表  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">create_head_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((head = <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="keyword">new</span>-&gt;val);</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;head-&gt;val);</span><br><span class="line">        head-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span> = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  create_tail_sll函数：用尾插法创建一个长度为size的单链表  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">create_tail_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">pre</span>, *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pre = head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist ))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre-&gt;val);</span><br><span class="line">    pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="keyword">new</span>-&gt;val);</span><br><span class="line">        pre-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pre = <span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><blockquote><p>单链表的插入操作通常要分好几种情况讨论，但只要我们细心观察它们，就会发现它们之间的共性，即<font color="red">每个节点都有一个指向它的指针</font>，头节点也不例外。从这种角度来看，头指针也不过是指向一个节点的普通指针而已。因此，我们在这里使用二级指针，能极大地简化操作，并使代码简洁优雅。<font color="red">而在遍历单链表的过程中，我们只需要保存每个指向next域的指针即可，这样就将所有可能的情况转化成一种通用的情况。</font></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  insert_sll函数：在有序单链表中插入一个节点，这里假定是按升序排列的  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sll</span><span class="params">(struct nlist **nextp, <span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;val = new_val;</span><br><span class="line">    <span class="comment">/*  寻找插入位置  */</span></span><br><span class="line">    <span class="keyword">while</span> (*nextp != <span class="literal">NULL</span> &amp;&amp; (*nextp)-&gt;val &lt; new_val)</span><br><span class="line">        nextp = &amp;(*nextp)-&gt;next;   <span class="comment">/*  每次得到指向next域的指针  */</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = *nextp;</span><br><span class="line">    *nextp = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>删除操作同插入操作的方法类似，每次也只需保存指向前一个节点的next域的指针即可，原因也很简单，因为前一个节点中的next指针指向当前节点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  delete_sll函数：在单链表中删除一个节点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_sll</span><span class="params">(struct nlist **nextp, <span class="keyword">int</span> old_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*nextp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*nextp)-&gt;val == old_val) &#123;</span><br><span class="line">            tmp = (*nextp)-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(*nextp);</span><br><span class="line">            *nextp = tmp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextp = &amp;(*nextp)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆置"><a href="#逆置" class="headerlink" title="逆置"></a>逆置</h3><p>单链表的逆置通常有三种方法：</p><blockquote><ol><li>利用头插法创建一个单链表的思想，我们从头遍历整个链表，然后用头插法重新链接每个节点，自然就将链表逆置过来了</li><li>就地逆置，也叫三指针法，改变每个节点的next域，完成逆置过程</li><li>递归的方法</li></ol></blockquote><h4 id="头插法逆置"><a href="#头插法逆置" class="headerlink" title="头插法逆置"></a>头插法逆置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct nlist * <span class="title">reverse_cll</span><span class="params">(struct nlist *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">head</span>, *<span class="title">pre</span>;</span></span><br><span class="line"></span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        head = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="就地逆置"><a href="#就地逆置" class="headerlink" title="就地逆置"></a>就地逆置</h4><blockquote><p>我们用pre指向前一个节点，new指向后一个节点，而*nextp则是head指针，指向当前需要改变的节点，我们用它来遍历整个链表。<strong><em>每次我们先让new指向下一个需要改变的节点，然后再让当前结点的next指针指向之前的节点，最后我们更新pre的值。</em></strong> 至于这里用不用二级指针就随你喜欢了。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_sll</span><span class="params">(struct nlist **nextp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">pre</span>, *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (pre = <span class="literal">NULL</span>; *nextp != <span class="literal">NULL</span>; *nextp = <span class="keyword">new</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> = (*nextp)-&gt;next;</span><br><span class="line">        (*nextp)-&gt;next = pre;</span><br><span class="line">        pre = *nextp;</span><br><span class="line">    &#125;</span><br><span class="line">    *nextp = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找、求长、打印"><a href="#查找、求长、打印" class="headerlink" title="查找、求长、打印"></a>查找、求长、打印</h3><blockquote><p>单链表的查找、求长以及打印操作主要涉及到的都只是 <strong><em>遍历链表的方法</em></strong>，所以应该都很简单。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  search_sll函数：在单链表中查找一个值  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">search_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; head != <span class="literal">NULL</span>; head = head-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == val)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  length_sll函数：计算单链表的长度  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_sll</span><span class="params">(struct nlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; head != <span class="literal">NULL</span>; len++)</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  print_sll函数：打印单链表  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sll</span><span class="params">(struct nlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; head != <span class="literal">NULL</span>; head = head-&gt;next)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, head-&gt;val);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>这里销毁单链表之所以使用二级指针，我是这么想的：</p><blockquote><p><strong><em>如果我们只是简单的传回head指针，虽然它指向的节点被释放了，但它本身的值是不会改变的。</em></strong> 为了避免之后错误地引用已经被释放的head指针，我们需要将它置空，使用二级指针可以很容易做到这一点，虽然在main函数中我们可以在destruct之后手动置空head，但我认为这样更好一些。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  destruct_sll函数：销毁单链表  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destruct_sll</span><span class="params">(struct nlist **nextp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( ; *nextp != <span class="literal">NULL</span>; *nextp = tmp) &#123;</span><br><span class="line">        tmp = (*nextp)-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(*nextp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
  
  
</search>
