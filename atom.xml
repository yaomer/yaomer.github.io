<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>若倾</title>
  
  <subtitle>若教解语应倾国，任是无情也动人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yaoer.me/"/>
  <updated>2018-11-07T10:08:05.783Z</updated>
  <id>https://yaoer.me/</id>
  
  <author>
    <name>妖儿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见排序算法总结</title>
    <link href="https://yaoer.me/2018/11/07/sort/"/>
    <id>https://yaoer.me/2018/11/07/sort/</id>
    <published>2018-11-06T16:00:00.000Z</published>
    <updated>2018-11-07T10:08:05.783Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中，我们对常见的排序算法作一个总结。包括：<strong><em>冒泡、选择、插入、希尔、归并、快排、堆排以及桶排。</em></strong></p><a id="more"></a><p>以上排序算法中，除了桶排序以外，其余算法都是基于<font color="red">比较</font>的。在最差情况下，任何一种比较排序至少需要<font color="red">O(n log n)</font>次比较操作。这是比较操作所获取的信息有限所导致的，或者说是全序集的模糊代数结构所导致的。</p><p>不过，比较排序<strong><em>在控制比较函数方面有显著优势，能对各种数据类型进行排序，并且可以很好地控制一个序列如何被排序</em></strong>。例如，可以通过改变比较函数从而使排序结果倒置。并且 <strong><em>一旦比较函数完成，任何比较算法都可以不经修改地使用；</em></strong>而非比较排序对数据类型的要求会更严格。</p><hr><p>排序算法分类：</p><div class="table-container"><table><thead><tr><th>插入排序</th><th>选择排序</th><th>交换排序</th></tr></thead><tbody><tr><td>直接插入</td><td>选择排序</td><td>冒泡排序</td></tr><tr><td>希尔排序</td><td>堆排序</td><td>快排</td></tr></tbody></table></div><p>各排序算法的时间复杂度：</p><div class="table-container"><table><thead><tr><th>排序算法</th><th>最坏时间复杂度</th><th>平均时间复杂度</th><th>最优时间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>插入排序</td><td>O($n^2$)</td><td>O($n^2$)</td><td>O(n)</td><td>稳定</td></tr><tr><td>冒泡排序</td><td>O($n^2$)</td><td>O($n^2$)</td><td>O(n)（优化后的）</td><td>稳定</td></tr><tr><td>选择排序</td><td>O($n^2$)</td><td>O($n^2$)</td><td>O($n^2$)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O($n^2$)</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>不稳定</td></tr><tr><td>桶排序</td><td>O($n^2$)</td><td>O(n + k)</td><td>O(n)</td><td>不稳定</td></tr><tr><td>希尔排序</td><td></td><td></td><td></td><td>不稳定</td></tr></tbody></table></div><p>（注：希尔排序的时间复杂度依赖于增量序列的选择）</p><p>在接下来对各排序算法的描述中，我们用<strong><em>伪代码</em></strong>描述算法本身，并给出C语言的实现。我们假设我们所描述的排序算法都是对<strong><em>整形数组A[1..n]</em></strong>进行排序。</p><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序是一种简单直观的排序算法。它的工作原理是构建有序序列。对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong><em>插入排序对几乎已经排好序的序列是非常高效的。但一般情况下，插入排序是低效的，因为它每次只能将数据移动一位。</em></strong></p><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">2</span> to n</span><br><span class="line">    key = A[j]</span><br><span class="line">    i = j - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key</span><br><span class="line">        A[i + <span class="number">1</span>] = A[i]</span><br><span class="line">        i = i - <span class="number">1</span></span><br><span class="line">    A[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><p>C实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  insertion_sort函数：插入排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> key;    <span class="comment">/*  每次待插入的值  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        key = v[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; v[j] &gt; key; j--)</span><br><span class="line">            v[j + <span class="number">1</span>] = v[j];    <span class="comment">/*  将大于key的元素后移  */</span></span><br><span class="line">        v[j + <span class="number">1</span>] = key;    <span class="comment">/*  将key插入到相应位置  */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/2/25/Insertion_sort_animation.gif" alt=""></p><hr><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是一种简单的排序算法。<strong><em>它重复地遍历要排序的整个数列，每次比较相邻的两个元素，如果它们的顺序错误就把它们交换过来。这个算法名字的由来是因为小的元素会经由交换操作而慢慢“上浮”到排序序列的最前面。</em></strong></p><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">2</span> to n - j</span><br><span class="line">        <span class="keyword">if</span> A[i - <span class="number">1</span>] &gt; A[i]</span><br><span class="line">            swap A[i - <span class="number">1</span>] with A[i]</span><br></pre></td></tr></table></figure><p>C实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  bubble_sort函数：冒泡排序（原始版本）  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">/*  共需要进行n趟排序  */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n - i; j++)   <span class="comment">/*  每趟排序都使小数上升，大数下沉  */</span></span><br><span class="line">            <span class="keyword">if</span> (v[j - <span class="number">1</span>] &gt; v[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = v[j];</span><br><span class="line">                v[j] = v[j - <span class="number">1</span>];</span><br><span class="line">                v[j - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，当输入的序列已经是有序的时候，该排序算法仍然会做大量无用的比较操作。因此，我们可以考虑优化一下它。</p><p>我们可以考虑一下该算法完成整个排序的结束条件是什么，在现在这个原始版本中，它总要对整个待排序序列遍历n趟，即使在某一次遍历之后，已经排好序了，它仍然会像之前那样做完它应该做的所有工作，但这完全是没必要的，一旦排好序，算法就应该结束了。</p><p>为此，<strong><em>我们可以设置一个标志位exchange，标记在某一趟排序过程中，是否发生过交换，一旦没有发生过交换操作，就说明已经排好序了。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  bubble_sort函数：冒泡排序（优化版本）  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, exchange;</span><br><span class="line">    <span class="keyword">enum</span> &#123;NO, YES&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        exchange = NO;    </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (v[j - <span class="number">1</span>] &gt; v[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = v[j];</span><br><span class="line">                v[j] = v[j - <span class="number">1</span>];</span><br><span class="line">                v[j - <span class="number">1</span>] = tmp;</span><br><span class="line">                exchange = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exchange == NO)   <span class="comment">/*  上一趟排序中，没有发生过交换  */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif" alt=""></p><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是一种简单直观的排序算法。<strong><em>它每次找出从未排序序列中的最小值，然后将该最小值与未排序序列的第一个数交换，从而完成对有序区的增量。</em></strong></p><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">for</span> i = j to n</span><br><span class="line">        find A[min]</span><br><span class="line">    swap A[min] with A[j]</span><br></pre></td></tr></table></figure><p>C实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  selection_sort函数：选择排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (v[j] &lt; v[min])    <span class="comment">/*  找出未排序序列中的最小元素  */</span></span><br><span class="line">                min = j;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = v[i];</span><br><span class="line">            v[i] = v[min];</span><br><span class="line">            v[min] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" alt=""></p><hr><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序， 也称 <strong><em>缩小增量排序</em></strong>，是对直接插入排序的一种更高效的改进版本。它的基本思想是：<strong><em>先比较距离较远的元素，这样可以让每个元素一次性地朝最终位置前进一大步（而非像直接插入排序那样每次只能移动一步），从而快速减少大量无序的情况，并且减轻后续的工作。被比较的元素之间的距离逐步缩小，直到减少为1，这时就变成了直接插入排序对几近有序的序列进行排序的情况。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  shell_sort函数：希尔排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> gap;    <span class="comment">/*  步长  */</span></span><br><span class="line"><span class="comment">/*  这里采用希尔增量  */</span></span><br><span class="line">    <span class="keyword">for</span> (gap = n; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)    <span class="comment">/*  控制步长  */</span></span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; n; i++)   <span class="comment">/*  在各对元素间移动位置  */</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; v[j] &gt; v[j + gap]; j -= gap) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = v[j];    <span class="comment">/*  比较各对相距gap个位置的元素  */</span></span><br><span class="line">                v[j] = v[j + gap];</span><br><span class="line">                v[j + gap] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif" alt=""></p><p>希尔排序算法彩条：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Shell_sorting_algorithm_color_bars.svg/220px-Shell_sorting_algorithm_color_bars.svg.png" alt=""></p><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是<code>分治法</code>的一个非常典型的应用，其算法核心是<code>合并(merge)</code>操作。</p><p>因为用到了分治法，所以这里我们简述一下其思想：<strong><em>将原问题分解为若干个规模较小的类似于原问题的子问题，递归地求解这些子问题，然后再合并所有子问题的解来建立原问题的解。</em></strong></p><p>分治法都有类似以下的三个步骤：</p><blockquote><ul><li>分解：将原问题划分为若干个类似于原问题的规模较小的实例</li><li>求解：递归求解所有的子问题，若子问题规模足够小，则直接求解</li><li>合并：合并所有子问题的解，从而得到原问题的解</li></ul></blockquote><p>归并排序完全遵循上述模式，具体操作如下：</p><blockquote><ul><li>分解：将待排序的n个元素的序列划分为各具有n/2个元素的两个子序列</li><li>求解：使用归并排序递归地排序两个子序列</li><li>合并：合并两个已排好序的子序列以产生新的已排好序的序列</li></ul></blockquote><p>当待排序的序列长度为1时，<strong><em>递归“开始回升“</em></strong>，在这种情况下不需做任何工作，因为长度为1的每个序列都已排好序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  merge_sort函数：归并排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(v, left, mid);</span><br><span class="line">        merge_sort(v, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(v, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  merge函数：合并操作  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> tmp[right - left + <span class="number">1</span>];    <span class="comment">/*  用于合并操作的一个附加的临时数组  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= mid &amp;&amp; j &lt;= right; k++)</span><br><span class="line">        tmp[k] = v[i] &lt; v[j] ? v[i++] : v[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        tmp[k++] = v[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">        tmp[k++] = v[j++];</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)    <span class="comment">/*  将排好序的序列拷贝回原数组  */</span></span><br><span class="line">        v[left++] = tmp[k++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然归并排序的最坏运行时间是O(n $\log$ n)，但它很难用于主存排序，主要问题在于合并操作中所需要的线性附加内存。不过，merge例程是大多数外部排序算法的基石。</p><p>归并排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" alt=""></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c5/Merge_sort_animation2.gif/220px-Merge_sort_animation2.gif" alt=""></p><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是实践中已知的最快的排序算法，同样用到了分治法的思想。它之所以特别快的原因主要是非常精炼和高度优化的内部循环。</p><p>快排的基本算法如下：</p><p><strong><em>对于一个给定的数组，从中选择任一元素作为主元，以主元为界将其余元素划分为两个子集：一个子集中的所有元素都小于主元，另一个子集中的所有元素都大于或等于主元。对这两个子集递归地执行这一过程，当某个子集中的元素个数小于2时，该子集就不需要再次排序了，即终止递归。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  q_sort函数：快速排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">q_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)    <span class="comment">/*  若某个子集的元素个数小于2，则终止递归  */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    swap(v, left, (left + right) / <span class="number">2</span>);   <span class="comment">/*  每次选取每个子集中间的元素作为主元  */</span></span><br><span class="line">    last = left;</span><br><span class="line">    <span class="keyword">for</span> (i = left + <span class="number">1</span>; i &lt;= right; i++)    <span class="comment">/*  划分子集  */</span></span><br><span class="line">        <span class="keyword">if</span> (v[i] &lt; v[left])</span><br><span class="line">            swap(v, i, ++last);</span><br><span class="line">    swap(v, left, last);     <span class="comment">/*  恢复主元  */</span></span><br><span class="line"></span><br><span class="line">    q_sort(v, left, last - <span class="number">1</span>);</span><br><span class="line">    q_sort(v, last + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  swap函数：交换两个数  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = v[i];</span><br><span class="line">    v[i] = v[j];</span><br><span class="line">    v[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt=""></p><hr><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序可以详见我的另一篇博客<a href="https://yaoer.me/2018/10/24/heap/">堆及其应用</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本文中，我们对常见的排序算法作一个总结。包括：&lt;strong&gt;&lt;em&gt;冒泡、选择、插入、希尔、归并、快排、堆排以及桶排。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yaoer.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>浅析scanf函数</title>
    <link href="https://yaoer.me/2018/11/01/scanf/"/>
    <id>https://yaoer.me/2018/11/01/scanf/</id>
    <published>2018-10-31T16:00:00.000Z</published>
    <updated>2018-11-01T07:47:38.362Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h3><blockquote><ul><li><strong><em>函数原型</em></strong>： <code>int scanf(char *fmt, ...)</code></li><li><strong><em>参数说明</em></strong>：它的第一个参数fmt是格式字符串，包含普通字符和转换说明；第二个参数是可变长参数表，它的参数必须是指针，这是c语言 <strong><em><font color="red">传值调用语义所要求的</font></em></strong>  。它的返回值是 <strong><em><font color="red">成功匹配并赋值的输入项个数。</font></em></strong> 如果到达文件尾，它返回EOF。</li></ul></blockquote><a id="more"></a><p>我们可以举例说明一下它的返回值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果我们输入两个整数，程序将打印2；如果一个是整数，一个不是整数的话，程序则会打印1；通俗来说，<strong><em>就是我们输入的与格式字符串中转换说明匹配的参数个数将作为返回值。</em></strong></p></blockquote><h3 id="格式字符串"><a href="#格式字符串" class="headerlink" title="格式字符串"></a>格式字符串</h3><blockquote><ul><li><strong><em>普通字符</em></strong>（不包括%）：用于匹配输入流中下一个<strong>非空白字符。</strong></li><li><strong><em>转换说明</em></strong>：依次由一个<strong>%</strong>、一个可选的<strong>赋值禁止符*</strong>、一个可选的<strong>数值(指定最大字段宽度)</strong>、一个可选的<strong>h、l或L字符(指定目标对象的宽度)</strong> 以及一个<strong>转换字符</strong>组成。</li></ul></blockquote><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><ul><li>首先，逐个拿输入缓冲区内的字符与格式字符串进行匹配检查。</li><li><strong><em>对于转换说明，匹配成功则读入字符；匹配不成功，则将字符压回到输入缓冲区中，留待下次读取，然后函数返回。</em></strong></li><li><strong><em>对于普通字符和空白符，匹配成功时把字符丢弃掉；匹配不成功，则将字符压回到输入缓冲区中，函数返回。</em></strong></li><li>下一次调用scanf函数时将从上一次转换的最后一个字符的下一个字符开始继续搜索</li><li>转换说明用于控制下一个输入字段的转换。但是如果转换说明中有赋值禁止符*，则跳过该字段，不进行赋值。 <strong><em><font color="red">输入字段被定义为一个不包括空白符的字符串，其边界定义为到下一个空白符或达到指定的字段宽度。</font></em></strong> 而这表明scanf函数将越过行边界读取输入。</li><li>需要说明的是：<strong><em>scanf函数会忽略格式串中的空白符</em></strong>；当在格式串中遇见一个或多个连续的空白符时，它会重复读取，直到遇见一个非空白符为止，然后将最后遇见的非空白符重新放到输入缓冲区中。</li></ul></blockquote><h3 id="一些有趣的转换说明"><a href="#一些有趣的转换说明" class="headerlink" title="一些有趣的转换说明"></a>一些有趣的转换说明</h3><h4 id="scanf扫描集"><a href="#scanf扫描集" class="headerlink" title="scanf扫描集"></a>scanf扫描集</h4><blockquote><ul><li>使用格式是这样的：<strong>%[]</strong>。它需要一个<strong>char *</strong> 类型的参数，并且总在所有输入之后存储一个 <strong>‘\0’</strong> 字符。</li><li>方括号里可以指定匹配的所有字符，也可以指定所有不匹配的字符，只需 <strong>%<sup><a href="#fn_" id="reffn_"></a></sup></strong> 。如果想在指定的集合中包含 <strong>]</strong> ，则可以这样使用 <strong>%[]]</strong> ，例如 <strong>%[][]</strong> 可以扫描方括号。 <strong><em><font color="red">不能将空字符包含在指定的字符集合中。</font></em></strong></li></ul></blockquote><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[123]"</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);</span><br><span class="line">    <span class="comment">/*  它会扫描整个输入，直到遇见空格、制表或其他字符(非123)，然后将之前的字符保存在字符数组s中  */</span></span><br><span class="line">    <span class="comment">/*  如果你想要遇见数字就停止，可以这样使用  */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^0-9]"</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);</span><br><span class="line">    <span class="comment">/*  怎么样，是不是有点正则表达式的范儿了  */</span></span><br><span class="line">    <span class="comment">/*  我们都知道，scanf函数无法读取含空白符的字串，而我们使用扫描集就可以解决这个问题  */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^\n]"</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);</span><br><span class="line">    <span class="comment">/*  将一行输入保存到s中，包括空白和制表符  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很有趣啊<code>^o^</code></p><h4 id="转换说明-n"><a href="#转换说明-n" class="headerlink" title="转换说明%n"></a>转换说明<code>%n</code></h4><blockquote><ul><li>它不读取输入，需要一个<strong>int *</strong> 类型的参数，这个整数 <strong><em>记录了scanf函数从输入流中读取的字符总数。</em></strong></li><li><strong><em>执行一个%n不会增加scanf函数匹配并赋值的输入项个数</em></strong>，即它的返回值不会增加。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%n"</span>, s, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n);</span><br><span class="line">    <span class="comment">/*  如果我们输入hello，则输出结果为:5  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>我们的重点主要在于 <strong><em>参数的处理</em></strong>，所以，minscanf函数只处理格式字符串和参数，格式转换则通过调用scanf函数实现。</p><p>在此之前，我们先说明一下<strong>stdarg.h</strong>中包含的一组宏定义，它们对 <strong><em>如何遍历可变参数表</em></strong> 作了定义。该头文件的实现因不同的机器而不同，但提供的接口是一致的。</p><div class="table-container"><table><thead><tr><th>宏</th><th>说明</th></tr></thead><tbody><tr><td>va_list</td><td>用于声明一个变量，该变量将依次引用各无名参数。</td></tr><tr><td>va_start</td><td>将ap初始化为指向第一个无名参数的指针。在使用ap之前，该宏必须被调用一次。参数表必须至少包含一个有名参数，va_start将最后一个有名参数作为起点。</td></tr><tr><td>va_arg</td><td>每次调用va_arg，该函数都将返回一个参数，并将ap指向下一个参数。</td></tr><tr><td>va_end</td><td>必须在函数返回之前调用以作一些必要的清理工作。</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  minscanf函数：带有可变参数表的简化的scanf函数  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minscanf</span><span class="params">(<span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;    <span class="comment">/*  声明一个变量ap，该变量将依次指向每个无名参数  */</span></span><br><span class="line">    <span class="keyword">char</span> *p, *sval;</span><br><span class="line">    <span class="keyword">char</span> format[FORMAT];</span><br><span class="line">    <span class="keyword">int</span> i, *ival;</span><br><span class="line">    <span class="keyword">unsigned</span> *uval;</span><br><span class="line">    <span class="keyword">double</span> *dval;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    va_start(ap, fmt);    <span class="comment">/*  将ap指向第一个无名参数  */</span></span><br><span class="line">    <span class="keyword">for</span> (p = fmt; *p != <span class="string">'\0'</span>; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p != <span class="string">'%'</span>) &#123;</span><br><span class="line">            format[i++] = *p;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        format[i++] = <span class="string">'%'</span>;</span><br><span class="line">        <span class="keyword">while</span> (*(p + <span class="number">1</span>) &amp;&amp; !<span class="built_in">isalpha</span>(*(p + <span class="number">1</span>)))    <span class="comment">/*  保存%后的可选字符  */</span></span><br><span class="line">            format[i++] = *++p;</span><br><span class="line">        format[i++] = *++p;    <span class="comment">/*  保存转换字符  */</span></span><br><span class="line">        format[i] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'i'</span>:  </span><br><span class="line">            ival = va_arg(ap, <span class="keyword">int</span> *);</span><br><span class="line">            <span class="built_in">scanf</span>(format, ival);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'x'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">            uval = va_arg(ap, <span class="keyword">unsigned</span> *);</span><br><span class="line">            <span class="built_in">scanf</span>(format, uval);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">            dval = va_arg(ap, <span class="keyword">double</span> *);</span><br><span class="line">            <span class="built_in">scanf</span>(format, dval);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">            sval = va_arg(ap, <span class="keyword">char</span> *);</span><br><span class="line">            <span class="built_in">scanf</span>(format, sval);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br>[C程序设计语言][K&amp;R]</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本说明&quot;&gt;&lt;a href=&quot;#基本说明&quot; class=&quot;headerlink&quot; title=&quot;基本说明&quot;&gt;&lt;/a&gt;基本说明&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;函数原型&lt;/em&gt;&lt;/strong&gt;： &lt;code&gt;int scanf(char *fmt, ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;参数说明&lt;/em&gt;&lt;/strong&gt;：它的第一个参数fmt是格式字符串，包含普通字符和转换说明；第二个参数是可变长参数表，它的参数必须是指针，这是c语言 &lt;strong&gt;&lt;em&gt;&lt;font color=&quot;red&quot;&gt;传值调用语义所要求的&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;  。它的返回值是 &lt;strong&gt;&lt;em&gt;&lt;font color=&quot;red&quot;&gt;成功匹配并赋值的输入项个数。&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt; 如果到达文件尾，它返回EOF。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>谈谈C语言中的类型转换</title>
    <link href="https://yaoer.me/2018/11/01/ctype/"/>
    <id>https://yaoer.me/2018/11/01/ctype/</id>
    <published>2018-10-31T16:00:00.000Z</published>
    <updated>2018-11-01T08:08:27.712Z</updated>
    
    <content type="html"><![CDATA[<p>C语言中的类型转换有两种：</p><blockquote><ul><li><code>隐式类型转换(自动类型转换)</code>：这通常会发生在操作数类型不同的二元运算符中，一般是由编译器帮我们做的。</li><li><code>显示类型转换(强制类型转换)</code>：我们自己转换自己想要的类型。</li></ul></blockquote><a id="more"></a><p><strong>隐式类型转换</strong>往往很容易被我们忽略，它通常发生在不经意间，在多数情况下，我们不必去在意其中到底发生了什么，编译器又为我们做了什么、隐藏了什么；但在有些时候，编译器私下不为人知的<strong>隐式类型转换</strong>的结果却会出乎我们的意料之外，倘若我们不明白其中的道理，就会导致一些莫名其妙的<strong>bug</strong>。因此，我们有理由去弄懂它。</p><p><strong>显示类型转换</strong>因为是我们自己主观的行为，所以当出现<strong>显示类型转换</strong>时我们知道自己在做什么，并且知道它的结果是什么。但在其中到底发生了什么，有些人未必很清楚，因次也需要去弄懂其中的原理，这十分有助于我们以后更深入地学习。</p><hr><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>C语言应该来说是一种强类型语言，但在语法检查方面却是比较弱的。C语言中基本的数据类型有以下几种：<code>char、short、int、long、long long、float、double、long double</code>以及可选的修饰符<code>signed、unsigned</code>。</p><p>在很多情况下都会发生隐式的类型转换。一般来说，<strong><em>如果二元运算符(具有两个操作数的运算符)的两个操作数具有不同的类型，那么在进行运算前先要把 “较低(较窄)”的类型提升为“较高(较宽)”的类型，运算的结果为后者</em></strong>。</p><p>如果没有<code>unsigned</code>类型的操作数，则只要使用下面这些<strong>非正式规则</strong>就可以了：</p><blockquote><ul><li>如果其中一个操作数的类型为<code>long double</code>，则将另一个操作数转换为<code>long double</code>类型。</li><li>如果其中一个操作数的类型为<code>double</code>，则将另一个操作数转换为<code>double</code>类型。</li><li>如果其中一个操作数的类型为<code>float</code>，则将另一个操作数转换为<code>float</code>类型。</li><li><code>char</code>和<code>short</code>类型的操作数将转换为<code>int</code>类型，这个过程称为<strong>整型提升</strong>。</li><li>如果其中一个操作数的类型为<code>long</code>，则将另一个操作数也转换为<code>long</code>类型。</li></ul></blockquote><p><strong><em>在将<code>char</code>类型转换为<code>int</code>类型时需要特别注意</em></strong>。C语言没有规定<code>char</code>类型的变量是<code>signed</code>类型还是<code>unsigned</code>类型。当把一个<code>char</code>类型转换为<code>int</code>类型时，其结果可能为正，也可能为负，这取决于你所使用的机器。在某些机器中，如果<code>char</code>类型的最高位为1，则转换为负值，即进行<strong>符号扩展</strong>；而在另一些机器中，把<code>char</code>类型转换为<code>int</code>类型时，<code>char</code>类型的最高位总被填充为0，这导致转换的结果总是正值。</p><p><strong><em>C语言的定义保证了机器的标准打印字符集中的字符不会是负值</em></strong>。因此，在表达式中这些字符总是正值。但是，存储在字符变量中的位模式在某些机器中可能是负的，而在另一些机器中则可能是正的。为了保证程序的可移植性，如果要在<code>char</code>类型数据中存储非字符数据，最好指定<code>signed</code>或<code>unsigned</code>限定符。</p><p>我们看下面一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">0244</span>;</span><br><span class="line">    <span class="keyword">int</span>  b = <span class="number">0244</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\nb = %d\n"</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">-92</span>;</span><br><span class="line">b = <span class="number">164</span>;</span><br></pre></td></tr></table></figure><blockquote><p>八进制数<code>0244</code>的十进制表达为<code>164</code>，对应的位模式为<code>10100100</code>。很显然在我的机器上，当从<code>char</code>类型转换到<code>int</code>类型时会进行符号扩展，即<code>0244</code>会被解释为一个负值。<code>10100100</code>对应的补码形式为<code>11011100</code>，它的值即为<code>-92</code>。</p></blockquote><p>还有一点就是，表达式中的<code>float</code>类型的操作数不会自动转换为<code>double</code>类型。</p><p>当表达式中包含<code>unsigned</code>类型的操作数时，转换规则要复杂一些。主要原因在于，有符号数和无符号数之间的比较运算是与机器相关的，它们取决于机器中不同整数类型的大小。</p><p>赋值时若进行类型转换，则赋值运算符右边的操作数需要转换为左边操作数的类型，该类型即为赋值表达式结果的类型。</p><p>由于函数调用的参数也是表达式，所以在把参数传递给函数时也可能进行类型转换。</p><p>在没有函数原型的情况下，<code>char</code>和<code>short</code>类型都将被转换为<code>int</code>类型，<code>float</code>类型将被转换为<code>double</code>类型。</p><p><strong><em>整型提升</em></strong></p><blockquote><p>在一个表达式中，凡是可以使用整型的地方都可以使用<code>signed</code>或<code>unsigned</code>类型的字符、短整型或位字段，还可以使用枚举类型的对象。如果原始类型的所有值都可以用<code>int</code>类型表示，则其值将被转换为<code>int</code>类型；否则将被转换为<code>unsigned int</code>类型。这一过程称为<strong>整型提升</strong>。</p></blockquote><p><strong><em>整型转换</em></strong></p><blockquote><ul><li>将任何整数转换为某种指定类型的无符号数的方法是：<strong><em>以该无符号类型能够表示的最大值加1为模，找出与此整数同余的最小的非负值</em></strong>。在补码表示中，如果该无符号数的位模式较窄，这就相当于左截取；如果该无符号数的位模式较宽，这就相当于对带符号数进行符号扩展和对无符号数进行0填充。</li><li>将任何整数转换为带符号类型时，如果它可以在新类型中表示出来，则其值保持不变，否则它的值同具体的实现有关。</li></ul></blockquote><p><strong><em>整型和浮点数</em></strong></p><blockquote><ul><li>当把浮点类型转换为整型时，小数部分将被丢弃。如果其结果值不能用整型表示出来，则其行为是为定义的。特别是，将负的浮点数转换为无符号整型的结果是没有定义的。</li><li>当把整型转换为浮点类型时，如果该值在该浮点类型的可表示范围内但不能精确表示，则结果可能是下一个较高或较低的可表示值。如果该值超出可表示范围，则其行为是未定义的。</li></ul></blockquote><p><strong><em>浮点类型</em></strong></p><blockquote><p>将一个精度较低的浮点值转换为一个相同的或精度较高的浮点类型时，它的值保持不变。将一个较高精度的浮点值转换为较低精度的浮点类型时，如果它的值在可表示范围内，则结果可能是下一个较高或较低的可表示值。如果结果在可表示范围之外，则其行为是未定义的。</p></blockquote><p><strong><em>算术类型转换</em></strong></p><blockquote><ul><li>首先，如果任何一个操作数为<code>long double</code>类型，则将另一个操作数转换为<code>long double</code>类型。</li><li>否则，如果任何一个操作数为<code>double</code>类型，则将另一个操作数转换为<code>double</code>类型。</li><li>否则，如果其中一个操作数为<code>float</code>类型，则将另一个操作数转换为<code>float</code>类型。</li><li>否则，同时对两个操作数进行整型提升；然后，如果任何一个操作数为<code>unsigned long</code>类型，则将另一个操作数转换为<code>unsigned long</code>类型。</li><li>否则，如果一个操作数为<code>long</code>类型且另一个操作数<code>unsigned</code>类型，则其结果依赖于<code>long</code>类型是否可以表示所有的<code>unsigned</code>类型的值。如果可以，则将<code>unsigned</code>类型的操作数转换为<code>long</code>类型；如果不可以，则将两个操作数都转换为<code>unsigned long</code>类型。</li><li>否则，如果一个操作数为<code>long</code>类型，则另一个操作数转换为<code>long</code>类型。</li><li>否则，如果任何一个操作数为<code>unsigned</code>类型，则将另一个操作数转换为<code>unsigned</code>类型。</li><li>否则，将两个操作数都转换为<code>int</code>类型。</li></ul></blockquote><hr><h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><p>在任何表达式中都可以使用<strong>强制类型转换</strong>进行显示的类型转换。<br><code>(类型名) 表达式</code><br>我们可以这样理解强制类型转换的准确含义：<strong><em>在上述语句中，表达式首先被赋值给我们指定类型的某个变量，然后在用该变量替换上述整条语句</em></strong>。</p><p>需要注意的一点是：<strong><em>强制类型转换只是生成了一个临时的我们指定类型的值，原有的被转换的值不会发生变化，并且含有强制类型转换的表达式不能作为左值</em></strong>。</p><p>在通常情况下，参数是通过函数原型声明的。这样，当函数被调用时，声明将对参数自动进行强制类型转换。例如<math.h>中的数学函数<br><code>double sqrt(double);</code><br>无论我们的调用参数是否是<code>double</code>类型，它都会被强制转换为<code>double</code>类型。</math.h></p><hr><h4 id="对指针进行强制类型转换"><a href="#对指针进行强制类型转换" class="headerlink" title="对指针进行强制类型转换"></a>对指针进行强制类型转换</h4><p>最后我们来说一下对指针的强制类型转换。</p><p>我们知道指针是一种保存地址的变量。<strong><em>而不同类型的指针的区别仅在于编译器对该地址的解释不同而已</em></strong>。</p><p>类如一个<code>char</code>类型指针<code>p</code>和<code>int</code>类型指针<code>q</code>，我们如果对<code>p</code>进行解引用操作，则编译器会做以下事情：<strong><em>以<code>p</code>中保存的地址为基地址，向后偏移<code>sizeof(char)</code>,取出这段内存地址中的内容</em></strong>。如果对<code>q</code>进行解引用操作，编译器行为的不同仅在于<code>向后偏移不再是1而是sizeof(int)</code>。</p><p>所以说对某种类型的指针进行强制类型转换的目的仅在于<strong><em>我们想以什么样的方式去访问某段内存</em></strong>。</p><hr><p>参考资料：<br>[C程序设计语言][K&amp;R]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言中的类型转换有两种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;隐式类型转换(自动类型转换)&lt;/code&gt;：这通常会发生在操作数类型不同的二元运算符中，一般是由编译器帮我们做的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;显示类型转换(强制类型转换)&lt;/code&gt;：我们自己转换自己想要的类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下的贪吃蛇小游戏</title>
    <link href="https://yaoer.me/2018/10/25/snake/"/>
    <id>https://yaoer.me/2018/10/25/snake/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2018-10-25T05:27:34.692Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主要设计思路"><a href="#主要设计思路" class="headerlink" title="主要设计思路"></a>主要设计思路</h3><blockquote><ul><li>主要数据结构：单链表</li><li>蛇的移动：每次在蛇头添加2个节点，在蛇尾删除2个节点</li><li>蛇的转向：通过一组方向坐标与蛇的位置坐标的运算来实现转向</li><li>蛇吃食物：只在蛇头添加2个节点，而不必在蛇尾删除2个节点</li><li>蛇的死亡：撞上边界或自身</li></ul></blockquote><a id="more"></a><p>然后给出实现中的一点说明：</p><blockquote><ul><li>之所以每次操作2个节点，是因为我所绘制的游戏界面比较大，这样能使游戏效果更明显点</li><li>而且为了当蛇身比较长的时候，对蛇身的折叠缠绕能够明显的区分开，而不是混成一团，我们让蛇每次移动2行或2列</li><li>还有一个需要注意的点：当你给普通字符着色后，它所对应的一个整形值就不再是原来的值了，它会在原来的基础上附加上颜色属性。所以不同颜色的相同字符其实是不同的，不能一概视之</li></ul></blockquote><p>游戏的核心逻辑：</p><blockquote><p><strong><em><font color="red">正常情况下，程序一直处于监听键盘的状态，但一旦有信号中断(这里是超时)产生，就转而去执行display_snake函数；执行完毕后，又处于监听键盘的状态… 直至程序运行结束。</font></em></strong>(这里用到了一点简单的signal方面的知识)。这个机制应该是整个程序设计的难点了，我也是在参考了许多博客，再加上一段时间的思考之后，才想明白的。</p></blockquote><p>还有一点就是，你得确保你的电脑上有curses库，绝大多数unix系统应该会自带curses库，如果没有的话，那么你得自行安装，安装方法很简单，网上也有很多，这里就不多说了。</p><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY  150    <span class="comment">/*  设置延时  */</span>                                                                                                            </span></span><br><span class="line"><span class="comment">/*  蛇的活动地图的大小  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW    (LINES - 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COL    (COLS - 24) </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">snake</span> &#123;</span>     <span class="comment">/*  蛇身节点  */</span></span><br><span class="line">    <span class="keyword">int</span> sx;       <span class="comment">/*  行坐标  */</span></span><br><span class="line">    <span class="keyword">int</span> sy;       <span class="comment">/*  列坐标  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snake</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Snake;</span><br></pre></td></tr></table></figure><blockquote><p>主函数很简单。<code>(^_^)a</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Snake *head, *tail;   <span class="comment">/*  蛇头、蛇尾  */</span></span><br><span class="line"><span class="keyword">int</span> dx, dy;           <span class="comment">/*  一组方向坐标  */</span></span><br><span class="line"><span class="keyword">int</span> score;            <span class="comment">/*  得分  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    signal(SIGALRM, display_snake);</span><br><span class="line">    get_keyboard();     <span class="comment">/*  监听键盘  */</span></span><br><span class="line">    endwin();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  init函数：游戏初始化  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initscr();   <span class="comment">/*  初始化curses  */</span></span><br><span class="line">    start_color();  <span class="comment">/*  初始化颜色表  */</span></span><br><span class="line">    set_color();    <span class="comment">/*  设置颜色  */</span></span><br><span class="line">    box(stdscr, ACS_VLINE, ACS_HLINE);   <span class="comment">/*  绘制一个同物理终端大小相同的窗口  */</span></span><br><span class="line">    noecho();    <span class="comment">/*  关闭键入字符的回显  */</span></span><br><span class="line">    cbreak();    <span class="comment">/*  字符一键入，直接传递给程序  */</span></span><br><span class="line">    curs_set(<span class="number">0</span>);    <span class="comment">/*  隐藏光标  */</span></span><br><span class="line">    keypad(stdscr, <span class="literal">true</span>);    <span class="comment">/*  开启逻辑键  */</span></span><br><span class="line">    draw_initscr();</span><br><span class="line">    draw_map();</span><br><span class="line">    creat_snake();</span><br><span class="line">    creat_food();</span><br><span class="line">    display_score();</span><br><span class="line">    refresh();   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  display_snake函数：游戏的主要控制逻辑  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_snake</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_crash())</span><br><span class="line">        over();</span><br><span class="line">    <span class="keyword">if</span> (is_eat_food()) &#123;</span><br><span class="line">        add_snake();</span><br><span class="line">        creat_food();</span><br><span class="line">        display_score();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        add_snake();</span><br><span class="line">        del_snake();</span><br><span class="line">    &#125;</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  over函数：游戏结束  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">over</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    draw_overscr();</span><br><span class="line">    endwin();    <span class="comment">/*  结束调用curses  */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面是与蛇的移动有关的代码，也是游戏的核心部分代码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  creat_snake函数：初始化蛇身  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_snake</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(head = tail = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Snake)));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    srand(clock());   <span class="comment">/*  以当前挂钟时间作随机种子数  */</span></span><br><span class="line">    <span class="keyword">while</span> ((head-&gt;sx = rand() % (ROW - <span class="number">3</span>) + <span class="number">3</span>) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">while</span> ((head-&gt;sy = rand() % (COL - <span class="number">4</span>) + <span class="number">4</span>) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">    mvaddch(head-&gt;sx, head-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  creat_food函数：初始化食物  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_food</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    srand(clock());</span><br><span class="line">    <span class="keyword">while</span> ((i = rand() % (ROW - <span class="number">3</span>) + <span class="number">3</span>) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">while</span> ((j = rand() % (COL - <span class="number">4</span>) + <span class="number">4</span>) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    move(i, j);</span><br><span class="line">    <span class="keyword">if</span> (inch() == <span class="number">288</span>)    <span class="comment">/*  食物不能覆盖蛇身  */</span></span><br><span class="line">        creat_food();</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">2</span>));</span><br><span class="line">    addch(<span class="string">' '</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  add_snake函数：在蛇头增加2个节点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_snake</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Snake *p, *q;</span><br><span class="line"></span><br><span class="line">    assert(p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Snake)));</span><br><span class="line">    assert(q = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Snake)));</span><br><span class="line">    head-&gt;next = p;</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">    p-&gt;sx = head-&gt;sx + dx;</span><br><span class="line">    p-&gt;sy = head-&gt;sy + dy;</span><br><span class="line">    mvaddch(p-&gt;sx, p-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    q-&gt;sx = p-&gt;sx + dx;</span><br><span class="line">    q-&gt;sy = p-&gt;sy + dy;</span><br><span class="line">    mvaddch(q-&gt;sx, q-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">    head = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  del_snake函数：在蛇尾删除2个节点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_snake</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Snake *tmp;</span><br><span class="line"></span><br><span class="line">    mvaddch(tail-&gt;sx, tail-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    mvaddch(tail-&gt;next-&gt;sx, tail-&gt;next-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    tmp = tail-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(tail-&gt;next);</span><br><span class="line">    <span class="built_in">free</span>(tail);</span><br><span class="line">    tail = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  is_eat_food函数：判断是否吃到食物  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_eat_food</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inch() == <span class="number">544</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  is_crash函数：判断是否撞到障碍物  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_crash</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    move(head-&gt;sx + <span class="number">2</span> * dx, head-&gt;sy + <span class="number">2</span> * dy);</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;sx &lt;= <span class="number">2</span> || head-&gt;sx &gt;= ROW + <span class="number">1</span>|| </span><br><span class="line">        head-&gt;sy &lt;= <span class="number">3</span> || head-&gt;sy &gt;= COL + <span class="number">1</span>)   <span class="comment">/*  撞到边界  */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (inch() == <span class="number">288</span>)   <span class="comment">/*  撞到自身  */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  get_keyboard函数：监听键盘  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_keyboard</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((c = getch()) != <span class="string">'q'</span>) &#123;   <span class="comment">/*  按q键可以退出游戏  */</span></span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> KEY_UP:</span><br><span class="line">            dx = <span class="number">-1</span>; dy = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KEY_DOWN:</span><br><span class="line">            dx = <span class="number">1</span>; dy = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KEY_LEFT:</span><br><span class="line">            dx = <span class="number">0</span>; dy = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KEY_RIGHT:</span><br><span class="line">            dx = <span class="number">0</span>; dy = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_snake();</span><br><span class="line">        set_ticker(DELAY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  lock_snake函数：防止蛇身反向移动  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_snake</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lx, ly;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dx &amp;&amp; dx + lx == <span class="number">0</span>)</span><br><span class="line">        dx = lx;</span><br><span class="line">    <span class="keyword">if</span> (dy &amp;&amp; dy + ly == <span class="number">0</span>)</span><br><span class="line">        dy = ly;</span><br><span class="line">    lx = dx;</span><br><span class="line">    ly = dy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>游戏界面的绘制就是个细心活喽，大家按自己的喜好绘制就可以了，说实话，这个界面我是尝试了好多好多次，挺无聊的。<code>^o^(逃</code></p><p>注意：这个界面是按我的终端大小绘制的，你应该根据你的终端大小作一点调整。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  draw_initscr函数：绘制游戏开始界面  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_initscr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    attron(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = COLS / <span class="number">2</span> - <span class="number">20</span>; i &lt;= COLS / <span class="number">2</span> + <span class="number">20</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        mvaddch(LINES / <span class="number">2</span> - <span class="number">4</span>, i, <span class="string">'@'</span>);</span><br><span class="line">        mvaddch(LINES / <span class="number">2</span> + <span class="number">6</span>, i, <span class="string">'@'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = LINES / <span class="number">2</span> - <span class="number">3</span>; i &lt;= LINES / <span class="number">2</span> + <span class="number">5</span>; i++) &#123;</span><br><span class="line">        mvaddch(i, COLS / <span class="number">2</span> - <span class="number">22</span>, <span class="string">'@'</span>);</span><br><span class="line">        mvaddch(i, COLS / <span class="number">2</span> + <span class="number">22</span>, <span class="string">'@'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">8</span>, COLS / <span class="number">2</span> - <span class="number">13</span>, <span class="string">"Press any key to continue..."</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> - <span class="number">2</span>, COLS / <span class="number">2</span> - <span class="number">8</span>, <span class="string">"Welcome to snake"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> - <span class="number">1</span>, COLS / <span class="number">2</span> - <span class="number">10</span>, <span class="string">"emmmmmmmmm, however,"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span>, COLS / <span class="number">2</span> - <span class="number">20</span>, <span class="string">"now that you are here, you must be greedy!"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">1</span>, COLS / <span class="number">2</span> - <span class="number">11</span>, <span class="string">"~~o~~o~~o~~o~~o~~o~~o~~"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">2</span>, COLS / <span class="number">2</span> - <span class="number">5</span>, <span class="string">"Game Rules:"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">3</span>, COLS / <span class="number">2</span> - <span class="number">18</span>, <span class="string">"1. use direciton keys to move snake"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">4</span>, COLS / <span class="number">2</span> - <span class="number">18</span>, <span class="string">"2. snake is green space, food is red"</span>);</span><br><span class="line">    getch();</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    refresh();</span><br><span class="line">    clear();   <span class="comment">/*  清屏  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  draw_map函数：绘制游戏地图  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_map</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    attron(COLOR_PAIR(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; COLS - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        mvaddch(<span class="number">2</span>, i, <span class="string">' '</span>);</span><br><span class="line">        mvaddch(LINES - <span class="number">2</span>, i, <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; LINES - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        mvaddch(i, <span class="number">3</span>, <span class="string">' '</span>);</span><br><span class="line">        mvaddch(i, COL + <span class="number">1</span>, <span class="string">' '</span>);</span><br><span class="line">        mvaddch(i, COLS - <span class="number">3</span>, <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">3</span>));</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    mvaddstr(<span class="number">10</span>, <span class="number">132</span>, <span class="string">"Your Score:"</span>);</span><br><span class="line">    mvaddstr(<span class="number">12</span>, <span class="number">130</span>, <span class="string">"^0^ smiling ^0^"</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  draw_overscr函数：绘制结束界面  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_overscr</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    clear();</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = COLS / <span class="number">2</span> - <span class="number">16</span>; i &lt;= COLS / <span class="number">2</span> + <span class="number">16</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        mvaddch(LINES / <span class="number">2</span> - <span class="number">4</span>, i, <span class="string">'@'</span>);</span><br><span class="line">        mvaddch(LINES / <span class="number">2</span> + <span class="number">3</span>, i, <span class="string">'@'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = LINES / <span class="number">2</span> - <span class="number">3</span>; i &lt;= LINES / <span class="number">2</span> + <span class="number">2</span>; i++) &#123;</span><br><span class="line">        mvaddch(i, COLS / <span class="number">2</span> - <span class="number">18</span>, <span class="string">'@'</span>);</span><br><span class="line">        mvaddch(i, COLS / <span class="number">2</span> + <span class="number">18</span>, <span class="string">'@'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">5</span>, COLS / <span class="number">2</span> - <span class="number">13</span>, <span class="string">"Press any key to continue..."</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> - <span class="number">1</span>, COLS / <span class="number">2</span> - <span class="number">13</span>, <span class="string">"I'm sorry, the game is over"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span>, COLS / <span class="number">2</span> - <span class="number">9</span>, <span class="string">"But expect you back"</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    refresh();</span><br><span class="line">    getch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  display_score函数：显示当前得分  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_score</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    move(<span class="number">11</span>, <span class="number">136</span>);</span><br><span class="line">    printw(<span class="string">"%d"</span>, score++);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  set_color函数：设置颜色  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_color</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_pair(<span class="number">1</span>, COLOR_GREEN, COLOR_GREEN);</span><br><span class="line">    init_pair(<span class="number">2</span>, COLOR_RED, COLOR_RED);</span><br><span class="line">    init_pair(<span class="number">3</span>, COLOR_WHITE, COLOR_WHITE);</span><br><span class="line">    init_pair(<span class="number">4</span>, COLOR_YELLOW, COLOR_BLACK);</span><br><span class="line">    init_pair(<span class="number">5</span>, COLOR_RED, COLOR_BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  set_ticker函数：设置间隔计时器(ms)  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_ticker</span><span class="params">(<span class="keyword">int</span> n_msecs)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_timeset</span>;</span>  </span><br><span class="line">    <span class="keyword">long</span> n_sec, n_usecs;  </span><br><span class="line">  </span><br><span class="line">    n_sec = n_msecs / <span class="number">1000</span>;      </span><br><span class="line">    n_usecs = (n_msecs % <span class="number">1000</span>) * <span class="number">1000L</span>;      </span><br><span class="line">    </span><br><span class="line">    new_timeset.it_interval.tv_sec = n_sec;   <span class="comment">/*  设置初始间隔  */</span>  </span><br><span class="line">    new_timeset.it_interval.tv_usec = n_usecs;  </span><br><span class="line"></span><br><span class="line">    new_timeset.it_value.tv_sec = n_sec;      <span class="comment">/*  设置重复间隔  */</span>  </span><br><span class="line">    new_timeset.it_value.tv_usec = n_usecs;  </span><br><span class="line">    <span class="keyword">return</span> setitimer(ITIMER_REAL, &amp;new_timeset, <span class="literal">NULL</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后说明一点：当你编译运行的时候需要链接至curses库哦，在编译命令后加上<code>-lcurses</code>就可以了</p><p>emmm，然后呢，希望大家能多多提出建议<code>^o^</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主要设计思路&quot;&gt;&lt;a href=&quot;#主要设计思路&quot; class=&quot;headerlink&quot; title=&quot;主要设计思路&quot;&gt;&lt;/a&gt;主要设计思路&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;主要数据结构：单链表&lt;/li&gt;
&lt;li&gt;蛇的移动：每次在蛇头添加2个节点，在蛇尾删除2个节点&lt;/li&gt;
&lt;li&gt;蛇的转向：通过一组方向坐标与蛇的位置坐标的运算来实现转向&lt;/li&gt;
&lt;li&gt;蛇吃食物：只在蛇头添加2个节点，而不必在蛇尾删除2个节点&lt;/li&gt;
&lt;li&gt;蛇的死亡：撞上边界或自身&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>编写一个程序，删除C语言程序中的所有注释</title>
    <link href="https://yaoer.me/2018/10/25/rcomment/"/>
    <id>https://yaoer.me/2018/10/25/rcomment/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2018-10-25T05:07:04.861Z</updated>
    
    <content type="html"><![CDATA[<p>这是[k&amp;r]第一章也就是导言后的一道习题，原题是这样的：</p><blockquote><p>编写一个程序，删除C语言程序中所有的注释语句。要正确处理带引号的字符与字符常量。在C语言中，注释不允许嵌套。</p></blockquote><a id="more"></a><p>我们简单分析如下：</p><ul><li><p>对于引号内的字符，我们原样输出即可，不过要注意其中 <strong><em>出现转义字符</em></strong> 时的情况。</p></li><li><p>对于<code>/* ... */</code>这样的注释处理起来是比较简单的，我们只需搜寻到配对的<code>/*</code>和<code>*/</code>，然后跳过它们中间的字符即可。</p></li><li><p>而对于<code>//</code>，则稍微有点麻烦。因为<code>//</code>虽然一般用作单行注释，但却可以用<code>\</code>连接为多行注释。</p></li></ul><p>那么什么样的<code>\</code>出现时应该被当作连接注释行呢？<br>答案很简单，<font color="red">即<code>\</code>之后直到<code>\n</code>全是空白符。</font>根据这个规则，我们可以很容易地处理<code>//</code>注释中<code>\</code>连接注释行的情况。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  删除c程序中的注释，我们假设输入的都是合法的c程序  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'/'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((d = getchar()) == <span class="string">'*'</span>)    </span><br><span class="line">                in_dcomment();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (d == <span class="string">'/'</span>)</span><br><span class="line">                in_scomment();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">putchar</span>(c);</span><br><span class="line">                <span class="built_in">putchar</span>(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'\''</span> || c == <span class="string">'\"'</span>)</span><br><span class="line">            echo_quote(c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">putchar</span>(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主函数负责接收字符流，并对之进行判断，然后交由各函数进行处理。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  in_scomment函数：处理单行注释  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_scomment</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != <span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'\\'</span>)   <span class="comment">/* 处理//注释，或者//用\连接为多行注释的情况  */</span></span><br><span class="line">            <span class="keyword">while</span> ((c = getchar()) != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isspace</span>(c)) &#123;</span><br><span class="line">                ungetc(c, <span class="built_in">stdin</span>);   <span class="comment">/*  压回多读入的字符，可能是\  */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当程序遇见<code>\</code>字符时，我们继续向后读取，如果直到遇见<code>\n</code>程序遇见的都是空白符，那就说明<code>\</code>在这里表示连接注释行了，即下一行也是注释行。</p><p>而这里有个细微的地方需要注意，<strong><em>在这种情况下，if中的while语句会抛弃读到的<code>\n</code>，当返回到最外层while语句时，它会紧接着从下一行重新读取，这样就跳过了当前行，并且把下一行也当作注释行了</em></strong>。<br>一旦<code>\</code>之后出现了非空白符，情况就有所不同了，<strong><em>这说明程序需要接着对这一行进行处理，我们压回多读入的字符，因为它可能是<code>\</code>，如果不压回就会出现问题。</em></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fjlasjl \\</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><blockquote><p>如果不压回多读入的<code>\</code>字符的话，程序将不能删除return 0;但它本来是需要删除的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  in_dcomment函数：处理多行注释  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_dcomment</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    c = getchar();</span><br><span class="line">    d = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c != <span class="string">'*'</span> || d != <span class="string">'/'</span>) &#123;  </span><br><span class="line">        c = d;</span><br><span class="line">        d = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对多行注释的处理只需找到与<code>/*</code>匹配的<code>*/</code>，然后跳过其中的内容即可。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  echo_quote函数：原样输出引号内的字符  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_quote</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(c);</span><br><span class="line">    <span class="keyword">while</span> ((d = getchar()) != c) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(d);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="string">'\\'</span>)            <span class="comment">/*  正确处理转义字符  */</span></span><br><span class="line">            <span class="built_in">putchar</span>(getchar());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>引号内如果出现了<code>\</code>字符，程序就要不加判断的输出它之后的一个字符，不然如果是<code>\&quot;</code>这种情况，就会使程序产生错误的判断，因为此时的<code>&quot;</code>只是一个普通字符，并不是字符串的结束字符。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是[k&amp;amp;r]第一章也就是导言后的一道习题，原题是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编写一个程序，删除C语言程序中所有的注释语句。要正确处理带引号的字符与字符常量。在C语言中，注释不允许嵌套。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>约瑟夫环问题详解</title>
    <link href="https://yaoer.me/2018/10/25/joseph/"/>
    <id>https://yaoer.me/2018/10/25/joseph/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2018-10-25T01:35:28.445Z</updated>
    
    <content type="html"><![CDATA[<p>我们先看一下对该问题的描述：</p><blockquote><p>已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。</p></blockquote><a id="more"></a><p>解决该问题通常有两种方法：</p><blockquote><ul><li><font color="red">模拟法</font>（模拟整个游戏的运行过程）<ul><li><strong><em>循环链表</em></strong></li><li><strong><em>数组</em></strong></li></ul></li><li><font color="red">数学公式法</font>（直接通过公式推导得出结果，不关心具体过程）</li></ul></blockquote><p>谈不上哪种更简单，只在于思考问题、解决问题的方式不同而已。</p><blockquote><ul><li>模拟法的时间复杂度为O(mn)，当n和m很大时，程序将很难在短时间内得到结果。<ul><li>模拟法的一个优点是：程序的设计思路很清晰。</li></ul></li><li>数学公式法的时间复杂度为O(n)。<ul><li>数学方法虽然使最终的程序编写起来很简单，但前提是，你得有足够强的抽象思维能力，能够得出最终的公式。</li></ul></li></ul></blockquote><p>下面我们给出以上各种方法的实现：</p><hr><h3 id="模拟法"><a href="#模拟法" class="headerlink" title="模拟法"></a>模拟法</h3><h4 id="循环链表模拟"><a href="#循环链表模拟" class="headerlink" title="循环链表模拟"></a>循环链表模拟</h4><blockquote><p>确切说来，我们具体使用的是单向循环链表。我们从1，2，3，…n给每个人编号。一旦他出列，我们就将他从链表中删去，直到剩下最后一个人，即为获胜者。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> number;     <span class="comment">/*  编号  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意的是删除操作。我们都知道，每个节点都有一个next指针指向它，为了将删除所有位置的节点看作一种通用的情况，我们需要一个指向next域的指针，即一个二级指针。而且在删除过程中，要注意保证链表不断裂。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *head, **np, *tmp;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"></span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((head = creat_cll(head, n)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">/*  初始化链表  */</span></span><br><span class="line">    <span class="keyword">for</span> (np = &amp;head-&gt;next; *np != head; np = &amp;(*np)-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> ((*np)-&gt;number == k)    <span class="comment">/*  找到开始报数的人  */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((*np)-&gt;next != *np) &#123;    <span class="comment">/*  剩下最后一个节点，循环终止  */</span></span><br><span class="line">        <span class="keyword">if</span> (k++ == m) &#123;     <span class="comment">/*  删除应该出列的人  */</span></span><br><span class="line">            tmp = (*np)-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(*np);</span><br><span class="line">            *np = tmp;</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            np = &amp;(*np)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (*np)-&gt;number);   <span class="comment">/*  打印出获胜者  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面的操作类似于单链表的创建，只是最后我们需要把链表的首尾连接起来而已。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  creat_cll函数：创建一个单向循环链表，并初始化  */</span></span><br><span class="line"><span class="function">Node *<span class="title">creat_cll</span><span class="params">(Node *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *<span class="keyword">new</span>, *pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pre = <span class="keyword">new</span> = head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;number = n;</span><br><span class="line">    <span class="keyword">while</span> (--n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = pre;</span><br><span class="line">        pre = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;number = n;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = <span class="keyword">new</span>;    <span class="comment">/*  连接链表的首尾  */</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环链表还有一种方法，就是采用惰性删除</p><blockquote><p>意思就是我们并不真正地删除链表节点，而只是将它标记为已删除状态。因为我们的编号都是大于0的数，所以一旦某个人出列，我们只需将他的number置为0即可。</p></blockquote><p>具体过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *head, *p;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"></span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((head = creat_cll(head, n)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = head-&gt;next; p != head; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;number == k)    <span class="comment">/*  找到开始报数的人  */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k++ == m) &#123;</span><br><span class="line">            p-&gt;number = <span class="number">0</span>;</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;    <span class="comment">/*  每次遍历链表的时候，需要跳过那些已出列的节点，即number域为0的节点  */</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!p-&gt;number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;number);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们并没有销毁链表，你可以自行加上该操作。</p><hr><h4 id="数组模拟"><a href="#数组模拟" class="headerlink" title="数组模拟"></a>数组模拟</h4><blockquote><p>数组模拟方法的难点在于我们要循环使用一个线性数组，其实稍微认真思考一下，也不是很难。每当遍历到数组末尾的时候，我们就从头重新开始遍历，一旦某个人出列，就将该处的值置为0，直到剩下最后一个人。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p, *q, </span><br><span class="line">    <span class="keyword">char</span> *eq;    <span class="comment">/*  指向数组末尾  */</span></span><br><span class="line">    <span class="keyword">int</span> n, m, k, i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">if</span> ((q = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">/*  为使用的数组分配内存空间  */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        q[i] = i + <span class="number">1</span>;    <span class="comment">/*  初始化数组  */</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    eq = q + n;</span><br><span class="line">    p = q + k - <span class="number">1</span>;     <span class="comment">/*  指向开始报数的人  */</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i++ == m) &#123;</span><br><span class="line">            *p = <span class="number">0</span>;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (++p &gt;= eq)    <span class="comment">/*  到达数组末尾后，就从头重新开始遍历  */</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!*p);    <span class="comment">/*  跳过已出列的人  */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数学公式法"><a href="#数学公式法" class="headerlink" title="数学公式法"></a>数学公式法</h3><p>利用下面这个递推公式，我们就能得到我们想要的结果。</p><script type="math/tex; mode=display">f(N,M)=(f(N-1,M)+M)modN</script><p>$f(N, M)$表示：N个人报数，杀掉报M的那个人，最终胜利者的编号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n;    <span class="comment">/* 总人数 */</span></span><br><span class="line">    <span class="keyword">int</span> m;    <span class="comment">/* 数到m出列 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        p = (p + m) % i;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"winner is %d\n"</span>, p + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们先看一下对该问题的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>堆及其应用</title>
    <link href="https://yaoer.me/2018/10/24/heap/"/>
    <id>https://yaoer.me/2018/10/24/heap/</id>
    <published>2018-10-23T16:00:00.000Z</published>
    <updated>2018-10-24T13:00:30.994Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>(二叉堆)是一个数组，它可以被看成一个近似的完全二叉树</em></strong>。树上的每个节点对应数组中的一个元素，除了最底层外，该树是完全充满的，而且是从左向右填充。下文如果不加限定的话，所提到的堆均指二叉堆。常见的堆还有斐波那契堆等。</p><p><img src="https://github.com/yaomer/pictures/blob/master/array.png?raw=true" alt=""><br><a id="more"></a></p><blockquote><p>数组的每个下标对应堆中的一个节点。而给定一个下标，我们可以很容易得到其父亲和儿子的下标。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉堆可以分为两种形式：<strong><em>最大堆（大根堆）和最小堆（小根堆）</em></strong> 。</p><blockquote><ul><li><strong><em>最大堆</em></strong> 是指除了根节点以外的其他节点i都要满足：<strong>A[parent(i)] &gt;= A[i]</strong>。也就是说某个节点的值至多与其父节点一样大</li><li><strong><em>最小堆</em></strong> 是指除了根节点以外的其他节点i都要满足：<strong>A[parent(i)] &lt;= A[i]</strong></li></ul></blockquote><p>由于最大堆和最小堆非常相似，所以我们下面只讨论一下最大堆。并且为了方便起见，下面给出的C代码中数组下标均从1开始。要做到这一点其实是很容易的，只需为数组多开辟一个元素的空间，然后令下标从1开始，不使用A[0]即可。</p><hr><h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><p>首先我们定义一个全局变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 表示有多少个堆元素存储在该数组中，也就是堆中的元素个数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> heapsize;</span><br></pre></td></tr></table></figure><p>在下面的代码中，我们略去了一些错误检查，比如在实际应用中，你必须保证heapsize的值是有效的，即 <strong><em>heapsize不能大于数组的长度。</em></strong></p><h4 id="维护堆的性质"><a href="#维护堆的性质" class="headerlink" title="维护堆的性质"></a>维护堆的性质</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  max_heap函数：维护最大堆的性质  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> l, r, largest;</span><br><span class="line">    </span><br><span class="line">    l = left(i);</span><br><span class="line">    r = right(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  找出a[i]、a[l]、a[r]中的最大值  */</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= heapsize &amp;&amp; a[l] &gt; a[i])</span><br><span class="line">        largest = l;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        largest = i;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= heapsize &amp;&amp; a[r] &gt; a[largest])</span><br><span class="line">        largest = r;</span><br><span class="line">    <span class="comment">/* 如果a[i]是最大的，那么以该节点为根的子树已满足最大堆的性质，函数结束；</span></span><br><span class="line"><span class="comment">     * 否则，最大元素是其某个孩子节点，我们交换a[i]和a[largest]，从而使a[i]</span></span><br><span class="line"><span class="comment">     * 及其孩子都满足最大堆的性质</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(a, i, largest);</span><br><span class="line">        <span class="comment">/* 当a[largest]成为a[i]之后，以该节点为根的子树可能会违反最大堆的性质</span></span><br><span class="line"><span class="comment">         * 所以要对该子树递归调用max_heap</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        max_heap(a, largest);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  swap函数：交换两个数  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[i]; </span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码中注释的已经非常清楚了， <strong><em><font color="red">我们通过让a[i]在最大堆中“逐级下降“，从而使得以a[i]为根节点的子树重新遵循最大堆的性质。</font></em></strong></p></blockquote><hr><p>下面我们举例说明一下，下图是<strong>max_heap(a, 2)，heapsize = 10</strong>的执行过程：</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap.png?raw=true" alt=""></p><blockquote><p>a[2]违背了最大堆的性质，因为它不大于它的孩子，所以要将它和它的孩子中最大的进行交换，即swap(a[2], a[4])。递归调用max_heap(a, 4, 10)，发现a[4]同样不满足最大堆的性质，所以要swap(a[4], a[9])。再递归调用max_heap(a, 9, 10)，发现以a[9]为根的子树满足最大堆的性质。</p></blockquote><hr><p>维护最小堆的性质与之类似，我们只需 <strong><em>将不满足最小堆性质的节点与其孩子中最小的一个进行交换，然后递归下降即可。直到遇见满足最小堆性质的节点。</em></strong></p><hr><h4 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  build_max_heap函数：构建一个最大堆  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*  a[n / 2]..a[n]中的元素都是树的叶节点，所以</span></span><br><span class="line"><span class="comment">     *  我们对树中的其他节点都调用一次max_heap即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    heapsize = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        max_heap(a, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>构建一个最大堆就是对于以a[n / 2] .. a[n]为根节点的每个子树，使它们分别都满足最大堆的性质，也就是对它们的根节点分别都执行一次max_heap即可。这样整棵树都满足了最大堆的性质，即构建成了一个最大堆</em></strong>。因为a[1] .. a[n / 2]都是树叶，显然满足最大堆的性质。</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap1.png?raw=true" alt=""></p><blockquote><p>如上图所示，要将该数组构建成为一个最大堆，只需对红色区域的节点各执行一次max_heap即可。</p></blockquote><hr><h3 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h3><p>堆主要有两个应用：<strong><em>堆排序</em></strong> 和 <strong><em>优先队列</em></strong>。</p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong><em>堆排序先利用build_max_heap将整个数组构建成为一个最大堆。因为数组中的最大元素总存放在根节点a[1]中，通过把它与a[n]交换，我们能将它放到正确的位置上。然后我们从堆中去掉该节点，可以通过减少heapsize的值来实现。新的根节点可能会违背最大堆的性质，所以我们对该节点执行max_heap以维护最大堆的性质，从而在a[1] .. a[n - 1]上构建出一个新的最大堆</em></strong>。堆排序会不断重复这一过程，直到堆的大小下降为2。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  heap_sort函数：堆排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    build_max_heap(a, n);   <span class="comment">/*  将数组构建为一个最大堆  */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">        swap(a, <span class="number">1</span>, i);    <span class="comment">/*  将最大堆元素与堆中的最后一个元素交换  */</span></span><br><span class="line">        heapsize--;      <span class="comment">/*  从堆中去掉a[i]，即最大堆元素  */</span></span><br><span class="line">        max_heap(a, <span class="number">1</span>);  <span class="comment">/*  每次在剩余节点上构建一个新的最大堆  */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>我们这里举两个例子 <strong>(i = 10 和 i = 9)</strong> 来说明一下排序过程。</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap2.png?raw=true" alt=""></p><p><img src="https://github.com/yaomer/pictures/blob/master/heap3.png?raw=true" alt=""></p><blockquote><p>我们先将a[1]与a[10]交换，然后从堆中去掉a[10]，a[1]并不满足最大堆的性质，所以我们对它调用一次max_heap，沿红色路径进行调整，使之重新满足最大堆的性质。调整后的结果为：</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/heap4.png?raw=true" alt=""></p><p><img src="https://github.com/yaomer/pictures/blob/master/heap5.png?raw=true" alt=""></p><blockquote><p>我们将a[1]与a[9]交换，然后从堆中去掉a[9]，a[1]并不满足最大堆的性质，所以我们对它调用一次max_heap，沿红色路径进行调整，使之重新满足最大堆的性质。调整后的结果为：</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/heap6.png?raw=true" alt=""></p><hr><p>堆排序过程：<br><img src="https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif" alt=""></p><hr><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>和堆一样，优先队列也有两种形式：最大优先队列和最小优先队列。这里我们只讨论最大优先队列的有关操作。显而易见，在这里它就是基于最大堆来实现的。</p><p>最大优先队列的应用有很多，其中有一个就是<strong>作业调度问题</strong>。最大优先队列记录将要执行的各个作业以及它们之间的相对优先级。当一个作业完成或者被中断后，调度器从所有等待的作业中选出具有最高优先级的作业来执行。在任何时候，调度器可以把一个新作业加入到队列中。</p><h5 id="返回最大堆元素"><a href="#返回最大堆元素" class="headerlink" title="返回最大堆元素"></a>返回最大堆元素</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  topheap函数：返回最大堆元素  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topheap</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扩充堆"><a href="#扩充堆" class="headerlink" title="扩充堆"></a>扩充堆</h5><p>扩充堆就是将一个新的元素插入到堆中。具体方法就是：<strong><em>我们先对堆进行扩充，可以通过增加heapsize的值来实现。然后将待插入的元素key放到扩充后的位置上去，即a[heapsize] = key。接下来对于节点key，我们沿树向上进行调整，如果它的值大于它的父节点的值，我们就将它与其父节点进行交换，… 直到它的值不大于它的父节点的值，这时就满足了最大堆的性质，即将key插入到了堆中正确的位置上。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  addheap函数：在堆中插入一个元素key  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addheap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    i = ++heapsize;</span><br><span class="line">    a[i] = key;</span><br><span class="line">    j = parent(i);</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span> &amp;&amp; a[i] &gt; a[j]) &#123;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">        i = j;    <span class="comment">/*  更新i的值  */</span></span><br><span class="line">        j = parent(i);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们要把<strong>15</strong>插入到下列最大堆中</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap2.png?raw=true" alt=""></p><blockquote><p>它的过程如下：即将新插入的节点15沿红色路径向上进行调整，这个过程我们上面已经详细地描述过了。</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/heap7.png?raw=true" alt=""></p><p>最后的结果为：</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap8.png?raw=true" alt=""></p><hr><h5 id="缩减堆"><a href="#缩减堆" class="headerlink" title="缩减堆"></a>缩减堆</h5><p>缩减堆就是去掉堆中的最大元素。具体思想和堆排序的思想很相似。<strong><em>就是把堆的最后一个元素a[heapsize]赋给最大堆元素a[1]，然后缩减堆。对于新的a[1]，调用max_heap使之满足最大堆的性质即可。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  delheap函数：去掉并返回最大堆元素  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delheap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heapsize &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"heap underflow\n"</span>);</span><br><span class="line">    max = a[<span class="number">1</span>];</span><br><span class="line">    a[<span class="number">1</span>] = a[heapsize--];</span><br><span class="line">    <span class="comment">/*  将堆的最后一个元素赋给最大堆元素，然后缩减堆，即去除堆的最后一个元素  */</span></span><br><span class="line">    max_heap(a, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缩减堆的过程可以参照堆排序的过程去理解。</p><hr><p>参考资料：<br>[算法导论][Thomas H.Cormen / Charles E.Leiserson / Ronald L.Rivest / Clifford Stein]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;(二叉堆)是一个数组，它可以被看成一个近似的完全二叉树&lt;/em&gt;&lt;/strong&gt;。树上的每个节点对应数组中的一个元素，除了最底层外，该树是完全充满的，而且是从左向右填充。下文如果不加限定的话，所提到的堆均指二叉堆。常见的堆还有斐波那契堆等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yaomer/pictures/blob/master/array.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数组与指针那点事</title>
    <link href="https://yaoer.me/2018/10/23/arr_pointer/"/>
    <id>https://yaoer.me/2018/10/23/arr_pointer/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-10-24T05:31:15.071Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><p>说起数组名？绝大多数初学者是感到非常疑惑的，甚至哪怕是学习了好几年自以为懂的人，恐怕也不能够说得明明白白、清清楚楚。那么，它到底是个什么东西呢？</p><a id="more"></a><p><strong><em><font color="red">首先，我想先声明一点：数组名绝不是指针，也并不是常量指针。</font></em></strong></p><p>我们先以一个简单的赋值为例，说明一下<code>左值</code>和<code>右值</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y;</span><br><span class="line">这个语句的含义是：把y中的值放入x所代表的地址中去</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>左值</th><th>右值</th></tr></thead><tbody><tr><td>在这个上下文环境里，符号x的含义是x所代表的地址</td><td>在这个上下文环境中，符号y的含义是y所代表的地址中的内容</td></tr><tr><td>在编译时可知，表示存储结果的地方，即内存中的位置</td><td>直到运行时才可知，表示的是一个“值”</td></tr></tbody></table></div><p>这时就出现了一个奇怪的现象：我们都知道，只有变量才可以作为左值，而数组名是不能作为左值的。那么数组名不是变量的话，是什么呢？</p><p>如果我们查看一下对应的汇编代码，结果是显而易见的。我们会发现，汇编代码里并没有出现数组名这个东西，<strong><em>数组名只是一个符号而已，标识数组在内存中的位置</em></strong>。但是在某些情况下，编译器会对它进行隐式的转换。<strong><em><font color="red">或者我们可以像指针类型一样，将数组名理解为一个数据类型——数组类型，表示一段连续的内存空间。</font></em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">a表示：<span class="keyword">int</span> [<span class="number">5</span>]，即可以存储<span class="number">5</span>个整形元素的一段连续的内存空间。</span><br></pre></td></tr></table></figure><p>我们看下面这样一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;b;</span><br><span class="line"></span><br><span class="line">    a = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用clang编译的话，会报如下错误</p><p><code>error: array type &#39;int [2]&#39; is not assignable</code></p><hr><blockquote><ul><li>sizeof(a)，返回整个数组的长度。</li><li>&amp;a，得到一个指向整个数组的指针，即int (*)[]。</li><li>在函数参数中，数组名被转换为一个普通的指针</li><li><font color="red">在除此之外的其他情况下，</font><font color="green">数组名将被隐式转换为一个指向数组首元素的常量指针。</font></li></ul></blockquote><p>有效的指针运算方式有如下几种：</p><blockquote><ul><li>相同类型指针之间的赋值运算。</li><li>指针同整数间的加法或减法运算。</li><li>指向相同数组中元素的两个指针间的减法或比较运算。</li><li>将指针赋为0或指针与0之间的比较运算。</li><li>最后注意一点：(void *类型指针可以与其他类型指针混用）</li></ul></blockquote><hr><h3 id="数组和指针的区别"><a href="#数组和指针的区别" class="headerlink" title="数组和指针的区别"></a>数组和指针的区别</h3><p>我们先看一下这样一组声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> *x;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> y[];</span><br></pre></td></tr></table></figure><p>第一条语句声明x是一个指向int类型的指针；第二条语句声明y是一个int类型的数组，长度尚未确定，<strong><em>其存储在别处定义。</em></strong></p><p>那么，什么是声明，什么是定义呢？</p><div class="table-container"><table><thead><tr><th>声明</th><th>定义</th></tr></thead><tbody><tr><td>可以出现在多个地方</td><td>只能出现在一个地方</td></tr><tr><td>描述对象的类型，用于指代其他地方定义的对象</td><td>确定对象的类型并为之分配内存</td></tr></tbody></table></div><p>两者的主要区别在于：</p><blockquote><ul><li>声明：它所说明的并非自身，而是描述其他地方创建的对象。</li><li>定义：它为对象分配内存。</li></ul></blockquote><p><strong><em>总而言之，定义是声明的一个子集。</em></strong></p><p><strong><em>extern对象声明只是告诉编译器对象的类型和名字，对象的内存分配则在别处进行。</em></strong></p><hr><p>我们再看一个这样的问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file <span class="number">1</span>: <span class="keyword">int</span> logo[<span class="number">100</span>];</span><br><span class="line">file <span class="number">2</span>: <span class="keyword">extern</span> <span class="keyword">int</span> *logo;</span><br></pre></td></tr></table></figure><p>很明显，在file 2中的写法是错误的。正确写法应当是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file <span class="number">2</span>: <span class="keyword">extern</span> <span class="keyword">int</span> logo[]; <span class="keyword">or</span> <span class="keyword">extern</span> <span class="keyword">int</span> logo[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p>可能有人会问：这有什么错误？数组和指针不是可以互换吗？答案是<font color="red">数组下标<strong><em>表达式</em></strong>总是可以改写为指针加偏移量的表达式。</font>而且也确实存在一种数组和指针完全相同的上下文环境，但并不是所有情况下都是如此。</p><p><strong>[k&amp;r]</strong>第二版[99]中有相关的描述：<font color="red">作为函数定义的形式参数，</font><strong>char s[]</strong>和<strong>char *s</strong>是等价的。</p><hr><h3 id="数组和指针分别如何访问的？"><a href="#数组和指针分别如何访问的？" class="headerlink" title="数组和指针分别如何访问的？"></a>数组和指针分别如何访问的？</h3><blockquote><ul><li><font color="red">编译器为每个变量分配一个地址，这个地址在<strong>编译时</strong>可知，</font>而且该变量在运行时一直保存于该地址。<font color="red">相反，存储于变量中的值只有在<strong>运行时</strong>才可知。</font>如果需要用到变量中存储的值，编译器就发出指令从指定地址读入变量值并将它放入寄存器中。</li><li>这里的关键之处在于：<strong><em>如果编译器需要一个地址（可能还需要加上偏移量）来执行某种操作，它就可以直接进行操作，并不需要额外的指令首先取得具体的地址。相反，对于指针，必须在运行是取得它的当前值，然后才能对它进行解引用操作。</em></strong></li></ul></blockquote><h4 id="对数组下标的引用"><a href="#对数组下标的引用" class="headerlink" title="对数组下标的引用"></a>对数组下标的引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = <span class="string">"hello"</span>;</span><br><span class="line">c = s[i];</span><br></pre></td></tr></table></figure><p>假设编译器符号表中有一个地址100</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">取出i的值，将它与100相加</span><br><span class="line">取出地址（100 + i）中的内容</span><br></pre></td></tr></table></figure><p>这就是为什么<strong>extern int logo[100]</strong> 与<strong>extern int logo[]</strong> 等价的原因。这两个声明都提示logo是一个数组，也就是一个内存地址。<strong><em>编译器并不需要知道数组有多长，因为它只产生偏离起始地址的偏移地址</em></strong>（是否会越界访问取决于程序员本身，编译器并不会进行这样的检查）。访问数组中的一个字符，只需简单地将logo的地址加上下标即可，需要的字符就在该地址中。</p><hr><h4 id="对指针的引用"><a href="#对指针的引用" class="headerlink" title="对指针的引用"></a>对指针的引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br><span class="line">c = *p;</span><br></pre></td></tr></table></figure><p>假设编译器符号表中有一个地址1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">取出地址1024中的内容，假设是5076</span><br><span class="line">取出地址5076中的内容，就是&apos;h&apos;</span><br></pre></td></tr></table></figure><hr><h4 id="如果定义为指针，却以数组下标方式引用，会发生什么？"><a href="#如果定义为指针，却以数组下标方式引用，会发生什么？" class="headerlink" title="如果定义为指针，却以数组下标方式引用，会发生什么？"></a>如果定义为指针，却以数组下标方式引用，会发生什么？</h4><p>我们都知道，数组的引用是对内存的直接引用，而指针是对内存执行间接引用的。下面我们来分析一下对一个指针执行直接引用操作，会发生什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br><span class="line">c = p[i];</span><br></pre></td></tr></table></figure><p>假设编译器符号表中有一个p，它的地址为1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">取出地址1024中的内容，假设为5076</span><br><span class="line">取得i的值，并将它与5076相加</span><br><span class="line">取出地址（5076 + i）中的内容</span><br></pre></td></tr></table></figure><p>可见，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>; ... p[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello"</span>; ... a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>这两种情况下，都可以取得字符 <strong>‘e’</strong>，但两者的途径非常不一样。</p><p>当书写了<strong>extern char *p</strong>，然后以 <strong>p[1]</strong> 的方式来引用其中的元素时，其实质是对数组下标的引用和对指针的引用两种访问方式的组合。</p><p>总结一下上面的访问过程：</p><blockquote><ul><li>取得符号表中p的地址，提取存储于此处的指针</li><li>把下标所表示的偏移量与指针的值相加，产生一个偏移地址</li><li>取得该地址中的内容</li></ul></blockquote><p><strong><em>如果把p声明为一个指针，那么不管p原先的定义是指针还是数组，都会按照上面所示的三个步骤进行操作，但只有当p原来定义为指针时这个方法才是正确的。</em></strong></p><hr><h4 id="定义为数组，却以指针的方式引用，会发生什么？"><a href="#定义为数组，却以指针的方式引用，会发生什么？" class="headerlink" title="定义为数组，却以指针的方式引用，会发生什么？"></a>定义为数组，却以指针的方式引用，会发生什么？</h4><p>即下列情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file <span class="number">1</span>: <span class="keyword">char</span> p[<span class="number">10</span>];</span><br><span class="line">file <span class="number">2</span>: <span class="keyword">extern</span> <span class="keyword">char</span> *p;</span><br></pre></td></tr></table></figure><p>当以 <strong>p[i]</strong> 的方式访问数组中的内容时：<strong><em>首先，我们取得符号表中p的地址，提取该地址中的内容，很明显会是一个字符。但按照上面的方法，编译器却会把它当作一个地址，把ascii字符解释为地址显然是驴头不对马嘴的。如果真在程序中这样做的话，很可能会污染程序地址空间中的内容，并在以后出现莫名其妙的错误。</em></strong></p><hr><h3 id="数组和指针在什么情况下是相同的"><a href="#数组和指针在什么情况下是相同的" class="headerlink" title="数组和指针在什么情况下是相同的"></a>数组和指针在什么情况下是相同的</h3><p>在实际应用中，数组和指针可以互换的情况要比两者不可互换的情况更为常见。</p><blockquote><ul><li>数组<ul><li>声明<ul><li>extern，如extern char a[]; 不能改写成指针的形式</li><li>定义，如char a[10]; 不能改写成指针的形式</li><li>函数参数，你可以随自己喜欢，选择数组或指针形式</li></ul></li><li>在表达式中使用<ul><li>如c = a[i]; 你可以随自己喜欢，选择数组或指针形式</li></ul></li></ul></li></ul></blockquote><p><strong><em>所有作为函数参数的数组名总是可以通过编译器转换为指针。在其他情况下，数组的声明就是数组，指针的声明就是指针，两者不能混淆。但在使用数组时，两者是可以互换的。</em></strong></p><hr><h3 id="三个规则"><a href="#三个规则" class="headerlink" title="三个规则"></a>三个规则</h3><h4 id="在表达式中，对数组的引用总是可以改写为对指针的引用"><a href="#在表达式中，对数组的引用总是可以改写为对指针的引用" class="headerlink" title="在表达式中，对数组的引用总是可以改写为对指针的引用"></a>在表达式中，对数组的引用总是可以改写为对指针的引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], *p, i = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>我们可以通过以下任何一种方式访问a[i]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = a; p[i];</span><br><span class="line">p = a; *(p + i);</span><br><span class="line">p = a + i; *p;</span><br></pre></td></tr></table></figure><p>事实上，可以采用的方法更多。对数组的引用a[i]在编译时总是被编译器改写为*(a + i)的形式。C标准要求编译器必须具有这个概念性的行为。也许遵循这个规则的捷径就是记住<strong><em><font color="red">[] 表示一个取下标运算符，就像 + 表示加法运算符一样。</font></em></strong></p><p>取下标运算符取一个整数和一个指向T类型的指针，所产生的结果类型是T，一个在表达式中的数组名就变成了一个指针（除过本文开始描述的几种特殊情况）。你只要记住：在表达式中，指针和数组是可以互换的，因为它们在编译器中的最终形式都是指针，而且都可以进行取下标操作。<strong><em>就像加法一样，取下标操作符的操作数是可以互换的，</em></strong>即<font color="red">a[5] 和 5[a] 这两种情况下都是正确的。</font>第二种情况除了能把新手搞晕以外，实在没什么实际意义。</p><blockquote><p>编译器自动把下标值的步长调整为数组元素的大小，在对地址进行加法操作之前，编译器会负责计算每次增加的步长，这也就是指针之所以有类型限制的原因所在。</p></blockquote><hr><h4 id="C语言把数组下标作为指针的偏移量"><a href="#C语言把数组下标作为指针的偏移量" class="headerlink" title="C语言把数组下标作为指针的偏移量"></a>C语言把数组下标作为指针的偏移量</h4><p><font color="red">在通常情况下，使用指针比使用数组”更有效率“这个说法是错误的。</font>现代的编译器常常会对代码进行优化，两种访问方式所产生的代码不具有显著的差别。但不管怎样，数组下标是定义在指针的基础上的，所以编译器常常将它转换为更有效率的指针表达式形式。</p><p><strong><em>C语言把数组下标改写成指针加偏移量的形式的根本原因是：<font color="red">指针和偏移量是底层硬件所使用的基本模型。</font></em></strong></p><hr><h4 id="作为函数参数的数组名等同于指针"><a href="#作为函数参数的数组名等同于指针" class="headerlink" title="作为函数参数的数组名等同于指针"></a>作为函数参数的数组名等同于指针</h4><p>我们首先解释两个术语：</p><blockquote><ul><li>实参：在实际调用一个函数时传递给它的值</li><li>形参：它是一个变量，在函数定义或函数声明中定义</li></ul></blockquote><p>当用一个数组名作为参数时，由于效率原因，编译器只向该函数传递数组的地址，而不是整个数组的拷贝。</p><hr><h3 id="数组形参是如何被引用的？"><a href="#数组形参是如何被引用的？" class="headerlink" title="数组形参是如何被引用的？"></a>数组形参是如何被引用的？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun(<span class="keyword">char</span> p[]);</span><br><span class="line">fun(<span class="keyword">char</span> *p);</span><br></pre></td></tr></table></figure><p>假设编译器符号表显示p可以取地址，从堆栈指针偏移一定位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从堆栈指针偏移一定位置的地方找到函数的活动记录（栈桢），取出实参，假设为1024</span><br><span class="line">取得i的值，并与1024相加</span><br><span class="line">取出地址（1024 + i）中的内容</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br>[C专家编程][Peter Van Der Linden]</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组名&quot;&gt;&lt;a href=&quot;#数组名&quot; class=&quot;headerlink&quot; title=&quot;数组名&quot;&gt;&lt;/a&gt;数组名&lt;/h3&gt;&lt;p&gt;说起数组名？绝大多数初学者是感到非常疑惑的，甚至哪怕是学习了好几年自以为懂的人，恐怕也不能够说得明明白白、清清楚楚。那么，它到底是个什么东西呢？&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>简单计算器</title>
    <link href="https://yaoer.me/2018/10/23/calculator/"/>
    <id>https://yaoer.me/2018/10/23/calculator/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-10-24T13:02:59.933Z</updated>
    
    <content type="html"><![CDATA[<p>设计要求：</p><blockquote><p>输入一个只含有+、-、<em>、/、和%运算符的数学表达式，然后计算出其值；并且要能够处理圆括号。<br>例如：2 + 3 </em> (4 - 2)</p></blockquote><a id="more"></a><p>分析过程：</p><blockquote><ul><li>我们都知道后缀表达式是非常符合计算机的计算方式的，因为它不用考虑优先级的问题，只需要从左到右依次计算即可。</li><li>所以我们的整体思路是：<strong><em>先把输入的中缀表达式转换为后缀表达式，然后再计算出它的值。</em></strong></li></ul></blockquote><p>下面是程序的具体流程：</p><blockquote><ul><li>每次调用exp_trans函数读取一行输入，将其中的中缀表达式转换为后缀表达式，并保存在全局数组expr中；而getop函数则每次从expr中读取字符，解析生成的后缀表达式，最后借用stack计算出它的值。</li><li>为了方便计算后缀表达式，我们在解析生成的后缀表达式时对其格式作了一点简单的调整，即在每个运算符或操作数之间都加上了空格。</li><li>还应当注意的是：浮点数不能直接和0进行比较。</li></ul></blockquote><hr><p>计算后缀表达式的算法是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (下一个运算符或操作数不是EOF)</span><br><span class="line">    <span class="keyword">if</span> (是数)</span><br><span class="line">        将该数压入到栈中</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (是运算符)</span><br><span class="line">        弹出所需数目的操作数</span><br><span class="line">    执行运算</span><br><span class="line">        将结果压入到栈中</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (是\n)</span><br><span class="line">        弹出并打印栈顶值</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        出错</span><br></pre></td></tr></table></figure><hr><p>下面给出代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXEXP 200          <span class="comment">/*  允许输入的中缀表达式的最大长度  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXOP  20           <span class="comment">/*  运算符或操作数的最大长度  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER <span class="meta-string">'0'</span>          <span class="comment">/*  标识找到一个数  */</span></span></span><br></pre></td></tr></table></figure><blockquote><p>主函数主要控制表达式的计算，值得一提的是，这里便是switch语句的一个典型应用</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">main.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> expr[MAXEXP];   <span class="comment">/*  存储转换后的后缀表达式  */</span></span><br><span class="line"><span class="keyword">int</span> li = <span class="number">0</span>;         <span class="comment">/*  expr数组的索引  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[MAXOP];    <span class="comment">/*  存储获取的运算符或操作数  */</span></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">double</span> op2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((type = getop(s)) != EOF)</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> NUMBER:</span><br><span class="line">            push(atof(s));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            push(pop() + pop());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">            push(pop() * pop());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            op2 = pop();</span><br><span class="line">            push(pop() - op2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            op2 = pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(op2) &gt; DBL_EPSILON)</span><br><span class="line">                push(pop() / op2);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"error: zero divisor\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">            op2 = pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(op2) &gt; DBL_EPSILON)</span><br><span class="line">                push(<span class="built_in">fmod</span>(pop(), op2));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"error: zero divisor\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t%.8g\n"</span>, pop());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error: unknow command %s\n"</span>, s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后<strong>exp_trans</strong>完成表达式的转换，转换过程也是利用栈来完成的，和最终计算表达式是用的同一个栈。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">expts.c</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  遇见数字，输出；遇见操作符，入栈；遇见比栈顶操作符优先级更低的，弹出栈中比遇见的操作符优先级高的；</span></span><br><span class="line"><span class="comment"> *  遇见')'，弹出栈中'('之后的所有操作符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  exp_trans函数：将中缀表达式转换为后缀表达式   */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exp_trans</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, i;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c) || <span class="built_in">isdigit</span>(c) || c == <span class="string">'.'</span>) &#123;        <span class="comment">/*  原样保存空白符和数字  */</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!isempty()) &#123;        <span class="comment">/*  遇见\n，弹出栈中所有操作符  */</span></span><br><span class="line">                    expr[i++] = pop();</span><br><span class="line">                    expr[i++] = <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            expr[i++] = c;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op_prior(c) || c == <span class="string">')'</span>) &#123;    <span class="comment">/*  是运算符或')'  */</span></span><br><span class="line">            <span class="keyword">if</span> (isempty() &amp;&amp; c != <span class="string">'-'</span>) &#123;</span><br><span class="line">                push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!isempty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (top() == <span class="string">'('</span>) &#123;</span><br><span class="line">                        pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    expr[i++] = pop();</span><br><span class="line">                    expr[i++] = <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;       <span class="comment">/*  判断是负号还是减号  */</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c = getchar())) &#123;</span><br><span class="line">                        expr[i++] = <span class="string">'-'</span>;</span><br><span class="line">                        expr[i++] = c;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ungetc(c, <span class="built_in">stdin</span>);</span><br><span class="line">                        c = <span class="string">'-'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!isempty() &amp;&amp; top() != <span class="string">'('</span> &amp;&amp; op_prior(top()) &gt;= op_prior(c)) &#123;</span><br><span class="line">                    expr[i++] = pop();</span><br><span class="line">                    expr[i++] = <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    expr[i++] = c;</span><br><span class="line">    expr[i] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  op_prior函数：返回对应操作符的优先级   */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_prior</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们每次调用<strong>exp_trans</strong>函数读取一行，然后<strong>getop</strong>函数用于从中解析需要的运算符和操作数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">getop.c</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  getop函数：获取下一个运算符或操作数    */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getop</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (expr[li] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">        exp_trans();    <span class="comment">/* 如果刚开始时未读入或读到expr的末尾，就调用exp_trans函数读入新的一行  */</span></span><br><span class="line">        li = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((s[<span class="number">0</span>] = expr[li]) == <span class="string">' '</span> || expr[li] == <span class="string">'\t'</span>)</span><br><span class="line">        li++;</span><br><span class="line">    s[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(expr[li]) &amp;&amp; !<span class="built_in">islower</span>(expr[li]) &amp;&amp; expr[li] != <span class="string">'.'</span> &amp;&amp; expr[li] != <span class="string">'-'</span>)</span><br><span class="line">        <span class="keyword">return</span> expr[li++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expr[li] == <span class="string">'-'</span>) &#123;      <span class="comment">/*  判断‘-’是减号还是负号  */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(expr[++li]) || expr[li] == <span class="string">'.'</span>)</span><br><span class="line">            *++s = expr[li];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'-'</span>;</span><br><span class="line">    &#125;     <span class="comment">/*  收集数  */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(expr[li]))</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*++s = expr[++li]))</span><br><span class="line">            ;</span><br><span class="line">    <span class="keyword">if</span> (expr[li] == <span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*++s = expr[++li]))</span><br><span class="line">            ;</span><br><span class="line">    *s = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> NUMBER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是栈的实现了，很简单，没什么好说的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val[MAXVAL];    <span class="comment">/*  值栈  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;    <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将c压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull())</span><br><span class="line">        val[++sp] = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出并返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp--];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：只返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isfull函数：判断栈是否已满  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isempty函数：判断栈是否为空  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://github.com/yaomer/pictures/blob/master/v7.png?raw=true" alt=""></p><hr><p>参考资料：<br>[C程序设计语言][K&amp;R]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个只含有+、-、&lt;em&gt;、/、和%运算符的数学表达式，然后计算出其值；并且要能够处理圆括号。&lt;br&gt;例如：2 + 3 &lt;/em&gt; (4 - 2)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>栈的应用之表达式转换</title>
    <link href="https://yaoer.me/2018/10/23/expr/"/>
    <id>https://yaoer.me/2018/10/23/expr/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-10-24T00:57:02.216Z</updated>
    
    <content type="html"><![CDATA[<h3 id="中缀转后缀表达式"><a href="#中缀转后缀表达式" class="headerlink" title="中缀转后缀表达式"></a>中缀转后缀表达式</h3><p>实现的方法很简单：就是用栈来实现。</p><p>具体思路如下：</p><a id="more"></a><blockquote><ul><li>如果是数，我们就直接输出</li><li>是操作符，我们就弹出栈中比它优先级更高的操作符，然后再将它入栈</li><li>是’ ( ‘，直接入栈</li><li>是 ’ ) ‘ ，我们就弹出栈中 ‘ ( ‘ 之后的所有操作符</li><li>遇见 ‘ - ‘ 时，要判断它是负号还是减号</li><li>遇见 ’ \n ‘ ，弹出栈中所有的操作符</li></ul></blockquote><p>为了清晰美观起见，我们在输出的后缀表达式中的每个运算符或操作数之间加上了一个空格</p><p>下面是代码，都有很清晰的注释：</p><blockquote><p>首先是主函数，控制整个转换过程，当然也可以用一个函数来实现，不过这里是为了说明问题，没有必要那样。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  将中缀表达式转换为后缀表达式  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) || c == <span class="string">'.'</span>) &#123;    <span class="comment">/*  是数，就直接输出  */</span></span><br><span class="line">            <span class="built_in">putchar</span>(c);</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c = getchar()) || c == <span class="string">'.'</span>)</span><br><span class="line">                <span class="built_in">putchar</span>(c);</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">            ungetc(c, <span class="built_in">stdin</span>);     <span class="comment">/*  将多读入的字符压回到输入中  */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op_prior(c) || c == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isempty() &amp;&amp; c != <span class="string">'-'</span>)</span><br><span class="line">                push(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;     <span class="comment">/*  遇见')'，弹出栈中'('之后的所有运算符  */</span></span><br><span class="line">                <span class="keyword">while</span> (!isempty() &amp;&amp; top() != <span class="string">'('</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c "</span>, pop());</span><br><span class="line">                <span class="keyword">if</span> (!isempty())</span><br><span class="line">                    pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;     <span class="comment">/*  判断'-'是负号还是减号  */</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c = getchar())) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"-%c"</span>, c);</span><br><span class="line">                        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c = getchar()) || c == <span class="string">'.'</span>)</span><br><span class="line">                            <span class="built_in">putchar</span>(c);</span><br><span class="line">                        <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">                        ungetc(c, <span class="built_in">stdin</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ungetc(c, <span class="built_in">stdin</span>);</span><br><span class="line">                        c = <span class="string">'-'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;     <span class="comment">/*  栈顶运算符的优先级应当低于当前读入的运算符的优先级  */</span></span><br><span class="line">                <span class="keyword">while</span> (!isempty() &amp;&amp; top() != <span class="string">'('</span> &amp;&amp; op_prior(top()) &gt;= op_prior(c))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c "</span>, pop());</span><br><span class="line">                push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;    <span class="comment">/*  遇见换行符时，弹出栈中所有的运算符  */</span></span><br><span class="line">            <span class="keyword">while</span> (!isempty())</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c "</span>, pop());</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于如何返回对应操作符的优先级，我们可以用简单的数字来表示操作符的优先级，如果你想要实现更多的功能，你可以直接在<strong>op_prior</strong>函数中添加更多的操作符。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  op_prior函数：返回对应运算符的优先级  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_prior</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后便是所用到的主要的数据结构——栈了，这里很容易想到的便是用数组来实现堆栈，而非链表。原因也很简单： <strong><em><font color="red">在每一时刻，栈中的操作符数量总不会太多，栈空间用尽的可能性非常小。</font></em></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val[MAXVAL];    <span class="comment">/*  值栈  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;    <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull())</span><br><span class="line">        val[++sp] = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp--];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://github.com/yaomer/pictures/blob/master/v5.png?raw=true" alt=""></p><hr><h3 id="后缀转中缀表达式"><a href="#后缀转中缀表达式" class="headerlink" title="后缀转中缀表达式"></a>后缀转中缀表达式</h3><p>同样是用栈来实现的，有点类似于计算后缀表达式，但具体过程还是有点不同的。实现思路如下：</p><blockquote><ul><li>如果是数，就将它压入栈中</li><li>如果是运算符，就弹出对应数目的操作数，<font color="red">然而在这里我们并不计算该表达式，而是将它整个压入到栈中</font></li><li>我们都知道后缀表达式不存在优先级问题，但中缀表达式是需要考虑优先级的，因此，<strong><em>在转换过程中，我们需要在恰当的地方加上括号来保证运算过程的正确性</em></strong></li><li>对于如何加括号的问题，我是这么想的：例如中缀表达式 <strong>a  *  (b  +  c)</strong> 转换为后缀是 <strong>a  b  c  +  *</strong> ，当我们将 <strong>a  b  c  +  *</strong> 转换回去的时候就需要在  <strong>b  +  c</strong> 外面加上括号。<strong><em>如果当前运算符的优先级比上一个运算符的优先级要高，我们就给栈顶的两个子表达式加上括号。</em></strong></li><li>最后我们弹出栈顶表达式即可</li></ul></blockquote><p>思路大概就是这样，下面我会结合代码详细说明一下。</p><blockquote><p>同样，我们在主函数中控制整个转换过程，转换过程应当很简单。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXEXP 1000           <span class="comment">/*  输入的表达式的最大长度  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXOP  100            <span class="comment">/*  运算符或操作数的最大长度  */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER <span class="meta-string">'0'</span>            <span class="comment">/*  标识找到一个数  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  将后缀表达式转换为中缀表达式  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> lastc;</span><br><span class="line">    <span class="keyword">char</span> s[MAXEXP];      <span class="comment">/*  存储转换后的表达式  */</span></span><br><span class="line">    <span class="keyword">char</span> *op2;</span><br><span class="line"></span><br><span class="line">    lastc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = getop(s)) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (c == NUMBER)     <span class="comment">/*  是数  */</span></span><br><span class="line">            push(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op_prior(c)) &#123;     <span class="comment">/*  是运算符  */</span></span><br><span class="line">            op2 = top();</span><br><span class="line">            pop();</span><br><span class="line">            cat_exp(top(), s, op2, c, lastc);</span><br><span class="line">            push(s);</span><br><span class="line">            lastc = c;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, top());</span><br><span class="line">            pop();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>getop函数主要用于解析输入参数，将它们分解为运算符或操作数，为了后续的处理，我们也做了一些额外的工作，我们用空格将每个运算符或操作数分隔开。当然在处理输入时，它会丢弃多余的空白符，但如果你不加分隔符的话，它会帮你加上的。</li><li>op_prior函数很简单，我们在中缀转后缀表达式的过程中用到过它，这里和那里的是相同的</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  getop函数：从输入中获取下一个运算符或操作数  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getop</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, i;</span><br><span class="line">              </span><br><span class="line">    <span class="keyword">while</span> ((s[<span class="number">0</span>] = c = getchar()) == <span class="string">' '</span> || c == <span class="string">'\t'</span>)</span><br><span class="line">        ;     </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">'.'</span>) &#123;</span><br><span class="line">        s[<span class="number">1</span>] = <span class="string">' '</span>;</span><br><span class="line">        s[<span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;     <span class="comment">/*  收集操作数  */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))       </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getchar()))</span><br><span class="line">            ;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getchar()))</span><br><span class="line">            ;</span><br><span class="line">    s[i] = <span class="string">' '</span>;</span><br><span class="line">    s[++i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (c != EOF)</span><br><span class="line">        ungetc(c, <span class="built_in">stdin</span>);    <span class="comment">/*  将多读入的字符压回到输入中  */</span></span><br><span class="line">    <span class="keyword">return</span> NUMBER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  op_prior函数：返回对应运算符的优先级  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_prior</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码应该是这个程序的难点所在了</p><blockquote><p>cat_exp函数用当前读入的运算符把栈顶的两个子表达式连接起来，如同上面提到的，这里需要重点考虑的是加括号的问题，代码中注释的很详细，应当都能看得懂。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  cat_exp函数：连接两个子表达式  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat_exp</span><span class="params">(<span class="keyword">char</span> *op1, <span class="keyword">char</span> *s, <span class="keyword">char</span> *op2, <span class="keyword">int</span> c, <span class="keyword">int</span> lastc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp[MAXOP];</span><br><span class="line">    <span class="keyword">char</span> op[MAXOP];</span><br><span class="line">    <span class="keyword">char</span> opt[MAXOP];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, s);     <span class="comment">/*  先将已经生成的中缀表达式拷贝到tmp中  */</span></span><br><span class="line">    <span class="keyword">if</span> (lastc &amp;&amp; op_prior(c) &gt; op_prior(lastc)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isop(op1)) &#123;</span><br><span class="line">            cat(op, op1);</span><br><span class="line">            op1 = op;</span><br><span class="line">        &#125;        <span class="comment">/*  在可能需要加括号的地方都加上括号  */</span></span><br><span class="line">        <span class="keyword">if</span> (isop(op2)) &#123;</span><br><span class="line">            cat(opt, op2);</span><br><span class="line">            op2 = opt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     <span class="comment">/*  将新连接好的子表达式加入到已经生成的表达式中，然后拷贝回s中  */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s, op1);</span><br><span class="line">    <span class="built_in">strcat</span>(s, tmp);</span><br><span class="line">    <span class="built_in">strcat</span>(s, op2);</span><br><span class="line">    pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  cat函数：在表达式前后加上括号  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *s++ = <span class="string">'('</span>;</span><br><span class="line">    <span class="keyword">while</span> (*op != <span class="string">'\0'</span>)</span><br><span class="line">        *s++ = *op++;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">' '</span>)</span><br><span class="line">        s--;</span><br><span class="line">    *s++ = <span class="string">')'</span>;</span><br><span class="line">    *s++ = <span class="string">' '</span>;</span><br><span class="line">    *s = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isop函数：判断s中是否有运算符  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isop</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">if</span> (op_prior(*s++))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是栈的实现了，和中缀转后缀不同的是，这里是用指针栈来实现转换过程的，其实也就一普通的堆栈，没什么特别的。但其中也有几点是需要注意的：</p><blockquote><ul><li>我们需要实时为压入栈的表达式分配存储空间</li><li>不要忘记检查内存是否分配成功</li><li>出栈时记得释放内存</li></ul></blockquote><p><strong><em>为了方便起见，我这里用断言以防止使用NULL指针，即内存分配失败的情况。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *val[MAXVAL];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将字符串s压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull()) </span><br><span class="line">        assert((val[++sp] = strdup(s)));</span><br><span class="line">    <span class="keyword">else</span>           <span class="comment">/*  将s保存在某个安全的地方  */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty()) &#123;</span><br><span class="line">        <span class="built_in">free</span>(val[sp]);</span><br><span class="line">        val[sp--] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>运行结果：</p><p><img src="https://github.com/yaomer/pictures/blob/master/v6.png?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;中缀转后缀表达式&quot;&gt;&lt;a href=&quot;#中缀转后缀表达式&quot; class=&quot;headerlink&quot; title=&quot;中缀转后缀表达式&quot;&gt;&lt;/a&gt;中缀转后缀表达式&lt;/h3&gt;&lt;p&gt;实现的方法很简单：就是用栈来实现。&lt;/p&gt;
&lt;p&gt;具体思路如下：&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>将Vim打造成一个C/C++IDE</title>
    <link href="https://yaoer.me/2018/10/22/vim-IDE/"/>
    <id>https://yaoer.me/2018/10/22/vim-IDE/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-27T01:46:23.968Z</updated>
    
    <content type="html"><![CDATA[<p>当你不知从哪里听过Vim的鼎鼎大名而信心满满的去安装它后，你打开Vim的界面后是这样的：什么也没有，就是一个黑框框。然后你想尝试打几个字，结果发现终端一直在嘟嘟的响。这时你的心里一定会大失所望，这都是什么啊。<br><a id="more"></a></p><p><img src="https://github.com/yaomer/pictures/blob/master/v2.png?raw=true" alt=""></p><p>但请不要就此放弃，你可以把Vim看作一匹充满野性的烈马，需要你付出许多努力去驯服它，从而让它乖乖地为你服务，成为你的好帮手。</p><p>实际上，Vim最大的特性就是它的<code>可定制性和可扩展性</code>。因此，当你与它初次相遇时，它就是一块未经打磨的璞玉，一柄未经开封的利刃。你需要自己去打磨它，磨亮它。让它成为一把编辑器中的<code>瑞士军刀</code>。真正的无愧于它编辑器之神的称号。</p><p>之后我推荐你去看Vim最好的入门教程，它只需花费你半小时不到的时间，然后就可以进入下面的打造之路了。</p><p><code>$ vimtutor</code></p><hr><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>我们写代码的基本需求就是要有一点语法高亮，最起码不能是那样的丑陋吧，然后可能还要有对应的行号等等这样一些基本的需求，然后我们写代码可能就会好受一些了。</p><p>这些基本配置包括后面提到的所有插件都需要用到一个叫做<code>.vimrc</code>的文件，顾名思义，这就是Vim的配置文件。在Unix/Linux系统中，它一般在家目录下，你可以使用<code>$ ls -a | grep &quot;.vimrc&quot;</code>命令检查一下，如果没有的话，就自己创建一个。</p><p>然后我们加入一些最简单、最基本的配置，Vim的模样就会变得不一样了，最起码是有点颜色了。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">filetype</span> <span class="keyword">on</span>           <span class="comment">" 开启文件类型检测</span></span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="keyword">on</span>.   <span class="comment">" 设置加载对应文件类型的插件              </span></span><br><span class="line"><span class="keyword">colorscheme</span> desert    <span class="comment">" 语法高亮主题</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>             <span class="comment">" 开启语法高亮</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>            <span class="comment">" 显示行号</span></span><br><span class="line"><span class="keyword">set</span> noerrorbells      <span class="comment">" 关闭出错响铃</span></span><br><span class="line"><span class="keyword">set</span> autoindent        <span class="comment">" 自动缩进</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span>           <span class="comment">" 使用C/C++的自动缩进方式</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span>         <span class="comment">" 将tab设置为4个空格</span></span><br><span class="line"><span class="keyword">set</span> expandtab         <span class="comment">" 将tab扩展为空格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>      <span class="comment">" 每一级缩进为4个空格</span></span><br></pre></td></tr></table></figure><p>然后在重新打开你的Vim，你就会感到有所惊喜了。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v1.png?raw=true" alt=""></p><p>当然这些配置只是最基本的，Vim还有许多别的有用的配置，这就要根据你自己的需要去配置了。在本文最后，我会给出我的<code>.vimrc</code>，大家可以略作参考。</p><p>然后我们正式进入主题。</p><hr><h3 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h3><p>在谈下面的内容之前，我们首先需要选择一款插件管理器，随着我们安装插件数量的增多，为了方便我们管理也为了以后更方便地安装新插件，这都是我们必须要做的。</p><p>我极力推荐大家使用<code>Plug</code>，它是一款极简主义的Vim插件管理器，与老旧的<code>Vundle</code>相比，它的最大优点是超高速并行安装。除此之外，它还可以延迟加载插件，从而加快Vim的启动速度，这个我们最后会提到的。</p><p><img src="https://raw.githubusercontent.com/junegunn/i/master/vim-plug/installer.gif" alt=""></p><p>运行如下命令安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>它的用法也很简单。首先在你的vimrc中加入以下两行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">'~/.vim/plugged'</span>)</span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure><p>如果你要安装一个插件，就<code>Plug &#39;插件名&#39;</code>，然后把这行加到那两行中间即可，之后在Vim中运行<code>:PlugInstall</code>即可自动安装。</p><p>因此，以下提到的插件我不再说明安装方法，都是以这种方式安装的。</p><hr><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><h4 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h4><p>Vim本身自带了一些语法高亮主题，这些主题文件一般在<code>/usr/share/vim/vim80/colors/</code>目录下。你可以自己分别尝试下，不过这些高亮都相对来说比较简单，对于函数、运算符之类的都无法高亮。</p><p>这里我推荐两种我非常喜欢的配色，<a href="https://github.com/crusoexia/vim-monokai" target="_blank" rel="noopener">monokai</a>和<a href="https://github.com/altercation/vim-colors-solarized" target="_blank" rel="noopener">solarized</a>。</p><p>我最先使用的是<code>monokai</code>，使用了很长一段时间，自己也折腾了很多，最近突然觉得它看起来有些不太合心意，在网上看到了<code>solarized</code>，可以说是一见钟情吧，它在色彩处理上可以说是非常优秀，而且是适用于各个平台。</p><p>要修改它们也很简单，只需修改不同语法的高亮颜色即可。</p><h4 id="语法高亮增强"><a href="#语法高亮增强" class="headerlink" title="语法高亮增强"></a>语法高亮增强</h4><p><a href="https://github.com/octol/vim-cpp-enhanced-highlight" target="_blank" rel="noopener">vim-cpp-enhanced-highlight</a>提供了对C++语法高亮的增强，比如STL中的容器和类型。除此之外，还可以高亮运算符，只不过需要简单的设置。</p><p>找到<code>c.vim</code>这个文件，取消下面这些行的注释即可。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" Operators</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>\(&lt;&lt;\|&gt;&gt;\|[-+*/%&amp;^|&lt;&gt;!=]\)=<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>&lt;&lt;\|&gt;&gt;\|&amp;&amp;\|||\|++\|--\|-&gt;<span class="comment">"</span></span><br><span class="line">" syn match cOperator"[.!~*&amp;%&lt;&gt;^|=,;?:+-]"</span><br><span class="line"><span class="string">" syn match cOperator"</span>/[^/*=]<span class="comment">"me=e-1</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>/$<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator  "</span>&amp;&amp;\|||<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>[][]<span class="comment">"</span></span><br></pre></td></tr></table></figure><h4 id="彩虹括号"><a href="#彩虹括号" class="headerlink" title="彩虹括号"></a>彩虹括号</h4><p>当代码中出现多级嵌套的时候，<a href="https://github.com/kien/rainbow_parentheses.vim" target="_blank" rel="noopener">rainbow_parentheses.vim</a>这个插件就会很有用。它可以很明显的显示出不同括号内的代码层次。</p><p>这里我上一张我修改过的代码高亮配色的图吧。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v3.png?raw=true" alt=""></p><p>不过这个插件已经很久不维护了，大家也可以看一下这个较新的插件<a href="https://github.com/luochen1990/rainbow" target="_blank" rel="noopener">rainbow</a><br>，它是对旧的插件的改进版本。</p><hr><h3 id="漂亮的状态栏"><a href="#漂亮的状态栏" class="headerlink" title="漂亮的状态栏"></a>漂亮的状态栏</h3><p>作为一名颜值党，暂且不提Vim别的功能，最起码要看来漂亮动人才行吧。那么没有一个好看的状态栏怎么行呢！而<a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener">vim-airline</a>正是这样一款优秀的状态栏插件，现在它基本上已经取代了<a href="https://github.com/powerline/powerline" target="_blank" rel="noopener">powerline</a>。</p><p>它的配色非常多，可以说是只要你想要的，应该都能找到，我这里选出一个我觉得漂亮的吧。</p><p><img src="https://user-images.githubusercontent.com/9622/45275524-52f45c00-b48b-11e8-8b83-a66240b10747.gif" alt=""></p><p>更多的大家自己去看吧。</p><p>还有一个需要顺带下载的插件是它的主题<a href="https://github.com/vim-airline/vim-airline-themes" target="_blank" rel="noopener">vim-airline-themes</a>，我当初就是把它主题下的所有主题都试了一遍，才找到自己喜欢的。<code>^0^</code>希望大家不要像我一样o。</p><p>airline由于要显示一些图形字符，所以它需要使用一些<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">特定的字体</a>。</p><hr><h3 id="自动补全括号"><a href="#自动补全括号" class="headerlink" title="自动补全括号"></a>自动补全括号</h3><p>当我们码代码的时候，如果每次输入一个<code>(</code>之后，稍后还得记得输入另一个配对的<code>)</code>是不是很麻烦，而且有时候还会忘记另一个<code>)</code>。</p><p><a href="https://github.com/jiangmiao/auto-pairs" target="_blank" rel="noopener">auto-pairs</a>插件正好可以胜任这个任务。</p><hr><h3 id="代码自动补全"><a href="#代码自动补全" class="headerlink" title="代码自动补全"></a>代码自动补全</h3><p>代码自动补全首推YCM了，具体的安装配置过程可以参照我的另一篇博客<a href="https://yaoer.me/2018/10/21/YCM/#more">Mac安装配置YCM</a>，在Unix/Linux下过程应该是差不多的。</p><hr><h3 id="函数参数列表补全"><a href="#函数参数列表补全" class="headerlink" title="函数参数列表补全"></a>函数参数列表补全</h3><p>如果你YCM安装成功了，在你体验着它便利的同时，你应该会有另一个棘手的问题：<strong><em>对于函数参数无法补全</em></strong>。</p><p>在补全列表中是可以看到参数列表的，当当你键入<code>(</code>后，参数列表就消失了。对于一些常见的函数，我们可能不依赖于函数参数补全。但对于一个稍显生僻的函数或者参数表特别长的函数，我们显而易见需要参数补全，因为我们可能会忘掉参数或者搞错参数顺序。</p><p><a href="https://github.com/tenfyzhong/CompleteParameter.vim" target="_blank" rel="noopener">CompleteParameter.vim</a>正是这样一个与YCM完美配合的插件。</p><p><img src="https://camo.githubusercontent.com/5ff72790ae3d6bf6c964cf3b59bdc0985268b190/687474703a2f2f7778342e73696e61696d672e636e2f6d773639302f36393437323232336779316668796a76726a68723367323068733061307162792e676966" alt=""></p><p>一旦你键入<code>(</code>后，它会将该函数的参数列表显示出来，和一般IDE的补全是没有什么两样的，填完一个参数后，你可以使用<code>ctr + j</code>跳转到下一个参数，直到填完所有参数，最后跳到<code>)</code>外面。</p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;expr&gt;</span> ( complete_parameter#pre_complete(<span class="string">"()"</span>)</span><br><span class="line"><span class="keyword">smap</span> <span class="symbol">&lt;c-j&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_next_parameter)</span><br><span class="line"><span class="keyword">imap</span> <span class="symbol">&lt;c-j&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_next_parameter)</span><br><span class="line"><span class="keyword">smap</span> <span class="symbol">&lt;c-k&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_previous_parameter)</span><br><span class="line"><span class="keyword">imap</span> <span class="symbol">&lt;c-k&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_previous_parameter)</span><br></pre></td></tr></table></figure><hr><h3 id="跳转到声明或定义处"><a href="#跳转到声明或定义处" class="headerlink" title="跳转到声明或定义处"></a>跳转到声明或定义处</h3><p>这里我们不使用<code>ctags</code>，因为对于C/C++来说，YCM原生支持这些操作，而且使用起来非常方便。</p><p>在你的vimrc中加入下面这一句：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" 跳转到声明或定义处</span></span><br><span class="line"><span class="string">nnoremap &lt;silent&gt;&lt;leader&gt;j :YcmCompleter GoToDefinitionElseDeclaration&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><p>具体的键位映射需要你根据自己的方便设置。</p><hr><h3 id="树形目录"><a href="#树形目录" class="headerlink" title="树形目录"></a>树形目录</h3><p><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">nerdtree</a>插件可以显示树形目录。</p><p><a href="https://github.com/tiagofumo/vim-nerdtree-syntax-highlight" target="_blank" rel="noopener">vim-nerdtree-syntax-highlight</a>插件可以高亮nerdtree显示的文件类型。</p><p><a href="https://github.com/Xuyuanp/nerdtree-git-plugin" target="_blank" rel="noopener">nerdtree-git-plugin</a>插件可以显示git状态。</p><p>这三个插件大家可以一起配套下载使用。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v4.png?raw=true" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" nerdtree</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span>n :NERDTreeToggle<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeFileExtensionHighlightFullName</span>    = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeExactMatchHighlightFullName</span>       = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreePatternMatchHighlightFullName</span>     = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeHighlightFolders</span>                  = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeHighlightFoldersFullName</span>          = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeDirArrowExpandable</span>                = <span class="string">'▷'</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeDirArrowCollapsible</span>               = <span class="string">'▼'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" nerdtree-git-plugin</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeIndicatorMapCustom</span> = &#123;</span><br><span class="line">            \ <span class="string">"Modified"</span>  : <span class="string">"✹"</span>,</span><br><span class="line">            \ <span class="string">"Staged"</span>    : <span class="string">"✚"</span>,</span><br><span class="line">            \ <span class="string">"Untracked"</span> : <span class="string">"✭"</span>,</span><br><span class="line">            \ <span class="string">"Renamed"</span>   : <span class="string">"➜"</span>,</span><br><span class="line">            \ <span class="string">"Unmerged"</span>  : <span class="string">"═"</span>,</span><br><span class="line">            \ <span class="string">"Deleted"</span>   : <span class="string">"✖"</span>,</span><br><span class="line">            \ <span class="string">"Dirty"</span>     : <span class="string">"✗"</span>,</span><br><span class="line">            \ <span class="string">"Clean"</span>     : <span class="string">"✔︎"</span>,</span><br><span class="line">            \ <span class="string">'Ignored'</span>   : <span class="string">'☒'</span>,</span><br><span class="line">            \ <span class="string">"Unknown"</span>   : <span class="string">"?"</span></span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="显示类、方法、变量"><a href="#显示类、方法、变量" class="headerlink" title="显示类、方法、变量"></a>显示类、方法、变量</h3><p><a href="https://github.com/majutsushi/tagbar" target="_blank" rel="noopener">tagbar</a>插件可以让我们把握文件的整体结构。</p><p><img src="https://camo.githubusercontent.com/fc85311154723793776aed28488befdfaab36c42/68747470733a2f2f692e696d6775722e636f6d2f5366394c7332722e706e67" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:tagbar_width</span> = <span class="number">30</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span>t :TagbarToggle<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="快速代码注释"><a href="#快速代码注释" class="headerlink" title="快速代码注释"></a>快速代码注释</h3><p>当我们在debug时，经常需要注释一段可能会出错的代码来查看程序的运行行为，这个时候，<a href="https://github.com/scrooloose/nerdcommenter" target="_blank" rel="noopener">nerdcommenter</a>插件就非常有用，它可以让我们非常方便的注释或者反注释代码段。</p><p>它的简单用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;leader&gt;cc         注释一行</span><br><span class="line">&lt;leader&gt;cu         取消注释</span><br><span class="line">&lt;leader&gt;cm         注释(Visual)选中的一段代码</span><br></pre></td></tr></table></figure><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDSpaceDelims</span>               = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDCompactSexyComs</span>           = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDDefaultAlign</span>              = <span class="string">'left'</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDCommentEmptyLines</span>         = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTrimTrailingWhitespace</span>    = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDToggleCheckAllLines</span>       = <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h3 id="文件模糊搜索"><a href="#文件模糊搜索" class="headerlink" title="文件模糊搜索"></a>文件模糊搜索</h3><p>文件模糊查找在我们日常工作应该经常要用到，与其使用速度较慢的<code>find</code>命令，<a href="https://github.com/Yggdroot/LeaderF" target="_blank" rel="noopener">LeaderF</a>插件可以帮助我们在大型项目中快速定位文件。而且除过模糊查找之外，它还有很多其他功能，我这里就不多说了。</p><p><img src="https://github.com/Yggdroot/Images/raw/master/leaderf/leaderf_1.gif" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> :LeaderfFile<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_WildIgnore</span> = &#123;</span><br><span class="line">            \ <span class="string">'dir'</span>: [<span class="string">'.svn'</span>,<span class="string">'.git'</span>,<span class="string">'.hg'</span>,<span class="string">'.vscode'</span>,<span class="string">'.wine'</span>,<span class="string">'.deepinwine'</span>,<span class="string">'.oh-my-zsh'</span>],</span><br><span class="line">            \ <span class="string">'file'</span>: [<span class="string">'*.sw?'</span>,<span class="string">'~$*'</span>,<span class="string">'*.bak'</span>,<span class="string">'*.exe'</span>,<span class="string">'*.o'</span>,<span class="string">'*.so'</span>,<span class="string">'*.py[co]'</span>]</span><br><span class="line">            \&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_UseCache</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h3 id="更快速高效地移动"><a href="#更快速高效地移动" class="headerlink" title="更快速高效地移动"></a>更快速高效地移动</h3><p>Vim本身已经为我们提供了许多有用的组合键来帮助我们快速高效的移动，但那些大多是小范围的局部移动，而且也并不太准确。</p><p><a href="https://github.com/easymotion/vim-easymotion" target="_blank" rel="noopener">vim-easymotion</a>插件可以帮助我们快速准确的定位，让我们的移动一击即中。</p><p><img src="https://camo.githubusercontent.com/d5f800b9602faaeccc2738c302776a8a11797a0e/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f333739373036322f323033393335392f61386539333864362d383939662d313165332d383738392d3630303235656138333635362e676966" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;Leader&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-prefix)</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:EasyMotion_do_mapping</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">j</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">j</span>)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">k</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">k</span>)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>h <span class="symbol">&lt;Plug&gt;</span>(easymotion-linebackward)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">l</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-lineforward)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>s <span class="symbol">&lt;Plug&gt;</span>(easymotion-s)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">w</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">bd</span>-<span class="keyword">w</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="延迟加载Vim插件"><a href="#延迟加载Vim插件" class="headerlink" title="延迟加载Vim插件"></a>延迟加载Vim插件</h3><p>随着我们安装插件的增多，Vim的启动速度不可避免的会变慢，当达到某个临界点之后，这种略显卡顿的启动就不是我们能接受的了。它会非常影响我们编辑文本的心情。</p><p>当幸运的是，Vim的最新版本提供了延迟加载插件的机制，这可以帮助我们将那些在初打开文件时不用的且较重的插件延迟加载，即打开文件后再加载。这样就能显著提高Vim的启动速度了。</p><p>具体操作如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" 延迟加载YCM</span></span><br><span class="line"><span class="string">Plug 'Valloric/YouCompleteMe', &#123; 'on': [] &#125;             </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 100ms后调用LoadPlug，且只调用一次</span><br><span class="line">call timer_start(100, <span class="string">'LoadPlug'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>! LoadPlug(timer) abort</span><br><span class="line">    call plug<span class="comment">#load('YouCompleteMe')</span></span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你不知从哪里听过Vim的鼎鼎大名而信心满满的去安装它后，你打开Vim的界面后是这样的：什么也没有，就是一个黑框框。然后你想尝试打几个字，结果发现终端一直在嘟嘟的响。这时你的心里一定会大失所望，这都是什么啊。&lt;br&gt;
    
    </summary>
    
      <category term="vim" scheme="https://yaoer.me/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac安装配置YCM</title>
    <link href="https://yaoer.me/2018/10/21/YCM/"/>
    <id>https://yaoer.me/2018/10/21/YCM/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-10-24T13:09:17.716Z</updated>
    
    <content type="html"><![CDATA[<p>YCM的大名在这里就不消多说了。下面我们就来说说如何安装吧。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>YCM算是Vim插件中比较重的了，而且与其他插件不同的是，它是一个带有编译组件的插件。因此也就导致了在安装过程可能会出现各种意想不到的问题。<br><a id="more"></a></p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>在正式安装YCM之前需要安装一些依赖工具。</p><h4 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h4><p>可以说是homebrew使得Mac的软件生态变得完整，因为它是一个非常好用的包管理工具。我们下面提到的一些依赖都可以通过它很方便地安装。</p><p>可以在终端运行以下ruby脚本安装brew:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>它的用法很简单，比如说安装Vim。</p><p><code>$ brew install vim</code></p><p>运行<code>brew uninstall vim</code>即可卸载。</p><h4 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h4><p>确保你的Vim版本是最新的，且要支持py2或py3。Mac系统自带的Vim版本比较老，你最好使用brew安装最新的版本。可以通过以下命令查看：</p><p><code>$ vim --version</code></p><p>如果输出中包含<code>+python或+python3</code>，就说明你的Vim支持py2或py3。</p><p>如果你的Vim不支持python，那么你可能就需要<a href="https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source" target="_blank" rel="noopener">从源码编译安装Vim</a>了，不过别担心，它的过程很简单。</p><h4 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h4><p><code>$ brew install CMake</code></p><h4 id="Command-Line-Tools"><a href="#Command-Line-Tools" class="headerlink" title="Command Line Tools"></a>Command Line Tools</h4><p>如果你需要C-Family语言补全的话，你就需要安装以上命令行工具。它们在你第一次运行clang时自动安装，也可以通过手工安装：</p><p><code>$ xcode-select --install</code></p><h4 id="pythen-dev"><a href="#pythen-dev" class="headerlink" title="pythen-dev"></a>pythen-dev</h4><p>Mac系统已经默认安装。不过这里需要注意的是：</p><blockquote><p><strong><em>你千万不要在私下去安装一个新的python2，不然会导致YCM在安装和编译中使用不同的python2版本，从而会产生冲突。</em></strong></p></blockquote><p>如果你已经使用brew安装了，那么你可能需要卸载它。这或许会使你的问题得到解决。</p><p><code>$ brew uninstall python@2</code></p><h3 id="YCM"><a href="#YCM" class="headerlink" title="YCM"></a>YCM</h3><p>安装YCM这里推荐使用Plug安装，当然你使用Vundle也可以。</p><p>在你的.vimrc中加入以下代码段。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call plug<span class="comment">#begin('~/.vim/plugged')</span></span><br><span class="line">Plug <span class="string">'Valloric/YouCompleteMe'</span></span><br><span class="line">call plug<span class="comment">#end()</span></span><br></pre></td></tr></table></figure><p>然后在Vim中输入<code>:PlugInstall</code>等待自动安装结束即可。这个过程可能会有点久，需要耐心等待。</p><p>如果你不是使用Plug或Vundle安装的，那么你就需要保证YCM安装包的完整性。可以运行下列命令检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>安装成功后，接下来就需要进入编译环节了。编译过程实际上很简单，运行一个脚本就行了。但如果在脚本运行过程中出了点问题，那么你可能就需要完整地一步一步地编译YCM了。</p><hr><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="直接运行安装脚本"><a href="#直接运行安装脚本" class="headerlink" title="直接运行安装脚本"></a>直接运行安装脚本</h3><p>如果你需要C-Family语言补全，则运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.vim/Plug/YouCompleteMe</span><br><span class="line">$ ./install.py --clang-completer</span><br></pre></td></tr></table></figure><p>否则，直接运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.vim/Plug/YouCompleteMe</span><br><span class="line">$ ./install.py</span><br></pre></td></tr></table></figure><p>如果你幸运的编译成功了，那么直接跳转到配置过程中。否则，进入下一步。</p><h3 id="一步一步编译"><a href="#一步一步编译" class="headerlink" title="一步一步编译"></a>一步一步编译</h3><p>如果你和我当初一样失败了，那么可能就需要进行下面这些比较繁琐的安装过程了。</p><p>如果你关心C-Family语言语义支持，完成下面步骤：</p><h4 id="下载最新版本的libclang"><a href="#下载最新版本的libclang" class="headerlink" title="下载最新版本的libclang"></a>下载最新版本的libclang</h4><p>libclang它提供的库用于为这些语言提供YCM语义完成引擎。</p><p>只有在你确定它是3.9或更高版本时才可以使用系统libclang，否则不能。但即使它是，YCM官方也建议尽可能使用<a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener">llvm.org</a>的官方二进制文件。这确保为你的操作系统下载正确的存档文件。</p><h4 id="编译ycm-core"><a href="#编译ycm-core" class="headerlink" title="编译ycm_core"></a>编译ycm_core</h4><p>这个库是YCM用来获得快速补全的C++引擎。</p><p>在这里，我假设你使用Plug安装了YCM。这意味着YCM的顶级目录在<code>~/.vim/Plug/YouCompleteMe</code>。</p><p>我们将创建一个新文件夹，其中将放置构建文件。运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ mkdir ycm_build</span><br><span class="line">$ cd ycm_build</span><br></pre></td></tr></table></figure><p>现在我们需要生成Makefile。如果你不关心C-Family语言的语义支持，就请在ycm_build 目录中运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -G &quot;Unix Makefiles&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</span><br></pre></td></tr></table></figure><p>如果你关心C-Family语言的语义支持，那么CMake的调用就会更复杂些。我们假设你在llvm.org中下载的LLVM + Clang的二进制发行版，你提取的存档文件放到了文件夹<code>~/ycm_temp/llvm_root_dir</code>中。</p><p>然后在<code>ycm_build</code>目录中运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -G &quot;Unix Makefiles&quot; -DPATH_TO_LLVM_ROOT=~/ycm_temp/llvm_root_dir . ~/.vim/Plug/YouCompleteMe/third_party/ycmd/cpp</span><br></pre></td></tr></table></figure><p>现在已经生成了配置文件，使用以下命令编译库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build . --target ycm_core</span><br></pre></td></tr></table></figure><p>至此YCM就已经安装完成了，<code>ycm_build</code>和<code>ycm_temp</code>目录都可以删除了，不影响使用。</p><p>如果你中间还是出现了一些问题，那么请你仔细按照以上过程重新尝试安装。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置过程需要编辑两个文件：<code>vimrc</code>和<code>.ycm_extra_conf.py</code>。</p><p>在你的终端运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo | clang -v -E -x c++ -</span><br></pre></td></tr></table></figure><p>将输出结果中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;...&quot; search starts here:</span><br><span class="line">#include &lt;...&gt; search starts here:</span><br></pre></td></tr></table></figure><p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">End of search list.z</span><br></pre></td></tr></table></figure></p><p>之间的部分添加到<code>.ycm_extra_conf.py</code>中的<code>-isystem</code>后。</p><p>然后将一下代码段加入到你的vimrc中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> g:ycm_server_python_interpreter=<span class="string">'/usr/bin/python'</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_global_ycm_extra_conf = <span class="string">'~/.vim/plugged/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py'</span></span><br><span class="line"><span class="string">" 让vim的补全菜单行为与一般IDE一致</span></span><br><span class="line"><span class="string">set completeopt=longest,menu</span></span><br><span class="line"><span class="string">"</span> 触发(符号)补全时需要键入的字符数</span><br><span class="line"><span class="built_in">let</span> g:ycm_min_num_of_chars_for_completion = 1</span><br><span class="line"><span class="string">" 补全候选项的最小字符数</span></span><br><span class="line"><span class="string">let g:ycm_min_num_identifier_candidate_chars = 0</span></span><br><span class="line"><span class="string">"</span> 关闭诊断显示功能(已经使用了ale进行异步语法检查)</span><br><span class="line"><span class="built_in">let</span> g:ycm_show_diagnostics_ui = 0</span><br><span class="line"><span class="string">" 在字符串和注释中仍会触发补全</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_comments = 1</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_strings = 1</span></span><br><span class="line"><span class="string">"</span> 禁止缓存匹配项，每次重新生成匹配项</span><br><span class="line"><span class="built_in">let</span> g:ycm_cache_omnifunc = 0</span><br><span class="line"><span class="string">" 在用户接受提供的完成字符串后自动关闭窗口</span></span><br><span class="line"><span class="string">let g:ycm_autoclose_preview_window_after_completion = 0</span></span><br><span class="line"><span class="string">"</span> 跳转到声明或定义处</span><br><span class="line">nnoremap &lt;silent&gt;&lt;leader&gt;gj :YcmCompleter GoToDefinitionElseDeclaration&lt;cr&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">" 自动触发语义补全</span></span><br><span class="line"><span class="string">let g:ycm_semantic_triggers =  &#123;</span></span><br><span class="line"><span class="string">            \ 'c,cpp,python,java,go,erlang,perl': ['re!\w&#123;1&#125;'],</span></span><br><span class="line"><span class="string">            \ 'cs,lua,javascript': ['re!\w&#123;1&#125;'],</span></span><br><span class="line"><span class="string">            \ &#125;</span></span><br><span class="line"><span class="string">"</span> 遇到下列文件时才会开启YCM</span><br><span class="line"><span class="built_in">let</span> g:ycm_filetype_whitelist = &#123;</span><br><span class="line">            \ <span class="string">"c"</span>:1,</span><br><span class="line">            \ <span class="string">"cpp"</span>:1,</span><br><span class="line">            \ <span class="string">"python"</span>:1,</span><br><span class="line">            \ <span class="string">"sh"</span>:1,</span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure><p>接下来你就可以享受YCM带来的如丝般柔滑地补全了。</p><hr><p>参考资料：<br><a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="noopener">YCM官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;YCM的大名在这里就不消多说了。下面我们就来说说如何安装吧。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;YCM算是Vim插件中比较重的了，而且与其他插件不同的是，它是一个带有编译组件的插件。因此也就导致了在安装过程可能会出现各种意想不到的问题。&lt;br&gt;
    
    </summary>
    
      <category term="vim" scheme="https://yaoer.me/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>巧判机器的大小端</title>
    <link href="https://yaoer.me/2018/10/21/endian/"/>
    <id>https://yaoer.me/2018/10/21/endian/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-10-22T15:26:03.947Z</updated>
    
    <content type="html"><![CDATA[<p>大小端的命名来自于《格列佛游记》中一个有关吃鸡蛋先磕鸡蛋的大端还是小端的故事，大家有兴趣的话可以去了解一下。</p><p>那么什么是大端、什么是小端呢？</p><blockquote><ul><li>大端：即高位有效字节在低位地址，低位有效字节在高位地址。</li><li>小端：即高位有效字节在高位地址，低位有效字节在低位地址。</li></ul></blockquote><a id="more"></a><p>我们举个例子来说明一下：<code>char a = 1;</code></p><p>它在内存中的表示如下图：</p><blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/endian.png?raw=true" alt=""></p></blockquote><p>那么如何用C语言来判断自己所使用机器的大小端呢？<br>通常有两种方法，其本质都是依赖于<strong><em>大小端的概念。</em></strong></p><p>一种方法是借助联合的特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125; port;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    port.a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (port.b == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们知道，在联合中 <strong><em>多个成员变量共用一段内存</em></strong>。在执行完<code>port.a = 1</code>后，内存中的情况是这样的：<code>00000000 00000000 00000000 00000001</code>。它到底是如何存放的，我们目前并不清楚。当我们访问<code>port.b</code>时，我们只会访问到位于该段内存中最低地址的那一字节的内容。如果<code>port.b == 1</code>，显然我们访问到的是<code>00000001</code>这一字节的内容，即低位有效字节在低位地址，所以是<code>little-endian</code>模式。<code>big-endian</code>模式同理。</p></blockquote><p>另一种方法就是根据大小端的概念直接判断了，相比于第一种更直接点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endian</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">char</span> *)&amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (endian())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>a是一个<code>int</code>类型的整数，所以<code>&amp;a</code>可以看作一个<code>int *</code>类型的指针。如果对<code>&amp;a</code>进行解引用操作，则编译器会将其解释为：<strong><em>从当前地址开始往后数4个字节，然后取出这4个字节中的内容</em></strong>。如果我们将<code>&amp;a</code>强制类型转换为<code>char *</code>类型后再进行解引用操作，那么编译器就会将其解释为：<strong><em>取出当前地址所在的那个字节中的内容</em></strong>。这个地址一定是之前那4个内存地址中的最低位地址。通过查看该地址中的值是什么我们就能确定该机器的大小端了。</p></blockquote><p>显然，两种方法的本质都是相同的，都是通过<strong><em>查看低位地址中的内容</em></strong>来判断大小端模式的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大小端的命名来自于《格列佛游记》中一个有关吃鸡蛋先磕鸡蛋的大端还是小端的故事，大家有兴趣的话可以去了解一下。&lt;/p&gt;
&lt;p&gt;那么什么是大端、什么是小端呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;大端：即高位有效字节在低位地址，低位有效字节在高位地址。&lt;/li&gt;
&lt;li&gt;小端：即高位有效字节在高位地址，低位有效字节在低位地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="server" scheme="https://yaoer.me/categories/server/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树的基本操作</title>
    <link href="https://yaoer.me/2018/10/21/bst/"/>
    <id>https://yaoer.me/2018/10/21/bst/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-10-23T06:27:25.789Z</updated>
    
    <content type="html"><![CDATA[<p>顾名思义，二叉搜索树就是以二叉树来组织的。而二叉树是一颗有根树，它的每个节点至多有两个子节点。</p><p>二叉搜索树的每个节点通常是这样组织的：<strong><em>一个指向左子树的指针、一个指向右子树的指针、关键字以及卫星数据</em></strong>。在某些情况下，还可以对树节点作一些更改，比如增加一个指向父节点的指针，这样做的目的是有助于更好地完成某些操作。</p><a id="more"></a><p>二叉搜索树也叫二叉排序树，它具有如下性质：</p><blockquote><p>设x是二叉搜索树中的一个节点。如果y是x的左子树中的一个节点，那么总有y.key &lt; x.key；如果y是x的右子树中的一个节点，那么总有y.key &gt; x.key。</p></blockquote><p>换句话说，就是<strong><em>对于任意一个节点来说，它的左子树中的所有节点的关键字都小于它自身的关键字，它的右子树中的所有节点的关键字都大于它自身的关键字。</em></strong></p><p>还有一点需要注意的就是 <strong><em>树中具有相同关键字的节点不能重复出现</em></strong>。要想解决这个问题其实也很容易，只需在树节点中增加一个<strong>count域</strong>，插入时如果遇见相同的节点，就将count加1，删除时类似。我们下面的讨论假设所有的元素都是互异的。</p><p>接下来，我们会发现二叉搜索树和快排是多么的相似。<font color="purple">^o\^</font></p><p><img src="https://github.com/yaomer/pictures/blob/master/bst.png?raw=true" alt=""></p><hr><p>下面我们给出一些二叉搜索树的基本操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> &#123;</span>     <span class="comment">/*  树节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; Tnode;</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><blockquote><p>查找操作通常需要返回指向树中具有某个关键字的节点的指针，如果不存在则返回NULL。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  search_tree函数（递归版本）：在树中查找某个值  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">search_tree</span><span class="params">(Tnode *p, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || val == p-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; p-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> search_tree(p-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> search_tree(p-&gt;right, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于树本身是递归定义的，所以这种递归操作是如此的容易，以至于让很多人不厌其烦地使用它。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  search_tree函数（迭代版本）：在树中查找某个值  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">search_tree</span><span class="params">(Tnode *p, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; val != p-&gt;val)</span><br><span class="line">        <span class="keyword">if</span> (val &lt; p-&gt;val)</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; p-&gt;val)</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>迭代版本也是简单而直接的，只需展开递归即可。对于绝大多数计算机来说，迭代版本的效率要更高一些。</p></blockquote><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>二叉搜索树的遍历根据何时输出子树根的关键字可分为三种：</p><blockquote><ul><li>先序遍历：输出的子树根的关键字在其左右子树的关键字之前</li><li>中序遍历：输出的子树根的关键字在其左右子树的关键字之间</li><li>后序遍历：输出的子树根的关键字在其左右子树的关键字之后</li></ul></blockquote><p><strong><em>所谓中序遍历，就是先遍历左子树，然后是当前结点(子树根节点)，最后是右子树</em></strong>。其他两种遍历操作类似。不过中序遍历常常是有用的，因为它从小到大输出树中所有节点的关键字。</p><p>在表达式树中，这三种遍历方法通常产生三种表达式：即前缀表达式、中缀表达式和后缀表达式。</p><blockquote><p><code>应当注意的是</code>：<strong><em>树的遍历需要花费O(n)的时间，而不是像其他操作一样花费O(log n)的时间。这是因为它需要遍历树的每一个节点。</em></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  travel_pre函数：先序遍历  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel_pre</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;val);</span><br><span class="line">        travel_pre(p-&gt;left);</span><br><span class="line">        travel_pre(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  travel_in函数：中序遍历  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel_in</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        travel_in(p-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;val);</span><br><span class="line">        travel_in(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  travel_post函数：后序遍历  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel_post</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        travel_post(p-&gt;left);</span><br><span class="line">        travel_post(p-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回最大关键字元素和最小关键字元素"><a href="#返回最大关键字元素和最小关键字元素" class="headerlink" title="返回最大关键字元素和最小关键字元素"></a>返回最大关键字元素和最小关键字元素</h3><blockquote><p>由于二叉搜索树自身的性质，这两种操作也是相当简单的。我们一种用递归实现，一种用迭代实现。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  mintree函数：返回树中的最小节点  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">mintree</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> mintree(p-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  maxtree函数：返回树中的最大节点  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">maxtree</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><blockquote><p>插入和删除操作会引起由二叉搜索树表示的动态集合的变化，因此我们要对树做一些修改来维护树本身的性质。插入一个节点要相对简单些，而删除的处理则有些复杂。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  addtree函数：在树中插入一个节点  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">addtree</span><span class="params">(Tnode *p, <span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;   <span class="comment">/*  找到了插入位置  */</span></span><br><span class="line">        <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tnode))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;val = new_val;</span><br><span class="line">        p-&gt;left = p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (new_val &lt; p-&gt;val)</span><br><span class="line">        p-&gt;left = addtree(p-&gt;left, new_val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (new_val &gt; p-&gt;val)</span><br><span class="line">        p-&gt;right = addtree(p-&gt;right, new_val);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>对于删除二叉搜索树中的一个节点，可能有如下三种情况：</p><blockquote><ul><li>没有子节点，它可以立即被删除</li><li>只有一个子节点，可以通过调整其父节点中的指针，使指针绕过该节点后而被删除</li><li>有两个子节点，下面作详细说明</li></ul></blockquote><p>第一种情况其实是可以归结到第二种情况中的。比较令人棘手的问题就是第三种情况的处理了。虽然它看起来是比较复杂的，但是由于二叉搜索树本身的性质，我们可以用一种简单的方法来处理它。即 <strong><em><font color="red">用待删除节点的后继节点中的数据来替换待删除节点中的数据，然后再删除其后继节点。</font></em></strong><br><strong><em>由于在这种情况下，待删除节点的右子树非空，所以其后继节点即为其右子树中的最小节点。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tnode *<span class="title">deltree</span><span class="params">(Tnode *p, <span class="keyword">int</span> old_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tnode *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (old_val &lt; p-&gt;val)</span><br><span class="line">        p-&gt;left = deltree(p-&gt;left, old_val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (old_val &gt; p-&gt;val)</span><br><span class="line">        p-&gt;right = deltree(p-&gt;right, old_val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;left &amp;&amp; p-&gt;right) &#123;   <span class="comment">/*  待删除节点有两个孩子  */</span></span><br><span class="line">        tmp = mintree(p-&gt;right);   <span class="comment">/*  找到其后继节点  */</span></span><br><span class="line">        p-&gt;val = tmp-&gt;val;    <span class="comment">/*  用后继节点中的数据来替换待删除节点中的数据  */</span></span><br><span class="line">        p-&gt;right = deltree(p-&gt;right, p-&gt;val);    <span class="comment">/*  删除后继节点  */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">/*  待删除节点有0个或1个孩子  */</span></span><br><span class="line">        tmp = p;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        tmp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们用图解详细说明一下删除过程：</p><blockquote><p><code>case 1：有0个或1个子节点</code></p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/bst1.png?raw=true" alt=""></p><blockquote><p>4是要待删除的节点，我们只需要把指针绕过4，然后释放该节点即可完成删除。</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/bst2.png?raw=true" alt=""></p><blockquote><p><code>case 2：有2个子节点</code></p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/bst3.png?raw=true" alt=""></p><blockquote><p>2是要待删除的节点，我们从节点2开始，找到它的后继节点3， 然后用3来替代2，然后我们删除其后继节点3。即这种方法并不是真正的删除想要删除的节点，只是间接删除。要想真正删除待删除节点，情况就比较复杂了，算法导论中有相关的描述，大家可以去看看。</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/bst4.png?raw=true" alt=""></p><p>我们上面描述的删除算法将会使得左子树比右子树更深，因为我们总是用右子树中的一个节点来代替需要删除的节点。在进行大量随机的<strong>insert / delete</strong>操作后，树或许会变得很不平衡。<br>如果输入的数据是已排好序的，那么二叉搜索树就会退化为线性表，多次<strong>insert</strong>操作将会花费O(n^2)的时间。这无疑不是我们所期望的。</p><p><img src="https://github.com/yaomer/pictures/blob/master/bst5.png?raw=true" alt=""><br>有一些二叉搜索树的变种可以解决这些问题，我们以后会提到的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;顾名思义，二叉搜索树就是以二叉树来组织的。而二叉树是一颗有根树，它的每个节点至多有两个子节点。&lt;/p&gt;
&lt;p&gt;二叉搜索树的每个节点通常是这样组织的：&lt;strong&gt;&lt;em&gt;一个指向左子树的指针、一个指向右子树的指针、关键字以及卫星数据&lt;/em&gt;&lt;/strong&gt;。在某些情况下，还可以对树节点作一些更改，比如增加一个指向父节点的指针，这样做的目的是有助于更好地完成某些操作。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>单链表的基本操作</title>
    <link href="https://yaoer.me/2018/10/20/sll/"/>
    <id>https://yaoer.me/2018/10/20/sll/</id>
    <published>2018-10-19T16:00:00.000Z</published>
    <updated>2018-10-21T12:36:41.627Z</updated>
    
    <content type="html"><![CDATA[<p>由于单链表是链表的一种，所以我们首先来介绍一下链表。</p><p>链表是一种线性表，通常由一连串节点组成，每个节点包含任意的实例数据，和一个或两个用于指向上一个或下一个节点的指针。</p><p>使用链表的优点是：</p><blockquote><ul><li>克服了数组需要预先知道数据大小的缺点</li><li>可以充分利用计算机的内存空间，实现灵活的动态内存管理</li></ul></blockquote><a id="more"></a><p>缺点是：</p><blockquote><ul><li>失去了数组随机读取的优点</li><li>由于增加了节点的指针域，空间开销比较大。</li></ul></blockquote><p>单链表是一种单向链接的链表，对链表的访问只能从表头开始，在表的末尾有一个特殊的结束标记，通常为NULL。</p><p>下面我们给出单链表的具体实现，涉及到它的一些基本操作，如创建、插入、删除等。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> &#123;</span>    <span class="comment">/*  表节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">next</span>;</span>    <span class="comment">/*  指向下一个节点的指针  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建一个单链表通常有两种方法：<strong><em>头插法和尾插法</em></strong></p><blockquote><ul><li>所谓头插法：就是将最先创建的那个节点作为尾节点，然后不断向前延伸。这种方法对数据的存储顺序和你的输入顺序是相反的。</li><li>所谓尾插法：与头插法相反，它将最先创建的那个节点作为头节点，然后不断向后延伸，这应该比较符合我们一般的思维习惯。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  create_head_sll函数：用头插法创建一个长度为size的单链表  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">create_head_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((head = <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="keyword">new</span>-&gt;val);</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;head-&gt;val);</span><br><span class="line">        head-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span> = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  create_tail_sll函数：用尾插法创建一个长度为size的单链表  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">create_tail_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">pre</span>, *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pre = head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist ))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre-&gt;val);</span><br><span class="line">    pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="keyword">new</span>-&gt;val);</span><br><span class="line">        pre-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pre = <span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><blockquote><p>单链表的插入操作通常要分好几种情况讨论，但只要我们细心观察它们，就会发现它们之间的共性，即<font color="red">每个节点都有一个指向它的指针</font>，头节点也不例外。从这种角度来看，头指针也不过是指向一个节点的普通指针而已。因此，我们在这里使用二级指针，能极大地简化操作，并使代码简洁优雅。<font color="red">而在遍历单链表的过程中，我们只需要保存每个指向next域的指针即可，这样就将所有可能的情况转化成一种通用的情况。</font></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  insert_sll函数：在有序单链表中插入一个节点，这里假定是按升序排列的  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sll</span><span class="params">(struct nlist **nextp, <span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;val = new_val;</span><br><span class="line">    <span class="comment">/*  寻找插入位置  */</span></span><br><span class="line">    <span class="keyword">while</span> (*nextp != <span class="literal">NULL</span> &amp;&amp; (*nextp)-&gt;val &lt; new_val)</span><br><span class="line">        nextp = &amp;(*nextp)-&gt;next;   <span class="comment">/*  每次得到指向next域的指针  */</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = *nextp;</span><br><span class="line">    *nextp = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>删除操作同插入操作的方法类似，每次也只需保存指向前一个节点的next域的指针即可，原因也很简单，因为前一个节点中的next指针指向当前节点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  delete_sll函数：在单链表中删除一个节点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_sll</span><span class="params">(struct nlist **nextp, <span class="keyword">int</span> old_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*nextp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*nextp)-&gt;val == old_val) &#123;</span><br><span class="line">            tmp = (*nextp)-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(*nextp);</span><br><span class="line">            *nextp = tmp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextp = &amp;(*nextp)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆置"><a href="#逆置" class="headerlink" title="逆置"></a>逆置</h3><p>单链表的逆置通常有三种方法：</p><blockquote><ol><li>利用头插法创建一个单链表的思想，我们从头遍历整个链表，然后用头插法重新链接每个节点，自然就将链表逆置过来了</li><li>就地逆置，也叫三指针法，改变每个节点的next域，完成逆置过程</li><li>递归的方法</li></ol></blockquote><h4 id="头插法逆置"><a href="#头插法逆置" class="headerlink" title="头插法逆置"></a>头插法逆置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct nlist * <span class="title">reverse_cll</span><span class="params">(struct nlist *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">head</span>, *<span class="title">pre</span>;</span></span><br><span class="line"></span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        head = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="就地逆置"><a href="#就地逆置" class="headerlink" title="就地逆置"></a>就地逆置</h4><blockquote><p>我们用pre指向前一个节点，new指向后一个节点，而*nextp则是head指针，指向当前需要改变的节点，我们用它来遍历整个链表。<strong><em>每次我们先让new指向下一个需要改变的节点，然后再让当前结点的next指针指向之前的节点，最后我们更新pre的值。</em></strong> 至于这里用不用二级指针就随你喜欢了。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_sll</span><span class="params">(struct nlist **nextp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">pre</span>, *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (pre = <span class="literal">NULL</span>; *nextp != <span class="literal">NULL</span>; *nextp = <span class="keyword">new</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> = (*nextp)-&gt;next;</span><br><span class="line">        (*nextp)-&gt;next = pre;</span><br><span class="line">        pre = *nextp;</span><br><span class="line">    &#125;</span><br><span class="line">    *nextp = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找、求长、打印"><a href="#查找、求长、打印" class="headerlink" title="查找、求长、打印"></a>查找、求长、打印</h3><blockquote><p>单链表的查找、求长以及打印操作主要涉及到的都只是 <strong><em>遍历链表的方法</em></strong>，所以应该都很简单。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  search_sll函数：在单链表中查找一个值  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">search_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; head != <span class="literal">NULL</span>; head = head-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == val)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  length_sll函数：计算单链表的长度  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_sll</span><span class="params">(struct nlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; head != <span class="literal">NULL</span>; len++)</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  print_sll函数：打印单链表  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sll</span><span class="params">(struct nlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; head != <span class="literal">NULL</span>; head = head-&gt;next)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, head-&gt;val);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>这里销毁单链表之所以使用二级指针，我是这么想的：</p><blockquote><p><strong><em>如果我们只是简单的传回head指针，虽然它指向的节点被释放了，但它本身的值是不会改变的。</em></strong> 为了避免之后错误地引用已经被释放的head指针，我们需要将它置空，使用二级指针可以很容易做到这一点，虽然在main函数中我们可以在destruct之后手动置空head，但我认为这样更好一些。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  destruct_sll函数：销毁单链表  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destruct_sll</span><span class="params">(struct nlist **nextp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( ; *nextp != <span class="literal">NULL</span>; *nextp = tmp) &#123;</span><br><span class="line">        tmp = (*nextp)-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(*nextp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于单链表是链表的一种，所以我们首先来介绍一下链表。&lt;/p&gt;
&lt;p&gt;链表是一种线性表，通常由一连串节点组成，每个节点包含任意的实例数据，和一个或两个用于指向上一个或下一个节点的指针。&lt;/p&gt;
&lt;p&gt;使用链表的优点是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;克服了数组需要预先知道数据大小的缺点&lt;/li&gt;
&lt;li&gt;可以充分利用计算机的内存空间，实现灵活的动态内存管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>队列的基本操作</title>
    <link href="https://yaoer.me/2018/10/20/queue/"/>
    <id>https://yaoer.me/2018/10/20/queue/</id>
    <published>2018-10-19T16:00:00.000Z</published>
    <updated>2018-10-23T06:27:33.669Z</updated>
    
    <content type="html"><![CDATA[<p>和栈一样，队列也是一种操作受限制的表。<strong><em>它只允许在表头（队头）执行删除操作（出队），在表尾（队尾）执行插入操作（入队）。</em></strong> 同样的，队列也可以分别由数组和链表实现。</p><p>队列的链表实现正如我们所描述的那样是直接而鲜明的，这里就不多加描述了。而队列的数组实现是有几点需要说明的。</p><a id="more"></a><p>关于顺序队列中的溢出问题</p><blockquote><ul><li>对空队列执行出队操作，称为下溢，是一种正常现象，常用作程序控制转移的条件</li><li>对满队列执行入队操作，称为“真上溢“，这是一种错误，应设法避免</li><li>由于入队和出队操作中， <strong><em><font color="red">头尾指针只增加不减小，致使被删除元素的空间永远无法重新利用。当队列中实际的元素个数远远小于队列空间的规模时，也可能是由于尾指针已超越队列空间的上界而不能做入队操作，就会发生“假上溢“</font></em></strong> &lt;/font&gt;</li></ul></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/a.png?raw=true" alt=""></p><blockquote><p>如上图所示，浅蓝色区域中的元素是被删除过的，它们所占有的空间本来是能够重新利用的，但对于顺序队列却无法做到。<strong><em>因为我们无法访问到之前被删除的元素所占有的空间。我们只能向队尾走，队列很快就会满，这样会导致队列中也许只存在很少的元素。</em></strong> 例如上述顺序队列再入队一次就会满，而队列中的实际元素只有3个。</p></blockquote><p>避免上述假上溢问题的简单的解决方法是：<strong><em>只要head或tail指针到达数组末尾，就让它们又绕回开头，</em></strong> 即队列的循环数组实现，也称为<font color="red">循环队列</font></p><p>当然，对于队列的链表实现，是不存在溢出问题的。</p><hr><h4 id="队列的链表实现"><a href="#队列的链表实现" class="headerlink" title="队列的链表实现"></a>队列的链表实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>    <span class="comment">/*  队列节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Queue *front;</span><br><span class="line"><span class="keyword">static</span> Queue *rear;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initqueue函数：初始化队列  */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initqueue</span><span class="params">(<span class="keyword">int</span> new_val)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Queue *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    p-&gt;val = new_val; </span><br><span class="line">    front = rear = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* enqueue函数：入队操作 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> new_val)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Queue *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    p-&gt;val = new_val;</span><br><span class="line">    rear-&gt;next = p;</span><br><span class="line">    rear = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* dequeue函数：出队操作 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dequeue</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Queue *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isempty()) &#123;</span><br><span class="line">        tmp = front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(front);</span><br><span class="line">        front = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  headqueue函数：返回队头元素  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">headqueue</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> front-&gt;val;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* isfull函数：判断队列是否已满 */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">/*  因为是用链表实现的，所以队列不会满 */</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* isempty函数：判断队列是否为空 */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> front == <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* clear函数：销毁队列 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (!isempty()) </span><br><span class="line">        dequeue(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h4><p>对于队列的数组实现我们需要说明几个问题：</p><blockquote><ul><li>如何实现回绕呢？<ul><li>很简单，就是利用取余运算的特性</li></ul></li><li>如何判断队列为空，如何判断队列已满呢？<ul><li>队列为空很简单，头尾指针重合时即表明队列为空</li><li><strong><em>我们初始化队列时，让head和tail都指向数组的第一个元素的位置。当进行若干次入队和出队操作后，队头和队尾只相差一个位置，如果再进行一次入队操作后，tail和head重合，这就表明队列中已没有可用的空间了，说明队列已满</em></strong></li></ul></li></ul></blockquote><hr><p>下图所展示的队列就已满了，当再进行一次入队操作后，tail就和head重合了。所以判断队列是否已满的条件是：<code>head == (tail + 1) % MAXVAL</code></p><p><img src="https://github.com/yaomer/pictures/blob/master/b.png?raw=true" alt=""></p><p>很显然，这样会浪费一个空间，但是这样保证了判断队列为空和队列已满的条件是不同的。</p><p>入队和出队操作都很简单，这里就不多说了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val[MAXVAL];    <span class="comment">/*  队列空间  */</span></span><br><span class="line">    <span class="keyword">int</span> head;     <span class="comment">/*  头指针  */</span></span><br><span class="line">    <span class="keyword">int</span> tail;     <span class="comment">/*  尾指针  */</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  initqueue函数：初始化队列  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initqueue</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;head = Q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  enqueue函数：入队  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Queue *Q, <span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull(Q)) &#123;</span><br><span class="line">    Q-&gt;val[Q-&gt;tail] = new_val;</span><br><span class="line">        Q-&gt;tail = (Q-&gt;tail + <span class="number">1</span>) % MAXVAL;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  dequeue函数：出队  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isempty(Q)) &#123;</span><br><span class="line">        tmp = Q-&gt;val[Q-&gt;head];</span><br><span class="line">        Q-&gt;head = (Q-&gt;head + <span class="number">1</span>) % MAXVAL;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  headqueue函数：返回队头元素  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">headqueue</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty(Q))</span><br><span class="line">        <span class="keyword">return</span> Q-&gt;val[Q-&gt;head];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isfull函数：检查队列是否已满  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;head == (Q-&gt;tail + <span class="number">1</span>) % MAXVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isempty函数：检查队列是否为空  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;head == Q-&gt;tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;和栈一样，队列也是一种操作受限制的表。&lt;strong&gt;&lt;em&gt;它只允许在表头（队头）执行删除操作（出队），在表尾（队尾）执行插入操作（入队）。&lt;/em&gt;&lt;/strong&gt; 同样的，队列也可以分别由数组和链表实现。&lt;/p&gt;
&lt;p&gt;队列的链表实现正如我们所描述的那样是直接而鲜明的，这里就不多加描述了。而队列的数组实现是有几点需要说明的。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>栈的基本操作</title>
    <link href="https://yaoer.me/2018/10/20/stack/"/>
    <id>https://yaoer.me/2018/10/20/stack/</id>
    <published>2018-10-19T16:00:00.000Z</published>
    <updated>2018-10-23T06:27:15.597Z</updated>
    
    <content type="html"><![CDATA[<p>栈是限制插入和删除只能在一个位置上进行的表，这个位置叫做栈顶。对空栈进行<strong>pop或top</strong>操作一般被认为是栈ADT的错误，而当运行<strong>push</strong>时栈空间用尽则是一个实现错误，不是栈ADT的错误。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Data_stack.svg/200px-Data_stack.svg.png" alt=""></p><a id="more"></a><p>栈的特点是 <strong><em>后进先出</em></strong>，因此栈特别适用于 <strong><em>保存和恢复调用现场</em></strong>。栈有许多重要应用，我们简单列举几例：</p><blockquote><ul><li>函数调用（尤其是递归的实现）</li><li>平衡符号</li><li>表达式转换</li><li>……</li></ul></blockquote><p>栈的基本操作很简单，主要有如下几种</p><blockquote><ul><li>push操作（入栈）</li><li>pop操作（出栈）</li><li>top操作（访问栈顶值）</li></ul></blockquote><p>根据你自身的需要，你还可以添加别的操作。比如：清空栈等。</p><p>下面我们给出栈的两种实现方法：数组和链表。</p><hr><h4 id="栈的数组实现"><a href="#栈的数组实现" class="headerlink" title="栈的数组实现"></a>栈的数组实现</h4><p>数组实现的唯一缺点就是：<strong><em>栈空间可能会用尽。</em></strong> 但在绝大多数情况下，只要稍加注意，是不会出现栈空间用尽的情况的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val[MAXVAL];    <span class="comment">/*  值栈  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;    <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将c压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull())</span><br><span class="line">        val[++sp] = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出并返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp--];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  clear函数：清空栈  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sp = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isfull函数：判断栈是否已满  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isempty函数：判断栈是否为空  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="栈的链表实现"><a href="#栈的链表实现" class="headerlink" title="栈的链表实现"></a>栈的链表实现</h4><p>由于栈自身的特点，特别适合于用单链表去实现。我们只需在表头进行<strong>push和pop</strong>操作即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>    <span class="comment">/*  表节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Node *sp;   <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将new_val压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    p-&gt;val = new_val;</span><br><span class="line">    p-&gt;next = sp;</span><br><span class="line">    sp = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isempty()) &#123;</span><br><span class="line">        tmp = sp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(sp);</span><br><span class="line">        sp = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> sp-&gt;val;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  clear函数：清空栈  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!isempty())</span><br><span class="line">pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isfull函数：判断栈是否已满  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isempty函数：判断栈是否为空  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;栈是限制插入和删除只能在一个位置上进行的表，这个位置叫做栈顶。对空栈进行&lt;strong&gt;pop或top&lt;/strong&gt;操作一般被认为是栈ADT的错误，而当运行&lt;strong&gt;push&lt;/strong&gt;时栈空间用尽则是一个实现错误，不是栈ADT的错误。&lt;br&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Data_stack.svg/200px-Data_stack.svg.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
</feed>
