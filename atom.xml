<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>若倾</title>
  
  <subtitle>若教解语应倾国，任是无情也动人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yaoer.me/"/>
  <updated>2018-12-14T05:15:45.226Z</updated>
  <id>https://yaoer.me/</id>
  
  <author>
    <name>妖儿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>双链表</title>
    <link href="https://yaoer.me/2018/12/14/dll/"/>
    <id>https://yaoer.me/2018/12/14/dll/</id>
    <published>2018-12-13T16:00:00.000Z</published>
    <updated>2018-12-14T05:15:45.226Z</updated>
    
    <content type="html"><![CDATA[<p>双链表的基本操作与单链表类似，相比单链表而言，在双链表中我们可以很方便的访问到一个节点的前驱和后继节点。</p><p>在本文中，我只描述一下双链表的插入和删除操作，其余的诸如查找、遍历、销毁等操作和单链表是相同，可以参照我的<a href="https://yaoer.me/2018/10/20/sll/">这篇文章</a>。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;                                                                                                               </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">last</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> <span class="title">Link</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Link *head, *tail;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> first;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>与在单链表中一样，双链表的插入也可分为头插和尾插，具体操作也都是类似的，唯一需要注意的是我们要注意维护几个指针，保证插入后的链表不断裂。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dll_insert_head(Link *p)</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;last = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    <span class="keyword">if</span> (head)</span><br><span class="line">        head-&gt;last = p;</span><br><span class="line">    head = p;</span><br><span class="line">    <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">        tail = head;</span><br><span class="line">        first = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dll_insert_head(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    Link *p;</span><br><span class="line"></span><br><span class="line">    assert(p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link)));</span><br><span class="line">    p-&gt;val = val;</span><br><span class="line"></span><br><span class="line">    _dll_insert_head(p);                                                                                                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头插法很简单，没什么好说的，有一点需要注意的是需要判断链表是否为空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Link *</span><br><span class="line">dll_find_tail(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Link *p, *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = head; p; pre = p, p = p-&gt;next)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dll_insert_tail(Link *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tail || (tail = dll_find_tail()))</span><br><span class="line">        tail-&gt;next = p;</span><br><span class="line">    p-&gt;last = tail;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">        head = tail;</span><br><span class="line">        first = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dll_insert_tail(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    Link *p;</span><br><span class="line"></span><br><span class="line">    assert(p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link)));</span><br><span class="line">    p-&gt;val = val;</span><br><span class="line"></span><br><span class="line">    _dll_insert_tail(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一次调用<strong>dll_insert_tail</strong>函数时，我们调用一个辅助过程<strong>dll_find_tail</strong>来找到链表的<strong>tail</strong>，然后将新插入的节点p插入到链表的结尾。</p><p>可以看到，这两种插入方法都是很简单的，但一旦要在一个有序双链表中插入一个节点，情况就有点复杂了。</p><p>我们可以简单分为几种情况来讨论：</p><blockquote><ul><li>在表头插入</li><li>在表中插入</li><li>在表尾插入</li></ul></blockquote><p>那么如何判断并处理这几种情况呢，下面我们结合代码来讨论一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dll_insert(Link *x)</span><br><span class="line">&#123;</span><br><span class="line">    Link *pre, *p;</span><br><span class="line"></span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;val &lt; x-&gt;val) &#123;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; pre) &#123;   <span class="comment">/* 在中间插入 */</span></span><br><span class="line">        pre-&gt;next = x;</span><br><span class="line">        x-&gt;last = pre;</span><br><span class="line">        x-&gt;next = p;</span><br><span class="line">        p-&gt;last = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p &amp;&amp; !pre)   <span class="comment">/* 在表头插入 */</span></span><br><span class="line">        _dll_insert_head(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!p &amp;&amp; pre)     <span class="comment">/* 在表尾插入 */</span></span><br><span class="line">        _dll_insert_tail(x);</span><br><span class="line">    <span class="keyword">else</span> &#123;   <span class="comment">/* 在空表中插入一个节点 */</span></span><br><span class="line">        x-&gt;last = x-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        head = tail = x;</span><br><span class="line">        first = <span class="number">1</span>;                                                                                                         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dll_insert(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    Link *p;</span><br><span class="line"></span><br><span class="line">    assert(p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link)));</span><br><span class="line">    p-&gt;val = val;</span><br><span class="line"></span><br><span class="line">    _dll_insert(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们需要先找到插入位置，这通过遍历链表即可做到。<strong>pre</strong>指向<strong>p</strong>的前驱节点，通过判断这两个指针的值，我们就可以知道新节点将要插入的位置。总共可以分为如下四种情况：</p><blockquote><ul><li>p为真、pre为假：在表头插入</li><li>p为真、pre为真：在表中插入</li><li>p为假、pre为真：在表尾插入</li><li>p为假、pre为假：在空表插入</li></ul></blockquote><p>具体的代码处理也是这样，只不过在表头和表尾插入的情况我们前面都已经描述过了，这里直接调用对应函数处理对应过程即可。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>利用上述三个插入函数的任意一个我们都可以创建一个双链表，<strong>dll_insert</strong>函数可以帮助我们创建出一个有序双链表。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除一个节点需要处理的情况与插入是类似的。如果找到了待删除节点，我们根据它所处的位置按不同的方法来删除它；如果没找到，那就什么也不用做。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dll_delete(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    Link *p, *pre;</span><br><span class="line"></span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">for</span> ( ; p; pre = p, p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val == val)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre) &#123;</span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next)   <span class="comment">/* 删除中间节点 */</span></span><br><span class="line">                p-&gt;next-&gt;last = p-&gt;last;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tail = pre;   <span class="comment">/* 删除表尾 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span>   <span class="comment">/* 删除表头 */</span></span><br><span class="line">            head = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果p为真、pre为假，就说明待删除的节点位于表头，我们摘除掉头节点即可；否则的话，它就可能在中间，也可能在末尾，对应处理就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;双链表的基本操作与单链表类似，相比单链表而言，在双链表中我们可以很方便的访问到一个节点的前驱和后继节点。&lt;/p&gt;
&lt;p&gt;在本文中，我只描述一下双链表的插入和删除操作，其余的诸如查找、遍历、销毁等操作和单链表是相同，可以参照我的&lt;a href=&quot;https://yaoer.me/2018/10/20/sll/&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>简单AI贪吃蛇</title>
    <link href="https://yaoer.me/2018/11/09/ai-snake/"/>
    <id>https://yaoer.me/2018/11/09/ai-snake/</id>
    <published>2018-11-08T16:00:00.000Z</published>
    <updated>2018-11-09T05:34:13.104Z</updated>
    
    <content type="html"><![CDATA[<p>简单的手工移动的贪吃蛇模型来自于我之前的一篇<a href="https://yaoer.me/2018/10/25/snake/">博客</a>，为了实现简单的AI功能，我只是在它的基础上添加了相关的AI部分代码而已。但就算如此，也有许多东西需要考虑。</p><p>AI贪吃蛇通俗点来说就是让蛇自己实现<strong><em>自动寻路功能</em></strong>。从这一点来说，首先应该想到的就是有关图的搜索算法了，这个我们下面会详细描述。现在我们先考虑最简单的一种情况，即<strong><em>使用某种办法，让蛇自己先动起来</em></strong>。</p><a id="more"></a><p>那么使用什么办法呢？要想让蛇自己寻找食物去吃，那么首先应该知道食物的坐标，这个不难办到（我们假设每次只会出现一个食物），然后就需要一条从蛇本身到食物的一条路径，蛇只要沿着这条路径走，就能吃到食物了。先不要去管这种方法的可行性有多高，最起码它能让蛇自己动起来，这已经是一个很好的开头了，不是吗？</p><p>那么怎么去选择这条路径呢？我们知道，两点之间的路径可以有好多种，其中直线最短，显然我们希望蛇能沿着最短路径吃到食物，但直线显然是不现实的，它无法沿着直线走。那我们可以退而求其次，选择一条<strong><em>最简单方便的路径</em></strong>，这条路径就是所谓的<strong><em>曼哈顿距离</em></strong>。它实际上很简单，在具体的编程中也很容易操作。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/08/Manhattan_distance.svg/300px-Manhattan_distance.svg.png" alt=""></p><blockquote><p>红、蓝与黄线都表示曼哈顿距离，它们都拥有一样的长度；而绿线则表示欧几里得距离。</p></blockquote><p>我们可以选择<strong>红线</strong>这种最简单的曼哈顿距离，每次我们记录下路径，然后沿着这条路径去走，直到吃到食物。在游戏初期，蛇身的长度很短时，这种方法是有一定作用的，可以让蛇坚持一段时间。<strong><em>但一旦蛇身变长，情形就显然有所不同了。</em></strong></p><p><strong><em>贪吃蛇每时每刻所面临的情形不是静态的一成不变的，而是随着它的移动不断发生变化的，前一刻所做出的安全可行的决策，在后一刻未必是安全可行的，也就是说，<font color="red">对于路径的规划应该是动态的，蛇每走一步，我们都应该重新审视蛇当前所面临的处境，重新寻找出一条可行的路径。</font></em></strong> &lt;/font&gt;</p><p>基于这种考虑，我们可以想到使用<strong><em>BFS和DFS</em></strong>来动态解决蛇的自动寻路问题。因为<strong><em>BFS</em></strong>找到的一定是最短路径，因此，我们优先考虑使用<strong><em>BFS</em></strong>。但后面我们就会意识到，<strong><em>事情有时并非绝对，并不是所有的情况下都需要走最短的路径。</em></strong></p><p>现在我们要思考几个问题：</p><blockquote><ul><li>每次只要找到最短路径，就要沿着该路径去吃食物吗？</li><li>吃到食物后，蛇有没有可能陷入绝境？</li><li>如果无法找到蛇到食物的最短路径怎么办？</li><li>。。。</li></ul></blockquote><p>这样想来，有些问题确实还挺复杂的。针对上述问题，我们先给出一个初步的算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (能找到吃食物的最短路径)</span><br><span class="line">    去吃食物</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    向安全的地方随便走一步</span><br></pre></td></tr></table></figure><p>显然上述算法也是有缺陷的，它并没有解决我们上面提出的问题。也就是说，<strong><em>它只满足于现在能吃到食物，而不去考虑这种行为是否会将自己置身于危险的境地</em></strong>。但它解决了一个问题，如果无法找到路径，只能<strong><em>wander</em></strong>一步，这种看似没有道理的<strong><em>闲逛</em></strong>，在实际中却是工作的很好。这种方案具有一定的随机性，并非完美无缺。但在绝大多数情况下它是可行的。</p><p><img src="https://github.com/yaomer/pictures/blob/master/snake.png?raw=true" alt=""></p><p>蛇在去吃食物时，显然不能只顾当前，而应该考虑的长远一点。如果仔细观察蛇身的移动，我们会发现，<strong><em>每次蛇身移动过后，蛇尾总是会空出一个位置，而这个位置一定是安全的，也是我们想要的。也就是说，每当去吃食物时，先判断一下能否找到从蛇身到蛇尾的路径，然后再作出决策。</em></strong></p><p>至于从蛇身到蛇尾的路径应该是什么样的，显然此时我们理所当然的认为应该是最短路径。但之后我们就会发现，这种方法如果运气好的话，可以让蛇运行相当长的一段时间，但它有时却会让蛇陷入到<strong><em>无限循环</em></strong> 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (能找到吃食物的最短路径)</span><br><span class="line">    <span class="keyword">if</span> (吃到食物后能找到蛇尾)</span><br><span class="line">        去吃食物</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (能找到蛇头到蛇尾的最短路径)</span><br><span class="line">            跟着蛇尾走</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            wander一步</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (能找到蛇头到蛇尾的最短路径)</span><br><span class="line">        跟着蛇尾走</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        wander一步</span><br></pre></td></tr></table></figure><p>这时的算法稍微有点复杂，但其实也不难，因为逻辑简单清楚。这里可能会出现问题的地方就是 <strong><em>wander</em></strong> 这种策略了。</p><p>我们可以试想一下这种情况：</p><blockquote><p>当蛇要走下一步时发现，它能找到吃食物的路径，但吃过后却无法找到自己的尾巴，然而却能找到从自己蛇头到蛇尾的路径。基于我们的算法策略，它认为现在去吃食物不安全，所以它决定跟着蛇尾走，但这种做法是有缺陷的，很有可能它会一直陷入这种怪圈中，因为下一步可能一直是不安全的，这样就会让它自己陷入无限循环之中，即一直追着自己的尾巴走。</p></blockquote><p>对于应该如何解决这种困境，我的初步想法是，<strong><em>在寻找到蛇尾的路径时，不能使用BFS，而应该使用DFS朝相反方向找一条相对来说较远的路径</em></strong>。这种反其道而行之的做法却是合理的，当蛇无法找到可行路径时，它就应该为自己之后的行动留有余地。</p><p>这种方法应该有一定概率跑完全图，但我还没有去实现它，我目前实现了只使用<strong><em>BFS</em></strong>的那个版本。</p><hr><p>我们上面讨论了相关算法策略，但在具体编程实现时仍有许多需要仔细思考的东西，下面我会给出相应的C代码，并作出一定的解释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY   50    <span class="comment">/*  设置延时  */</span></span></span><br><span class="line"><span class="comment">/*  蛇的活动地图的大小  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW     (LINES - 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COL     (COLS - 25) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">snake</span> &#123;</span>     <span class="comment">/*  蛇身节点  */</span></span><br><span class="line">    <span class="keyword">int</span> sx;       </span><br><span class="line">    <span class="keyword">int</span> sy;       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snake</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Snake;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> &#123;</span>    <span class="comment">/*  队列节点  */</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> *<span class="title">pre</span>;</span>    <span class="comment">/*  用于回溯路径  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">smap</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">30</span>][<span class="number">120</span>];     <span class="comment">/*  标记是否访问过某个点  */</span></span><br><span class="line">&#125; Smap;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isok(x, y)  ((x) &gt; 2 &amp;&amp; (x) <span class="meta-string">&lt;= ROW &amp;&amp; (y) &gt; 3 &amp;&amp; (y) &lt;= COL)  </span></span></span><br><span class="line"></span><br><span class="line">Snake *head, *tail;     <span class="comment">/*  蛇头、蛇尾  */</span></span><br><span class="line">Queue *front, *rear;    <span class="comment">/*  队头，队尾  */</span></span><br><span class="line"><span class="keyword">int</span> fx, fy;     <span class="comment">/*  食物坐标  */</span></span><br><span class="line"><span class="keyword">int</span> nx, ny;     <span class="comment">/*  蛇下一步要走的坐标  */</span></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> foundpath;      <span class="comment">/*  是否找到路径  */</span></span><br><span class="line"><span class="keyword">int</span> findtail;       <span class="comment">/*  是否在寻找蛇尾  */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    signal(SIGALRM, display_snake);</span><br><span class="line">    swait();</span><br><span class="line">    endwin();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swait</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"><span class="comment">/*  输入'q'，则退出游戏  */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getch()) != <span class="string">'q'</span>)</span><br><span class="line">        set_ticker(DELAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>display_snake()</em></strong>函数便是整个AI部分的核心控制函数了，它完全符合我们上面所描述的算法，只是简单的用C语言翻译过来而已。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  initgame函数：游戏初始化  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initscr();   <span class="comment">/*  初始化curses  */</span></span><br><span class="line">    start_color();  <span class="comment">/*  初始化颜色表  */</span></span><br><span class="line">    set_color();    <span class="comment">/*  设置颜色  */</span></span><br><span class="line">    box(stdscr, ACS_VLINE, ACS_HLINE);   <span class="comment">/*  绘制一个同物理终端大小相同的窗口  */</span></span><br><span class="line">    noecho();    <span class="comment">/*  关闭键入字符的回显  */</span></span><br><span class="line">    cbreak();    <span class="comment">/*  字符一键入，直接传递给程序  */</span></span><br><span class="line">    curs_set(<span class="number">0</span>);    <span class="comment">/*  隐藏光标  */</span></span><br><span class="line">    draw_map();</span><br><span class="line">    creat_snake();</span><br><span class="line">    creat_food();</span><br><span class="line">    refresh();   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  display_snake函数：游戏的主要控制逻辑  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_snake</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bfs(head-&gt;sx, head-&gt;sy, fx, fy)) &#123;    <span class="comment">/*  能找到食物  */</span></span><br><span class="line">        <span class="keyword">int</span> tx = nx; </span><br><span class="line">        <span class="keyword">int</span> ty = ny;</span><br><span class="line">        findtail = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bfs(nx, ny, tail-&gt;sx, tail-&gt;sy))     <span class="comment">/*  吃到食物后能找到蛇尾  */</span></span><br><span class="line">            add_snake(tx, ty);    <span class="comment">/*  去吃食物  */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bfs(head-&gt;sx, head-&gt;sy, tail-&gt;sx, tail-&gt;sy))</span><br><span class="line">                add_snake(nx, ny);    <span class="comment">/*  跟着蛇尾走  */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                around();    <span class="comment">/*  随便逛逛  */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        findtail = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bfs(head-&gt;sx, head-&gt;sy, tail-&gt;sx, tail-&gt;sy))</span><br><span class="line">            add_snake(nx, ny);    </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            around(); </span><br><span class="line">    &#125;</span><br><span class="line">    findtail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (is_eat_food())</span><br><span class="line">        creat_food();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        del_snake();</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>around()</em></strong>函数只是在蛇头周围找出一处安全的位置去走。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  around函数：随便逛逛  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">around</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    findtail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tx = head-&gt;sx + dx[i];</span><br><span class="line">        <span class="keyword">int</span> ty = head-&gt;sy + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (isok(tx, ty) &amp;&amp; !is_crash_snake(tx, ty)) &#123;</span><br><span class="line">            add_snake(tx, ty);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  creat_snake函数：初始化蛇身  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_snake</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(head = tail = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Snake)));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    srand(clock());   <span class="comment">/*  以当前挂钟时间作随机种子数  */</span></span><br><span class="line">    <span class="keyword">while</span> ((head-&gt;sx = rand() % (ROW - <span class="number">2</span>) + <span class="number">3</span>) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">while</span> ((head-&gt;sy = rand() % (COL - <span class="number">3</span>) + <span class="number">4</span>) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">    mvaddch(head-&gt;sx, head-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  creat_food函数：设置食物  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_food</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(clock());</span><br><span class="line">    <span class="keyword">while</span> ((fx = rand() % (ROW - <span class="number">2</span>) + <span class="number">3</span>) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">while</span> ((fy = rand() % (COL - <span class="number">3</span>) + <span class="number">4</span>) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">if</span> (is_crash_snake(fx, fy))   <span class="comment">/*  食物不能覆盖蛇身  */</span></span><br><span class="line">        creat_food();</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">2</span>));</span><br><span class="line">    mvaddch(fx, fy, <span class="string">' '</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  add_snake函数：在蛇头增加2个节点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_snake</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Snake *p, *q;</span><br><span class="line"></span><br><span class="line">    assert(p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Snake)));</span><br><span class="line">    assert(q = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Snake)));</span><br><span class="line">    head-&gt;next = p;</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">    p-&gt;sx = (head-&gt;sx + x) / <span class="number">2</span>;</span><br><span class="line">    p-&gt;sy = (head-&gt;sy + y) / <span class="number">2</span>;</span><br><span class="line">    mvaddch(p-&gt;sx, p-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    q-&gt;sx = x;</span><br><span class="line">    q-&gt;sy = y;</span><br><span class="line">    mvaddch(q-&gt;sx, q-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">    head = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  del_snake函数：在蛇尾删除2个节点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_snake</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Snake *tmp;</span><br><span class="line"></span><br><span class="line">    mvaddch(tail-&gt;sx, tail-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    mvaddch(tail-&gt;next-&gt;sx, tail-&gt;next-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    tmp = tail-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(tail-&gt;next);</span><br><span class="line">    <span class="built_in">free</span>(tail);</span><br><span class="line">    tail = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  is_eat_food函数：判断是否吃到食物  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_eat_food</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;sx == fx &amp;&amp; head-&gt;sy == fy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>is_crash_snake()</em></strong>函数需要注意的一点是，<strong><em>当正在寻找到蛇尾的路径时，蛇尾本身将不能视作蛇身的一部分</em></strong>。即在判断是否撞到蛇自己时，应该忽略蛇尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  bfs函数：寻找从(sx, sy)到(rx, ry)的最短路径  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> sx, <span class="keyword">int</span> sy, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Smap.vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(Smap.vis));</span><br><span class="line"></span><br><span class="line">    initqueue(sx, sy, <span class="literal">NULL</span>);</span><br><span class="line">    Smap.vis[sx][sy] = <span class="number">1</span>;    <span class="comment">/*  标记为已访问  */</span></span><br><span class="line">    foundpath = <span class="number">0</span>;    <span class="comment">/*  未找到路径  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (front) &#123;</span><br><span class="line">        <span class="keyword">if</span> (front-&gt;x == rx &amp;&amp; front-&gt;y == ry) &#123;    <span class="comment">/*  找到了食物  */</span></span><br><span class="line">            backpath(front);    <span class="comment">/*  回溯路径  */</span></span><br><span class="line">            foundpath = <span class="number">1</span>;    <span class="comment">/*  已找到路径  */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tx = front-&gt;x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ty = front-&gt;y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (!Smap.vis[tx][ty] &amp;&amp; isok(tx, ty) &amp;&amp; !is_crash_snake(tx, ty)) &#123;</span><br><span class="line">                enqueue(tx, ty, front);</span><br><span class="line">                Smap.vis[tx][ty] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    clean();   <span class="comment">/*  清空队列  */</span></span><br><span class="line">    <span class="keyword">return</span> foundpath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  backpath函数：回溯路径，找到蛇下一步需要走的坐标  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backpath</span><span class="params">(Queue *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue *q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;pre) &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">    nx = q-&gt;x;</span><br><span class="line">    ny = q-&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  is_crash_snake函数：是否撞到了蛇自己  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_crash_snake</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Snake *p = tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (findtail)</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p != tail &amp;&amp; x == p-&gt;sx &amp;&amp; y == p-&gt;sy)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == p-&gt;sx &amp;&amp; y == p-&gt;sy)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是队列的几个基本操作。队列主要用于 <strong><em>BFS</em></strong> 中，用于记录路径。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initqueue函数：初始化队列  */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initqueue</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Queue *pre)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Queue *p;</span><br><span class="line"></span><br><span class="line">    assert(p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue)));</span><br><span class="line">    p-&gt;x = x; </span><br><span class="line">    p-&gt;y = y;</span><br><span class="line">    p-&gt;pre = pre;</span><br><span class="line">    front = rear = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* enqueue函数：入队操作 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Queue *pre)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Queue *p;</span><br><span class="line"></span><br><span class="line">    assert(p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue)));</span><br><span class="line">    p-&gt;x = x; </span><br><span class="line">    p-&gt;y = y;</span><br><span class="line">    p-&gt;pre = pre;</span><br><span class="line">    rear-&gt;next = p;</span><br><span class="line">    rear = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  clean函数：销毁队列  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rear) &#123;</span><br><span class="line">        tmp = rear-&gt;pre;</span><br><span class="line">        <span class="built_in">free</span>(rear);</span><br><span class="line">        rear = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是一些画图和设置函数，可以根据自己的需要去调整。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  draw_map函数：绘制游戏地图  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_map</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    attron(COLOR_PAIR(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; COLS - <span class="number">2</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        mvaddch(<span class="number">2</span>, i, <span class="string">' '</span>);</span><br><span class="line">        mvaddch(LINES - <span class="number">2</span>, i, <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; LINES - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        mvaddch(i, <span class="number">3</span>, <span class="string">' '</span>);</span><br><span class="line">        mvaddch(i, COL + <span class="number">1</span>, <span class="string">' '</span>);</span><br><span class="line">        mvaddch(i, COLS - <span class="number">4</span>, <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  set_color函数：设置颜色属性  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_color</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_pair(<span class="number">1</span>, COLOR_GREEN, COLOR_GREEN);</span><br><span class="line">    init_pair(<span class="number">2</span>, COLOR_RED, COLOR_RED);</span><br><span class="line">    init_pair(<span class="number">3</span>, COLOR_WHITE, COLOR_WHITE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  set_ticker函数：设置间隔计时器(ms)  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_ticker</span><span class="params">(<span class="keyword">int</span> n_msecs)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_timeset</span>;</span>  </span><br><span class="line">    <span class="keyword">long</span> n_sec, n_usecs;  </span><br><span class="line">  </span><br><span class="line">    n_sec = n_msecs / <span class="number">1000</span>;      </span><br><span class="line">    n_usecs = (n_msecs % <span class="number">1000</span>) * <span class="number">1000L</span>;      </span><br><span class="line">    </span><br><span class="line">    new_timeset.it_interval.tv_sec = n_sec;   <span class="comment">/*  设置初始间隔  */</span>  </span><br><span class="line">    new_timeset.it_interval.tv_usec = n_usecs;  </span><br><span class="line"></span><br><span class="line">    new_timeset.it_value.tv_sec = n_sec;      <span class="comment">/*  设置重复间隔  */</span>  </span><br><span class="line">    new_timeset.it_value.tv_usec = n_usecs;  </span><br><span class="line">    <span class="keyword">return</span> setitimer(ITIMER_REAL, &amp;new_timeset, <span class="literal">NULL</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后要说明的一点是，不管是<strong><em>BFS</em></strong>还是<strong><em>DFS</em></strong>，都<code>盲目式</code>搜索算法，一般而言，它们都不是高效的，而使用<code>启发式</code>搜索算法显然更好一些，如大名鼎鼎的<code>A*</code>算法。我呢，希望自己以后能有时间用<code>A*</code>算法去实现一下这个<strong><em>简单的AI贪吃蛇</em></strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的手工移动的贪吃蛇模型来自于我之前的一篇&lt;a href=&quot;https://yaoer.me/2018/10/25/snake/&quot;&gt;博客&lt;/a&gt;，为了实现简单的AI功能，我只是在它的基础上添加了相关的AI部分代码而已。但就算如此，也有许多东西需要考虑。&lt;/p&gt;
&lt;p&gt;AI贪吃蛇通俗点来说就是让蛇自己实现&lt;strong&gt;&lt;em&gt;自动寻路功能&lt;/em&gt;&lt;/strong&gt;。从这一点来说，首先应该想到的就是有关图的搜索算法了，这个我们下面会详细描述。现在我们先考虑最简单的一种情况，即&lt;strong&gt;&lt;em&gt;使用某种办法，让蛇自己先动起来&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>常见排序算法总结</title>
    <link href="https://yaoer.me/2018/11/07/sort/"/>
    <id>https://yaoer.me/2018/11/07/sort/</id>
    <published>2018-11-06T16:00:00.000Z</published>
    <updated>2018-11-07T10:08:05.783Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中，我们对常见的排序算法作一个总结。包括：<strong><em>冒泡、选择、插入、希尔、归并、快排、堆排以及桶排。</em></strong></p><a id="more"></a><p>以上排序算法中，除了桶排序以外，其余算法都是基于<font color="red">比较</font>的。在最差情况下，任何一种比较排序至少需要<font color="red">O(n log n)</font>次比较操作。这是比较操作所获取的信息有限所导致的，或者说是全序集的模糊代数结构所导致的。</p><p>不过，比较排序<strong><em>在控制比较函数方面有显著优势，能对各种数据类型进行排序，并且可以很好地控制一个序列如何被排序</em></strong>。例如，可以通过改变比较函数从而使排序结果倒置。并且 <strong><em>一旦比较函数完成，任何比较算法都可以不经修改地使用；</em></strong>而非比较排序对数据类型的要求会更严格。</p><hr><p>排序算法分类：</p><div class="table-container"><table><thead><tr><th>插入排序</th><th>选择排序</th><th>交换排序</th></tr></thead><tbody><tr><td>直接插入</td><td>选择排序</td><td>冒泡排序</td></tr><tr><td>希尔排序</td><td>堆排序</td><td>快排</td></tr></tbody></table></div><p>各排序算法的时间复杂度：</p><div class="table-container"><table><thead><tr><th>排序算法</th><th>最坏时间复杂度</th><th>平均时间复杂度</th><th>最优时间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>插入排序</td><td>O($n^2$)</td><td>O($n^2$)</td><td>O(n)</td><td>稳定</td></tr><tr><td>冒泡排序</td><td>O($n^2$)</td><td>O($n^2$)</td><td>O(n)（优化后的）</td><td>稳定</td></tr><tr><td>选择排序</td><td>O($n^2$)</td><td>O($n^2$)</td><td>O($n^2$)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O($n^2$)</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>不稳定</td></tr><tr><td>桶排序</td><td>O($n^2$)</td><td>O(n + k)</td><td>O(n)</td><td>不稳定</td></tr><tr><td>希尔排序</td><td></td><td></td><td></td><td>不稳定</td></tr></tbody></table></div><p>（注：希尔排序的时间复杂度依赖于增量序列的选择）</p><p>在接下来对各排序算法的描述中，我们用<strong><em>伪代码</em></strong>描述算法本身，并给出C语言的实现。我们假设我们所描述的排序算法都是对<strong><em>整形数组A[1..n]</em></strong>进行排序。</p><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序是一种简单直观的排序算法。它的工作原理是构建有序序列。对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong><em>插入排序对几乎已经排好序的序列是非常高效的。但一般情况下，插入排序是低效的，因为它每次只能将数据移动一位。</em></strong></p><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">2</span> to n</span><br><span class="line">    key = A[j]</span><br><span class="line">    i = j - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key</span><br><span class="line">        A[i + <span class="number">1</span>] = A[i]</span><br><span class="line">        i = i - <span class="number">1</span></span><br><span class="line">    A[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><p>C实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  insertion_sort函数：插入排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> key;    <span class="comment">/*  每次待插入的值  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        key = v[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; v[j] &gt; key; j--)</span><br><span class="line">            v[j + <span class="number">1</span>] = v[j];    <span class="comment">/*  将大于key的元素后移  */</span></span><br><span class="line">        v[j + <span class="number">1</span>] = key;    <span class="comment">/*  将key插入到相应位置  */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/2/25/Insertion_sort_animation.gif" alt=""></p><hr><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是一种简单的排序算法。<strong><em>它重复地遍历要排序的整个数列，每次比较相邻的两个元素，如果它们的顺序错误就把它们交换过来。这个算法名字的由来是因为小的元素会经由交换操作而慢慢“上浮”到排序序列的最前面。</em></strong></p><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">2</span> to n - j</span><br><span class="line">        <span class="keyword">if</span> A[i - <span class="number">1</span>] &gt; A[i]</span><br><span class="line">            swap A[i - <span class="number">1</span>] with A[i]</span><br></pre></td></tr></table></figure><p>C实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  bubble_sort函数：冒泡排序（原始版本）  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">/*  共需要进行n趟排序  */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n - i; j++)   <span class="comment">/*  每趟排序都使小数上升，大数下沉  */</span></span><br><span class="line">            <span class="keyword">if</span> (v[j - <span class="number">1</span>] &gt; v[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = v[j];</span><br><span class="line">                v[j] = v[j - <span class="number">1</span>];</span><br><span class="line">                v[j - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，当输入的序列已经是有序的时候，该排序算法仍然会做大量无用的比较操作。因此，我们可以考虑优化一下它。</p><p>我们可以考虑一下该算法完成整个排序的结束条件是什么，在现在这个原始版本中，它总要对整个待排序序列遍历n趟，即使在某一次遍历之后，已经排好序了，它仍然会像之前那样做完它应该做的所有工作，但这完全是没必要的，一旦排好序，算法就应该结束了。</p><p>为此，<strong><em>我们可以设置一个标志位exchange，标记在某一趟排序过程中，是否发生过交换，一旦没有发生过交换操作，就说明已经排好序了。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  bubble_sort函数：冒泡排序（优化版本）  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, exchange;</span><br><span class="line">    <span class="keyword">enum</span> &#123;NO, YES&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        exchange = NO;    </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (v[j - <span class="number">1</span>] &gt; v[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = v[j];</span><br><span class="line">                v[j] = v[j - <span class="number">1</span>];</span><br><span class="line">                v[j - <span class="number">1</span>] = tmp;</span><br><span class="line">                exchange = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exchange == NO)   <span class="comment">/*  上一趟排序中，没有发生过交换  */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif" alt=""></p><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是一种简单直观的排序算法。<strong><em>它每次找出从未排序序列中的最小值，然后将该最小值与未排序序列的第一个数交换，从而完成对有序区的增量。</em></strong></p><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">for</span> i = j to n</span><br><span class="line">        find A[min]</span><br><span class="line">    swap A[min] with A[j]</span><br></pre></td></tr></table></figure><p>C实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  selection_sort函数：选择排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (v[j] &lt; v[min])    <span class="comment">/*  找出未排序序列中的最小元素  */</span></span><br><span class="line">                min = j;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = v[i];</span><br><span class="line">            v[i] = v[min];</span><br><span class="line">            v[min] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" alt=""></p><hr><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序， 也称 <strong><em>缩小增量排序</em></strong>，是对直接插入排序的一种更高效的改进版本。它的基本思想是：<strong><em>先比较距离较远的元素，这样可以让每个元素一次性地朝最终位置前进一大步（而非像直接插入排序那样每次只能移动一步），从而快速减少大量无序的情况，并且减轻后续的工作。被比较的元素之间的距离逐步缩小，直到减少为1，这时就变成了直接插入排序对几近有序的序列进行排序的情况。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  shell_sort函数：希尔排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> gap;    <span class="comment">/*  步长  */</span></span><br><span class="line"><span class="comment">/*  这里采用希尔增量  */</span></span><br><span class="line">    <span class="keyword">for</span> (gap = n; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)    <span class="comment">/*  控制步长  */</span></span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; n; i++)   <span class="comment">/*  在各对元素间移动位置  */</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; v[j] &gt; v[j + gap]; j -= gap) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = v[j];    <span class="comment">/*  比较各对相距gap个位置的元素  */</span></span><br><span class="line">                v[j] = v[j + gap];</span><br><span class="line">                v[j + gap] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif" alt=""></p><p>希尔排序算法彩条：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Shell_sorting_algorithm_color_bars.svg/220px-Shell_sorting_algorithm_color_bars.svg.png" alt=""></p><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是<code>分治法</code>的一个非常典型的应用，其算法核心是<code>合并(merge)</code>操作。</p><p>因为用到了分治法，所以这里我们简述一下其思想：<strong><em>将原问题分解为若干个规模较小的类似于原问题的子问题，递归地求解这些子问题，然后再合并所有子问题的解来建立原问题的解。</em></strong></p><p>分治法都有类似以下的三个步骤：</p><blockquote><ul><li>分解：将原问题划分为若干个类似于原问题的规模较小的实例</li><li>求解：递归求解所有的子问题，若子问题规模足够小，则直接求解</li><li>合并：合并所有子问题的解，从而得到原问题的解</li></ul></blockquote><p>归并排序完全遵循上述模式，具体操作如下：</p><blockquote><ul><li>分解：将待排序的n个元素的序列划分为各具有n/2个元素的两个子序列</li><li>求解：使用归并排序递归地排序两个子序列</li><li>合并：合并两个已排好序的子序列以产生新的已排好序的序列</li></ul></blockquote><p>当待排序的序列长度为1时，<strong><em>递归“开始回升“</em></strong>，在这种情况下不需做任何工作，因为长度为1的每个序列都已排好序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  merge_sort函数：归并排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(v, left, mid);</span><br><span class="line">        merge_sort(v, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(v, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  merge函数：合并操作  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> tmp[right - left + <span class="number">1</span>];    <span class="comment">/*  用于合并操作的一个附加的临时数组  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= mid &amp;&amp; j &lt;= right; k++)</span><br><span class="line">        tmp[k] = v[i] &lt; v[j] ? v[i++] : v[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        tmp[k++] = v[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">        tmp[k++] = v[j++];</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)    <span class="comment">/*  将排好序的序列拷贝回原数组  */</span></span><br><span class="line">        v[left++] = tmp[k++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然归并排序的最坏运行时间是O(n $\log$ n)，但它很难用于主存排序，主要问题在于合并操作中所需要的线性附加内存。不过，merge例程是大多数外部排序算法的基石。</p><p>归并排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" alt=""></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c5/Merge_sort_animation2.gif/220px-Merge_sort_animation2.gif" alt=""></p><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是实践中已知的最快的排序算法，同样用到了分治法的思想。它之所以特别快的原因主要是非常精炼和高度优化的内部循环。</p><p>快排的基本算法如下：</p><p><strong><em>对于一个给定的数组，从中选择任一元素作为主元，以主元为界将其余元素划分为两个子集：一个子集中的所有元素都小于主元，另一个子集中的所有元素都大于或等于主元。对这两个子集递归地执行这一过程，当某个子集中的元素个数小于2时，该子集就不需要再次排序了，即终止递归。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  q_sort函数：快速排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">q_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)    <span class="comment">/*  若某个子集的元素个数小于2，则终止递归  */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    swap(v, left, (left + right) / <span class="number">2</span>);   <span class="comment">/*  每次选取每个子集中间的元素作为主元  */</span></span><br><span class="line">    last = left;</span><br><span class="line">    <span class="keyword">for</span> (i = left + <span class="number">1</span>; i &lt;= right; i++)    <span class="comment">/*  划分子集  */</span></span><br><span class="line">        <span class="keyword">if</span> (v[i] &lt; v[left])</span><br><span class="line">            swap(v, i, ++last);</span><br><span class="line">    swap(v, left, last);     <span class="comment">/*  恢复主元  */</span></span><br><span class="line"></span><br><span class="line">    q_sort(v, left, last - <span class="number">1</span>);</span><br><span class="line">    q_sort(v, last + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  swap函数：交换两个数  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = v[i];</span><br><span class="line">    v[i] = v[j];</span><br><span class="line">    v[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt=""></p><hr><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序可以详见我的另一篇博客<a href="https://yaoer.me/2018/10/24/heap/">堆及其应用</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本文中，我们对常见的排序算法作一个总结。包括：&lt;strong&gt;&lt;em&gt;冒泡、选择、插入、希尔、归并、快排、堆排以及桶排。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yaoer.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>浅析scanf函数</title>
    <link href="https://yaoer.me/2018/11/01/scanf/"/>
    <id>https://yaoer.me/2018/11/01/scanf/</id>
    <published>2018-10-31T16:00:00.000Z</published>
    <updated>2018-11-01T07:47:38.362Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h3><blockquote><ul><li><strong><em>函数原型</em></strong>： <code>int scanf(char *fmt, ...)</code></li><li><strong><em>参数说明</em></strong>：它的第一个参数fmt是格式字符串，包含普通字符和转换说明；第二个参数是可变长参数表，它的参数必须是指针，这是c语言 <strong><em><font color="red">传值调用语义所要求的</font></em></strong>  。它的返回值是 <strong><em><font color="red">成功匹配并赋值的输入项个数。</font></em></strong> 如果到达文件尾，它返回EOF。</li></ul></blockquote><a id="more"></a><p>我们可以举例说明一下它的返回值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果我们输入两个整数，程序将打印2；如果一个是整数，一个不是整数的话，程序则会打印1；通俗来说，<strong><em>就是我们输入的与格式字符串中转换说明匹配的参数个数将作为返回值。</em></strong></p></blockquote><h3 id="格式字符串"><a href="#格式字符串" class="headerlink" title="格式字符串"></a>格式字符串</h3><blockquote><ul><li><strong><em>普通字符</em></strong>（不包括%）：用于匹配输入流中下一个<strong>非空白字符。</strong></li><li><strong><em>转换说明</em></strong>：依次由一个<strong>%</strong>、一个可选的<strong>赋值禁止符*</strong>、一个可选的<strong>数值(指定最大字段宽度)</strong>、一个可选的<strong>h、l或L字符(指定目标对象的宽度)</strong> 以及一个<strong>转换字符</strong>组成。</li></ul></blockquote><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><ul><li>首先，逐个拿输入缓冲区内的字符与格式字符串进行匹配检查。</li><li><strong><em>对于转换说明，匹配成功则读入字符；匹配不成功，则将字符压回到输入缓冲区中，留待下次读取，然后函数返回。</em></strong></li><li><strong><em>对于普通字符和空白符，匹配成功时把字符丢弃掉；匹配不成功，则将字符压回到输入缓冲区中，函数返回。</em></strong></li><li>下一次调用scanf函数时将从上一次转换的最后一个字符的下一个字符开始继续搜索</li><li>转换说明用于控制下一个输入字段的转换。但是如果转换说明中有赋值禁止符*，则跳过该字段，不进行赋值。 <strong><em><font color="red">输入字段被定义为一个不包括空白符的字符串，其边界定义为到下一个空白符或达到指定的字段宽度。</font></em></strong> 而这表明scanf函数将越过行边界读取输入。</li><li>需要说明的是：<strong><em>scanf函数会忽略格式串中的空白符</em></strong>；当在格式串中遇见一个或多个连续的空白符时，它会重复读取，直到遇见一个非空白符为止，然后将最后遇见的非空白符重新放到输入缓冲区中。</li></ul></blockquote><h3 id="一些有趣的转换说明"><a href="#一些有趣的转换说明" class="headerlink" title="一些有趣的转换说明"></a>一些有趣的转换说明</h3><h4 id="scanf扫描集"><a href="#scanf扫描集" class="headerlink" title="scanf扫描集"></a>scanf扫描集</h4><blockquote><ul><li>使用格式是这样的：<strong>%[]</strong>。它需要一个<strong>char *</strong> 类型的参数，并且总在所有输入之后存储一个 <strong>‘\0’</strong> 字符。</li><li>方括号里可以指定匹配的所有字符，也可以指定所有不匹配的字符，只需 <strong>%<sup><a href="#fn_" id="reffn_"></a></sup></strong> 。如果想在指定的集合中包含 <strong>]</strong> ，则可以这样使用 <strong>%[]]</strong> ，例如 <strong>%[][]</strong> 可以扫描方括号。 <strong><em><font color="red">不能将空字符包含在指定的字符集合中。</font></em></strong></li></ul></blockquote><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[123]"</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);</span><br><span class="line">    <span class="comment">/*  它会扫描整个输入，直到遇见空格、制表或其他字符(非123)，然后将之前的字符保存在字符数组s中  */</span></span><br><span class="line">    <span class="comment">/*  如果你想要遇见数字就停止，可以这样使用  */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^0-9]"</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);</span><br><span class="line">    <span class="comment">/*  怎么样，是不是有点正则表达式的范儿了  */</span></span><br><span class="line">    <span class="comment">/*  我们都知道，scanf函数无法读取含空白符的字串，而我们使用扫描集就可以解决这个问题  */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^\n]"</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);</span><br><span class="line">    <span class="comment">/*  将一行输入保存到s中，包括空白和制表符  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很有趣啊<code>^o^</code></p><h4 id="转换说明-n"><a href="#转换说明-n" class="headerlink" title="转换说明%n"></a>转换说明<code>%n</code></h4><blockquote><ul><li>它不读取输入，需要一个<strong>int *</strong> 类型的参数，这个整数 <strong><em>记录了scanf函数从输入流中读取的字符总数。</em></strong></li><li><strong><em>执行一个%n不会增加scanf函数匹配并赋值的输入项个数</em></strong>，即它的返回值不会增加。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%n"</span>, s, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n);</span><br><span class="line">    <span class="comment">/*  如果我们输入hello，则输出结果为:5  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>我们的重点主要在于 <strong><em>参数的处理</em></strong>，所以，minscanf函数只处理格式字符串和参数，格式转换则通过调用scanf函数实现。</p><p>在此之前，我们先说明一下<strong>stdarg.h</strong>中包含的一组宏定义，它们对 <strong><em>如何遍历可变参数表</em></strong> 作了定义。该头文件的实现因不同的机器而不同，但提供的接口是一致的。</p><div class="table-container"><table><thead><tr><th>宏</th><th>说明</th></tr></thead><tbody><tr><td>va_list</td><td>用于声明一个变量，该变量将依次引用各无名参数。</td></tr><tr><td>va_start</td><td>将ap初始化为指向第一个无名参数的指针。在使用ap之前，该宏必须被调用一次。参数表必须至少包含一个有名参数，va_start将最后一个有名参数作为起点。</td></tr><tr><td>va_arg</td><td>每次调用va_arg，该函数都将返回一个参数，并将ap指向下一个参数。</td></tr><tr><td>va_end</td><td>必须在函数返回之前调用以作一些必要的清理工作。</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  minscanf函数：带有可变参数表的简化的scanf函数  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minscanf</span><span class="params">(<span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;    <span class="comment">/*  声明一个变量ap，该变量将依次指向每个无名参数  */</span></span><br><span class="line">    <span class="keyword">char</span> *p, *sval;</span><br><span class="line">    <span class="keyword">char</span> format[FORMAT];</span><br><span class="line">    <span class="keyword">int</span> i, *ival;</span><br><span class="line">    <span class="keyword">unsigned</span> *uval;</span><br><span class="line">    <span class="keyword">double</span> *dval;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    va_start(ap, fmt);    <span class="comment">/*  将ap指向第一个无名参数  */</span></span><br><span class="line">    <span class="keyword">for</span> (p = fmt; *p != <span class="string">'\0'</span>; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p != <span class="string">'%'</span>) &#123;</span><br><span class="line">            format[i++] = *p;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        format[i++] = <span class="string">'%'</span>;</span><br><span class="line">        <span class="keyword">while</span> (*(p + <span class="number">1</span>) &amp;&amp; !<span class="built_in">isalpha</span>(*(p + <span class="number">1</span>)))    <span class="comment">/*  保存%后的可选字符  */</span></span><br><span class="line">            format[i++] = *++p;</span><br><span class="line">        format[i++] = *++p;    <span class="comment">/*  保存转换字符  */</span></span><br><span class="line">        format[i] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'i'</span>:  </span><br><span class="line">            ival = va_arg(ap, <span class="keyword">int</span> *);</span><br><span class="line">            <span class="built_in">scanf</span>(format, ival);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'x'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">            uval = va_arg(ap, <span class="keyword">unsigned</span> *);</span><br><span class="line">            <span class="built_in">scanf</span>(format, uval);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">            dval = va_arg(ap, <span class="keyword">double</span> *);</span><br><span class="line">            <span class="built_in">scanf</span>(format, dval);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">            sval = va_arg(ap, <span class="keyword">char</span> *);</span><br><span class="line">            <span class="built_in">scanf</span>(format, sval);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br>[C程序设计语言][K&amp;R]</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本说明&quot;&gt;&lt;a href=&quot;#基本说明&quot; class=&quot;headerlink&quot; title=&quot;基本说明&quot;&gt;&lt;/a&gt;基本说明&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;函数原型&lt;/em&gt;&lt;/strong&gt;： &lt;code&gt;int scanf(char *fmt, ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;参数说明&lt;/em&gt;&lt;/strong&gt;：它的第一个参数fmt是格式字符串，包含普通字符和转换说明；第二个参数是可变长参数表，它的参数必须是指针，这是c语言 &lt;strong&gt;&lt;em&gt;&lt;font color=&quot;red&quot;&gt;传值调用语义所要求的&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;  。它的返回值是 &lt;strong&gt;&lt;em&gt;&lt;font color=&quot;red&quot;&gt;成功匹配并赋值的输入项个数。&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt; 如果到达文件尾，它返回EOF。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>编写一个程序，删除C语言程序中的所有注释</title>
    <link href="https://yaoer.me/2018/10/25/rcomment/"/>
    <id>https://yaoer.me/2018/10/25/rcomment/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2018-10-25T05:07:04.861Z</updated>
    
    <content type="html"><![CDATA[<p>这是[k&amp;r]第一章也就是导言后的一道习题，原题是这样的：</p><blockquote><p>编写一个程序，删除C语言程序中所有的注释语句。要正确处理带引号的字符与字符常量。在C语言中，注释不允许嵌套。</p></blockquote><a id="more"></a><p>我们简单分析如下：</p><ul><li><p>对于引号内的字符，我们原样输出即可，不过要注意其中 <strong><em>出现转义字符</em></strong> 时的情况。</p></li><li><p>对于<code>/* ... */</code>这样的注释处理起来是比较简单的，我们只需搜寻到配对的<code>/*</code>和<code>*/</code>，然后跳过它们中间的字符即可。</p></li><li><p>而对于<code>//</code>，则稍微有点麻烦。因为<code>//</code>虽然一般用作单行注释，但却可以用<code>\</code>连接为多行注释。</p></li></ul><p>那么什么样的<code>\</code>出现时应该被当作连接注释行呢？<br>答案很简单，<font color="red">即<code>\</code>之后直到<code>\n</code>全是空白符。</font>根据这个规则，我们可以很容易地处理<code>//</code>注释中<code>\</code>连接注释行的情况。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  删除c程序中的注释，我们假设输入的都是合法的c程序  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'/'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((d = getchar()) == <span class="string">'*'</span>)    </span><br><span class="line">                in_dcomment();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (d == <span class="string">'/'</span>)</span><br><span class="line">                in_scomment();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">putchar</span>(c);</span><br><span class="line">                <span class="built_in">putchar</span>(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'\''</span> || c == <span class="string">'\"'</span>)</span><br><span class="line">            echo_quote(c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">putchar</span>(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主函数负责接收字符流，并对之进行判断，然后交由各函数进行处理。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  in_scomment函数：处理单行注释  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_scomment</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != <span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'\\'</span>)   <span class="comment">/* 处理//注释，或者//用\连接为多行注释的情况  */</span></span><br><span class="line">            <span class="keyword">while</span> ((c = getchar()) != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isspace</span>(c)) &#123;</span><br><span class="line">                ungetc(c, <span class="built_in">stdin</span>);   <span class="comment">/*  压回多读入的字符，可能是\  */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当程序遇见<code>\</code>字符时，我们继续向后读取，如果直到遇见<code>\n</code>程序遇见的都是空白符，那就说明<code>\</code>在这里表示连接注释行了，即下一行也是注释行。</p><p>而这里有个细微的地方需要注意，<strong><em>在这种情况下，if中的while语句会抛弃读到的<code>\n</code>，当返回到最外层while语句时，它会紧接着从下一行重新读取，这样就跳过了当前行，并且把下一行也当作注释行了</em></strong>。<br>一旦<code>\</code>之后出现了非空白符，情况就有所不同了，<strong><em>这说明程序需要接着对这一行进行处理，我们压回多读入的字符，因为它可能是<code>\</code>，如果不压回就会出现问题。</em></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fjlasjl \\</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><blockquote><p>如果不压回多读入的<code>\</code>字符的话，程序将不能删除return 0;但它本来是需要删除的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  in_dcomment函数：处理多行注释  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_dcomment</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    c = getchar();</span><br><span class="line">    d = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c != <span class="string">'*'</span> || d != <span class="string">'/'</span>) &#123;  </span><br><span class="line">        c = d;</span><br><span class="line">        d = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对多行注释的处理只需找到与<code>/*</code>匹配的<code>*/</code>，然后跳过其中的内容即可。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  echo_quote函数：原样输出引号内的字符  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_quote</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(c);</span><br><span class="line">    <span class="keyword">while</span> ((d = getchar()) != c) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(d);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="string">'\\'</span>)            <span class="comment">/*  正确处理转义字符  */</span></span><br><span class="line">            <span class="built_in">putchar</span>(getchar());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>引号内如果出现了<code>\</code>字符，程序就要不加判断的输出它之后的一个字符，不然如果是<code>\&quot;</code>这种情况，就会使程序产生错误的判断，因为此时的<code>&quot;</code>只是一个普通字符，并不是字符串的结束字符。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是[k&amp;amp;r]第一章也就是导言后的一道习题，原题是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编写一个程序，删除C语言程序中所有的注释语句。要正确处理带引号的字符与字符常量。在C语言中，注释不允许嵌套。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>约瑟夫环问题详解</title>
    <link href="https://yaoer.me/2018/10/25/joseph/"/>
    <id>https://yaoer.me/2018/10/25/joseph/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2018-10-25T01:35:28.445Z</updated>
    
    <content type="html"><![CDATA[<p>我们先看一下对该问题的描述：</p><blockquote><p>已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。</p></blockquote><a id="more"></a><p>解决该问题通常有两种方法：</p><blockquote><ul><li><font color="red">模拟法</font>（模拟整个游戏的运行过程）<ul><li><strong><em>循环链表</em></strong></li><li><strong><em>数组</em></strong></li></ul></li><li><font color="red">数学公式法</font>（直接通过公式推导得出结果，不关心具体过程）</li></ul></blockquote><p>谈不上哪种更简单，只在于思考问题、解决问题的方式不同而已。</p><blockquote><ul><li>模拟法的时间复杂度为O(mn)，当n和m很大时，程序将很难在短时间内得到结果。<ul><li>模拟法的一个优点是：程序的设计思路很清晰。</li></ul></li><li>数学公式法的时间复杂度为O(n)。<ul><li>数学方法虽然使最终的程序编写起来很简单，但前提是，你得有足够强的抽象思维能力，能够得出最终的公式。</li></ul></li></ul></blockquote><p>下面我们给出以上各种方法的实现：</p><hr><h3 id="模拟法"><a href="#模拟法" class="headerlink" title="模拟法"></a>模拟法</h3><h4 id="循环链表模拟"><a href="#循环链表模拟" class="headerlink" title="循环链表模拟"></a>循环链表模拟</h4><blockquote><p>确切说来，我们具体使用的是单向循环链表。我们从1，2，3，…n给每个人编号。一旦他出列，我们就将他从链表中删去，直到剩下最后一个人，即为获胜者。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> number;     <span class="comment">/*  编号  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意的是删除操作。我们都知道，每个节点都有一个next指针指向它，为了将删除所有位置的节点看作一种通用的情况，我们需要一个指向next域的指针，即一个二级指针。而且在删除过程中，要注意保证链表不断裂。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *head, **np, *tmp;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"></span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((head = creat_cll(head, n)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">/*  初始化链表  */</span></span><br><span class="line">    <span class="keyword">for</span> (np = &amp;head-&gt;next; *np != head; np = &amp;(*np)-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> ((*np)-&gt;number == k)    <span class="comment">/*  找到开始报数的人  */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((*np)-&gt;next != *np) &#123;    <span class="comment">/*  剩下最后一个节点，循环终止  */</span></span><br><span class="line">        <span class="keyword">if</span> (k++ == m) &#123;     <span class="comment">/*  删除应该出列的人  */</span></span><br><span class="line">            tmp = (*np)-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(*np);</span><br><span class="line">            *np = tmp;</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            np = &amp;(*np)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (*np)-&gt;number);   <span class="comment">/*  打印出获胜者  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面的操作类似于单链表的创建，只是最后我们需要把链表的首尾连接起来而已。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  creat_cll函数：创建一个单向循环链表，并初始化  */</span></span><br><span class="line"><span class="function">Node *<span class="title">creat_cll</span><span class="params">(Node *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *<span class="keyword">new</span>, *pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pre = <span class="keyword">new</span> = head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;number = n;</span><br><span class="line">    <span class="keyword">while</span> (--n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = pre;</span><br><span class="line">        pre = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;number = n;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = <span class="keyword">new</span>;    <span class="comment">/*  连接链表的首尾  */</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环链表还有一种方法，就是采用惰性删除</p><blockquote><p>意思就是我们并不真正地删除链表节点，而只是将它标记为已删除状态。因为我们的编号都是大于0的数，所以一旦某个人出列，我们只需将他的number置为0即可。</p></blockquote><p>具体过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *head, *p;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"></span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((head = creat_cll(head, n)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = head-&gt;next; p != head; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;number == k)    <span class="comment">/*  找到开始报数的人  */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k++ == m) &#123;</span><br><span class="line">            p-&gt;number = <span class="number">0</span>;</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;    <span class="comment">/*  每次遍历链表的时候，需要跳过那些已出列的节点，即number域为0的节点  */</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!p-&gt;number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;number);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们并没有销毁链表，你可以自行加上该操作。</p><hr><h4 id="数组模拟"><a href="#数组模拟" class="headerlink" title="数组模拟"></a>数组模拟</h4><blockquote><p>数组模拟方法的难点在于我们要循环使用一个线性数组，其实稍微认真思考一下，也不是很难。每当遍历到数组末尾的时候，我们就从头重新开始遍历，一旦某个人出列，就将该处的值置为0，直到剩下最后一个人。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p, *q, </span><br><span class="line">    <span class="keyword">char</span> *eq;    <span class="comment">/*  指向数组末尾  */</span></span><br><span class="line">    <span class="keyword">int</span> n, m, k, i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">if</span> ((q = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">/*  为使用的数组分配内存空间  */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        q[i] = i + <span class="number">1</span>;    <span class="comment">/*  初始化数组  */</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    eq = q + n;</span><br><span class="line">    p = q + k - <span class="number">1</span>;     <span class="comment">/*  指向开始报数的人  */</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i++ == m) &#123;</span><br><span class="line">            *p = <span class="number">0</span>;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (++p &gt;= eq)    <span class="comment">/*  到达数组末尾后，就从头重新开始遍历  */</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!*p);    <span class="comment">/*  跳过已出列的人  */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数学公式法"><a href="#数学公式法" class="headerlink" title="数学公式法"></a>数学公式法</h3><p>利用下面这个递推公式，我们就能得到我们想要的结果。</p><script type="math/tex; mode=display">f(N,M)=(f(N-1,M)+M)modN</script><p>$f(N, M)$表示：N个人报数，杀掉报M的那个人，最终胜利者的编号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n;    <span class="comment">/* 总人数 */</span></span><br><span class="line">    <span class="keyword">int</span> m;    <span class="comment">/* 数到m出列 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        p = (p + m) % i;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"winner is %d\n"</span>, p + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们先看一下对该问题的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下的贪吃蛇小游戏</title>
    <link href="https://yaoer.me/2018/10/25/snake/"/>
    <id>https://yaoer.me/2018/10/25/snake/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2018-10-25T05:27:34.692Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主要设计思路"><a href="#主要设计思路" class="headerlink" title="主要设计思路"></a>主要设计思路</h3><blockquote><ul><li>主要数据结构：单链表</li><li>蛇的移动：每次在蛇头添加2个节点，在蛇尾删除2个节点</li><li>蛇的转向：通过一组方向坐标与蛇的位置坐标的运算来实现转向</li><li>蛇吃食物：只在蛇头添加2个节点，而不必在蛇尾删除2个节点</li><li>蛇的死亡：撞上边界或自身</li></ul></blockquote><a id="more"></a><p>然后给出实现中的一点说明：</p><blockquote><ul><li>之所以每次操作2个节点，是因为我所绘制的游戏界面比较大，这样能使游戏效果更明显点</li><li>而且为了当蛇身比较长的时候，对蛇身的折叠缠绕能够明显的区分开，而不是混成一团，我们让蛇每次移动2行或2列</li><li>还有一个需要注意的点：当你给普通字符着色后，它所对应的一个整形值就不再是原来的值了，它会在原来的基础上附加上颜色属性。所以不同颜色的相同字符其实是不同的，不能一概视之</li></ul></blockquote><p>游戏的核心逻辑：</p><blockquote><p><strong><em><font color="red">正常情况下，程序一直处于监听键盘的状态，但一旦有信号中断(这里是超时)产生，就转而去执行display_snake函数；执行完毕后，又处于监听键盘的状态… 直至程序运行结束。</font></em></strong>(这里用到了一点简单的signal方面的知识)。这个机制应该是整个程序设计的难点了，我也是在参考了许多博客，再加上一段时间的思考之后，才想明白的。</p></blockquote><p>还有一点就是，你得确保你的电脑上有curses库，绝大多数unix系统应该会自带curses库，如果没有的话，那么你得自行安装，安装方法很简单，网上也有很多，这里就不多说了。</p><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY  150    <span class="comment">/*  设置延时  */</span>                                                                                                            </span></span><br><span class="line"><span class="comment">/*  蛇的活动地图的大小  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW    (LINES - 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COL    (COLS - 24) </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">snake</span> &#123;</span>     <span class="comment">/*  蛇身节点  */</span></span><br><span class="line">    <span class="keyword">int</span> sx;       <span class="comment">/*  行坐标  */</span></span><br><span class="line">    <span class="keyword">int</span> sy;       <span class="comment">/*  列坐标  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snake</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Snake;</span><br></pre></td></tr></table></figure><blockquote><p>主函数很简单。<code>(^_^)a</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Snake *head, *tail;   <span class="comment">/*  蛇头、蛇尾  */</span></span><br><span class="line"><span class="keyword">int</span> dx, dy;           <span class="comment">/*  一组方向坐标  */</span></span><br><span class="line"><span class="keyword">int</span> score;            <span class="comment">/*  得分  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    signal(SIGALRM, display_snake);</span><br><span class="line">    get_keyboard();     <span class="comment">/*  监听键盘  */</span></span><br><span class="line">    endwin();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  init函数：游戏初始化  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initscr();   <span class="comment">/*  初始化curses  */</span></span><br><span class="line">    start_color();  <span class="comment">/*  初始化颜色表  */</span></span><br><span class="line">    set_color();    <span class="comment">/*  设置颜色  */</span></span><br><span class="line">    box(stdscr, ACS_VLINE, ACS_HLINE);   <span class="comment">/*  绘制一个同物理终端大小相同的窗口  */</span></span><br><span class="line">    noecho();    <span class="comment">/*  关闭键入字符的回显  */</span></span><br><span class="line">    cbreak();    <span class="comment">/*  字符一键入，直接传递给程序  */</span></span><br><span class="line">    curs_set(<span class="number">0</span>);    <span class="comment">/*  隐藏光标  */</span></span><br><span class="line">    keypad(stdscr, <span class="literal">true</span>);    <span class="comment">/*  开启逻辑键  */</span></span><br><span class="line">    draw_initscr();</span><br><span class="line">    draw_map();</span><br><span class="line">    creat_snake();</span><br><span class="line">    creat_food();</span><br><span class="line">    display_score();</span><br><span class="line">    refresh();   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  display_snake函数：游戏的主要控制逻辑  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_snake</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_crash())</span><br><span class="line">        over();</span><br><span class="line">    <span class="keyword">if</span> (is_eat_food()) &#123;</span><br><span class="line">        add_snake();</span><br><span class="line">        creat_food();</span><br><span class="line">        display_score();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        add_snake();</span><br><span class="line">        del_snake();</span><br><span class="line">    &#125;</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  over函数：游戏结束  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">over</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    draw_overscr();</span><br><span class="line">    endwin();    <span class="comment">/*  结束调用curses  */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面是与蛇的移动有关的代码，也是游戏的核心部分代码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  creat_snake函数：初始化蛇身  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_snake</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(head = tail = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Snake)));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    srand(clock());   <span class="comment">/*  以当前挂钟时间作随机种子数  */</span></span><br><span class="line">    <span class="keyword">while</span> ((head-&gt;sx = rand() % (ROW - <span class="number">3</span>) + <span class="number">3</span>) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">while</span> ((head-&gt;sy = rand() % (COL - <span class="number">4</span>) + <span class="number">4</span>) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">    mvaddch(head-&gt;sx, head-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  creat_food函数：初始化食物  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_food</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    srand(clock());</span><br><span class="line">    <span class="keyword">while</span> ((i = rand() % (ROW - <span class="number">3</span>) + <span class="number">3</span>) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">while</span> ((j = rand() % (COL - <span class="number">4</span>) + <span class="number">4</span>) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    move(i, j);</span><br><span class="line">    <span class="keyword">if</span> (inch() == <span class="number">288</span>)    <span class="comment">/*  食物不能覆盖蛇身  */</span></span><br><span class="line">        creat_food();</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">2</span>));</span><br><span class="line">    addch(<span class="string">' '</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  add_snake函数：在蛇头增加2个节点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_snake</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Snake *p, *q;</span><br><span class="line"></span><br><span class="line">    assert(p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Snake)));</span><br><span class="line">    assert(q = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Snake)));</span><br><span class="line">    head-&gt;next = p;</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">    p-&gt;sx = head-&gt;sx + dx;</span><br><span class="line">    p-&gt;sy = head-&gt;sy + dy;</span><br><span class="line">    mvaddch(p-&gt;sx, p-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    q-&gt;sx = p-&gt;sx + dx;</span><br><span class="line">    q-&gt;sy = p-&gt;sy + dy;</span><br><span class="line">    mvaddch(q-&gt;sx, q-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">    head = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  del_snake函数：在蛇尾删除2个节点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_snake</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Snake *tmp;</span><br><span class="line"></span><br><span class="line">    mvaddch(tail-&gt;sx, tail-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    mvaddch(tail-&gt;next-&gt;sx, tail-&gt;next-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    tmp = tail-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(tail-&gt;next);</span><br><span class="line">    <span class="built_in">free</span>(tail);</span><br><span class="line">    tail = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  is_eat_food函数：判断是否吃到食物  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_eat_food</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inch() == <span class="number">544</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  is_crash函数：判断是否撞到障碍物  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_crash</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    move(head-&gt;sx + <span class="number">2</span> * dx, head-&gt;sy + <span class="number">2</span> * dy);</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;sx &lt;= <span class="number">2</span> || head-&gt;sx &gt;= ROW + <span class="number">1</span>|| </span><br><span class="line">        head-&gt;sy &lt;= <span class="number">3</span> || head-&gt;sy &gt;= COL + <span class="number">1</span>)   <span class="comment">/*  撞到边界  */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (inch() == <span class="number">288</span>)   <span class="comment">/*  撞到自身  */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  get_keyboard函数：监听键盘  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_keyboard</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((c = getch()) != <span class="string">'q'</span>) &#123;   <span class="comment">/*  按q键可以退出游戏  */</span></span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> KEY_UP:</span><br><span class="line">            dx = <span class="number">-1</span>; dy = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KEY_DOWN:</span><br><span class="line">            dx = <span class="number">1</span>; dy = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KEY_LEFT:</span><br><span class="line">            dx = <span class="number">0</span>; dy = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KEY_RIGHT:</span><br><span class="line">            dx = <span class="number">0</span>; dy = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_snake();</span><br><span class="line">        set_ticker(DELAY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  lock_snake函数：防止蛇身反向移动  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_snake</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lx, ly;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dx &amp;&amp; dx + lx == <span class="number">0</span>)</span><br><span class="line">        dx = lx;</span><br><span class="line">    <span class="keyword">if</span> (dy &amp;&amp; dy + ly == <span class="number">0</span>)</span><br><span class="line">        dy = ly;</span><br><span class="line">    lx = dx;</span><br><span class="line">    ly = dy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>游戏界面的绘制就是个细心活喽，大家按自己的喜好绘制就可以了，说实话，这个界面我是尝试了好多好多次，挺无聊的。<code>^o^(逃</code></p><p>注意：这个界面是按我的终端大小绘制的，你应该根据你的终端大小作一点调整。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  draw_initscr函数：绘制游戏开始界面  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_initscr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    attron(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = COLS / <span class="number">2</span> - <span class="number">20</span>; i &lt;= COLS / <span class="number">2</span> + <span class="number">20</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        mvaddch(LINES / <span class="number">2</span> - <span class="number">4</span>, i, <span class="string">'@'</span>);</span><br><span class="line">        mvaddch(LINES / <span class="number">2</span> + <span class="number">6</span>, i, <span class="string">'@'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = LINES / <span class="number">2</span> - <span class="number">3</span>; i &lt;= LINES / <span class="number">2</span> + <span class="number">5</span>; i++) &#123;</span><br><span class="line">        mvaddch(i, COLS / <span class="number">2</span> - <span class="number">22</span>, <span class="string">'@'</span>);</span><br><span class="line">        mvaddch(i, COLS / <span class="number">2</span> + <span class="number">22</span>, <span class="string">'@'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">8</span>, COLS / <span class="number">2</span> - <span class="number">13</span>, <span class="string">"Press any key to continue..."</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> - <span class="number">2</span>, COLS / <span class="number">2</span> - <span class="number">8</span>, <span class="string">"Welcome to snake"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> - <span class="number">1</span>, COLS / <span class="number">2</span> - <span class="number">10</span>, <span class="string">"emmmmmmmmm, however,"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span>, COLS / <span class="number">2</span> - <span class="number">20</span>, <span class="string">"now that you are here, you must be greedy!"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">1</span>, COLS / <span class="number">2</span> - <span class="number">11</span>, <span class="string">"~~o~~o~~o~~o~~o~~o~~o~~"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">2</span>, COLS / <span class="number">2</span> - <span class="number">5</span>, <span class="string">"Game Rules:"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">3</span>, COLS / <span class="number">2</span> - <span class="number">18</span>, <span class="string">"1. use direciton keys to move snake"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">4</span>, COLS / <span class="number">2</span> - <span class="number">18</span>, <span class="string">"2. snake is green space, food is red"</span>);</span><br><span class="line">    getch();</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    refresh();</span><br><span class="line">    clear();   <span class="comment">/*  清屏  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  draw_map函数：绘制游戏地图  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_map</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    attron(COLOR_PAIR(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; COLS - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        mvaddch(<span class="number">2</span>, i, <span class="string">' '</span>);</span><br><span class="line">        mvaddch(LINES - <span class="number">2</span>, i, <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; LINES - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        mvaddch(i, <span class="number">3</span>, <span class="string">' '</span>);</span><br><span class="line">        mvaddch(i, COL + <span class="number">1</span>, <span class="string">' '</span>);</span><br><span class="line">        mvaddch(i, COLS - <span class="number">3</span>, <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">3</span>));</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    mvaddstr(<span class="number">10</span>, <span class="number">132</span>, <span class="string">"Your Score:"</span>);</span><br><span class="line">    mvaddstr(<span class="number">12</span>, <span class="number">130</span>, <span class="string">"^0^ smiling ^0^"</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  draw_overscr函数：绘制结束界面  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_overscr</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    clear();</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = COLS / <span class="number">2</span> - <span class="number">16</span>; i &lt;= COLS / <span class="number">2</span> + <span class="number">16</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        mvaddch(LINES / <span class="number">2</span> - <span class="number">4</span>, i, <span class="string">'@'</span>);</span><br><span class="line">        mvaddch(LINES / <span class="number">2</span> + <span class="number">3</span>, i, <span class="string">'@'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = LINES / <span class="number">2</span> - <span class="number">3</span>; i &lt;= LINES / <span class="number">2</span> + <span class="number">2</span>; i++) &#123;</span><br><span class="line">        mvaddch(i, COLS / <span class="number">2</span> - <span class="number">18</span>, <span class="string">'@'</span>);</span><br><span class="line">        mvaddch(i, COLS / <span class="number">2</span> + <span class="number">18</span>, <span class="string">'@'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">5</span>, COLS / <span class="number">2</span> - <span class="number">13</span>, <span class="string">"Press any key to continue..."</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> - <span class="number">1</span>, COLS / <span class="number">2</span> - <span class="number">13</span>, <span class="string">"I'm sorry, the game is over"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span>, COLS / <span class="number">2</span> - <span class="number">9</span>, <span class="string">"But expect you back"</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    refresh();</span><br><span class="line">    getch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  display_score函数：显示当前得分  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_score</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    move(<span class="number">11</span>, <span class="number">136</span>);</span><br><span class="line">    printw(<span class="string">"%d"</span>, score++);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  set_color函数：设置颜色  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_color</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_pair(<span class="number">1</span>, COLOR_GREEN, COLOR_GREEN);</span><br><span class="line">    init_pair(<span class="number">2</span>, COLOR_RED, COLOR_RED);</span><br><span class="line">    init_pair(<span class="number">3</span>, COLOR_WHITE, COLOR_WHITE);</span><br><span class="line">    init_pair(<span class="number">4</span>, COLOR_YELLOW, COLOR_BLACK);</span><br><span class="line">    init_pair(<span class="number">5</span>, COLOR_RED, COLOR_BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  set_ticker函数：设置间隔计时器(ms)  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_ticker</span><span class="params">(<span class="keyword">int</span> n_msecs)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_timeset</span>;</span>  </span><br><span class="line">    <span class="keyword">long</span> n_sec, n_usecs;  </span><br><span class="line">  </span><br><span class="line">    n_sec = n_msecs / <span class="number">1000</span>;      </span><br><span class="line">    n_usecs = (n_msecs % <span class="number">1000</span>) * <span class="number">1000L</span>;      </span><br><span class="line">    </span><br><span class="line">    new_timeset.it_interval.tv_sec = n_sec;   <span class="comment">/*  设置初始间隔  */</span>  </span><br><span class="line">    new_timeset.it_interval.tv_usec = n_usecs;  </span><br><span class="line"></span><br><span class="line">    new_timeset.it_value.tv_sec = n_sec;      <span class="comment">/*  设置重复间隔  */</span>  </span><br><span class="line">    new_timeset.it_value.tv_usec = n_usecs;  </span><br><span class="line">    <span class="keyword">return</span> setitimer(ITIMER_REAL, &amp;new_timeset, <span class="literal">NULL</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后说明一点：当你编译运行的时候需要链接至curses库哦，在编译命令后加上<code>-lcurses</code>就可以了</p><p>emmm，然后呢，希望大家能多多提出建议<code>^o^</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主要设计思路&quot;&gt;&lt;a href=&quot;#主要设计思路&quot; class=&quot;headerlink&quot; title=&quot;主要设计思路&quot;&gt;&lt;/a&gt;主要设计思路&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;主要数据结构：单链表&lt;/li&gt;
&lt;li&gt;蛇的移动：每次在蛇头添加2个节点，在蛇尾删除2个节点&lt;/li&gt;
&lt;li&gt;蛇的转向：通过一组方向坐标与蛇的位置坐标的运算来实现转向&lt;/li&gt;
&lt;li&gt;蛇吃食物：只在蛇头添加2个节点，而不必在蛇尾删除2个节点&lt;/li&gt;
&lt;li&gt;蛇的死亡：撞上边界或自身&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>堆及其应用</title>
    <link href="https://yaoer.me/2018/10/24/heap/"/>
    <id>https://yaoer.me/2018/10/24/heap/</id>
    <published>2018-10-23T16:00:00.000Z</published>
    <updated>2018-10-24T13:00:30.994Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>(二叉堆)是一个数组，它可以被看成一个近似的完全二叉树</em></strong>。树上的每个节点对应数组中的一个元素，除了最底层外，该树是完全充满的，而且是从左向右填充。下文如果不加限定的话，所提到的堆均指二叉堆。常见的堆还有斐波那契堆等。</p><p><img src="https://github.com/yaomer/pictures/blob/master/array.png?raw=true" alt=""><br><a id="more"></a></p><blockquote><p>数组的每个下标对应堆中的一个节点。而给定一个下标，我们可以很容易得到其父亲和儿子的下标。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉堆可以分为两种形式：<strong><em>最大堆（大根堆）和最小堆（小根堆）</em></strong> 。</p><blockquote><ul><li><strong><em>最大堆</em></strong> 是指除了根节点以外的其他节点i都要满足：<strong>A[parent(i)] &gt;= A[i]</strong>。也就是说某个节点的值至多与其父节点一样大</li><li><strong><em>最小堆</em></strong> 是指除了根节点以外的其他节点i都要满足：<strong>A[parent(i)] &lt;= A[i]</strong></li></ul></blockquote><p>由于最大堆和最小堆非常相似，所以我们下面只讨论一下最大堆。并且为了方便起见，下面给出的C代码中数组下标均从1开始。要做到这一点其实是很容易的，只需为数组多开辟一个元素的空间，然后令下标从1开始，不使用A[0]即可。</p><hr><h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><p>首先我们定义一个全局变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 表示有多少个堆元素存储在该数组中，也就是堆中的元素个数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> heapsize;</span><br></pre></td></tr></table></figure><p>在下面的代码中，我们略去了一些错误检查，比如在实际应用中，你必须保证heapsize的值是有效的，即 <strong><em>heapsize不能大于数组的长度。</em></strong></p><h4 id="维护堆的性质"><a href="#维护堆的性质" class="headerlink" title="维护堆的性质"></a>维护堆的性质</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  max_heap函数：维护最大堆的性质  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> l, r, largest;</span><br><span class="line">    </span><br><span class="line">    l = left(i);</span><br><span class="line">    r = right(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  找出a[i]、a[l]、a[r]中的最大值  */</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= heapsize &amp;&amp; a[l] &gt; a[i])</span><br><span class="line">        largest = l;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        largest = i;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= heapsize &amp;&amp; a[r] &gt; a[largest])</span><br><span class="line">        largest = r;</span><br><span class="line">    <span class="comment">/* 如果a[i]是最大的，那么以该节点为根的子树已满足最大堆的性质，函数结束；</span></span><br><span class="line"><span class="comment">     * 否则，最大元素是其某个孩子节点，我们交换a[i]和a[largest]，从而使a[i]</span></span><br><span class="line"><span class="comment">     * 及其孩子都满足最大堆的性质</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(a, i, largest);</span><br><span class="line">        <span class="comment">/* 当a[largest]成为a[i]之后，以该节点为根的子树可能会违反最大堆的性质</span></span><br><span class="line"><span class="comment">         * 所以要对该子树递归调用max_heap</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        max_heap(a, largest);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  swap函数：交换两个数  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[i]; </span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码中注释的已经非常清楚了， <strong><em><font color="red">我们通过让a[i]在最大堆中“逐级下降“，从而使得以a[i]为根节点的子树重新遵循最大堆的性质。</font></em></strong></p></blockquote><hr><p>下面我们举例说明一下，下图是<strong>max_heap(a, 2)，heapsize = 10</strong>的执行过程：</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap.png?raw=true" alt=""></p><blockquote><p>a[2]违背了最大堆的性质，因为它不大于它的孩子，所以要将它和它的孩子中最大的进行交换，即swap(a[2], a[4])。递归调用max_heap(a, 4, 10)，发现a[4]同样不满足最大堆的性质，所以要swap(a[4], a[9])。再递归调用max_heap(a, 9, 10)，发现以a[9]为根的子树满足最大堆的性质。</p></blockquote><hr><p>维护最小堆的性质与之类似，我们只需 <strong><em>将不满足最小堆性质的节点与其孩子中最小的一个进行交换，然后递归下降即可。直到遇见满足最小堆性质的节点。</em></strong></p><hr><h4 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  build_max_heap函数：构建一个最大堆  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*  a[n / 2]..a[n]中的元素都是树的叶节点，所以</span></span><br><span class="line"><span class="comment">     *  我们对树中的其他节点都调用一次max_heap即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    heapsize = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        max_heap(a, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>构建一个最大堆就是对于以a[n / 2] .. a[n]为根节点的每个子树，使它们分别都满足最大堆的性质，也就是对它们的根节点分别都执行一次max_heap即可。这样整棵树都满足了最大堆的性质，即构建成了一个最大堆</em></strong>。因为a[1] .. a[n / 2]都是树叶，显然满足最大堆的性质。</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap1.png?raw=true" alt=""></p><blockquote><p>如上图所示，要将该数组构建成为一个最大堆，只需对红色区域的节点各执行一次max_heap即可。</p></blockquote><hr><h3 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h3><p>堆主要有两个应用：<strong><em>堆排序</em></strong> 和 <strong><em>优先队列</em></strong>。</p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong><em>堆排序先利用build_max_heap将整个数组构建成为一个最大堆。因为数组中的最大元素总存放在根节点a[1]中，通过把它与a[n]交换，我们能将它放到正确的位置上。然后我们从堆中去掉该节点，可以通过减少heapsize的值来实现。新的根节点可能会违背最大堆的性质，所以我们对该节点执行max_heap以维护最大堆的性质，从而在a[1] .. a[n - 1]上构建出一个新的最大堆</em></strong>。堆排序会不断重复这一过程，直到堆的大小下降为2。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  heap_sort函数：堆排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    build_max_heap(a, n);   <span class="comment">/*  将数组构建为一个最大堆  */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">        swap(a, <span class="number">1</span>, i);    <span class="comment">/*  将最大堆元素与堆中的最后一个元素交换  */</span></span><br><span class="line">        heapsize--;      <span class="comment">/*  从堆中去掉a[i]，即最大堆元素  */</span></span><br><span class="line">        max_heap(a, <span class="number">1</span>);  <span class="comment">/*  每次在剩余节点上构建一个新的最大堆  */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>我们这里举两个例子 <strong>(i = 10 和 i = 9)</strong> 来说明一下排序过程。</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap2.png?raw=true" alt=""></p><p><img src="https://github.com/yaomer/pictures/blob/master/heap3.png?raw=true" alt=""></p><blockquote><p>我们先将a[1]与a[10]交换，然后从堆中去掉a[10]，a[1]并不满足最大堆的性质，所以我们对它调用一次max_heap，沿红色路径进行调整，使之重新满足最大堆的性质。调整后的结果为：</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/heap4.png?raw=true" alt=""></p><p><img src="https://github.com/yaomer/pictures/blob/master/heap5.png?raw=true" alt=""></p><blockquote><p>我们将a[1]与a[9]交换，然后从堆中去掉a[9]，a[1]并不满足最大堆的性质，所以我们对它调用一次max_heap，沿红色路径进行调整，使之重新满足最大堆的性质。调整后的结果为：</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/heap6.png?raw=true" alt=""></p><hr><p>堆排序过程：<br><img src="https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif" alt=""></p><hr><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>和堆一样，优先队列也有两种形式：最大优先队列和最小优先队列。这里我们只讨论最大优先队列的有关操作。显而易见，在这里它就是基于最大堆来实现的。</p><p>最大优先队列的应用有很多，其中有一个就是<strong>作业调度问题</strong>。最大优先队列记录将要执行的各个作业以及它们之间的相对优先级。当一个作业完成或者被中断后，调度器从所有等待的作业中选出具有最高优先级的作业来执行。在任何时候，调度器可以把一个新作业加入到队列中。</p><h5 id="返回最大堆元素"><a href="#返回最大堆元素" class="headerlink" title="返回最大堆元素"></a>返回最大堆元素</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  topheap函数：返回最大堆元素  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topheap</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扩充堆"><a href="#扩充堆" class="headerlink" title="扩充堆"></a>扩充堆</h5><p>扩充堆就是将一个新的元素插入到堆中。具体方法就是：<strong><em>我们先对堆进行扩充，可以通过增加heapsize的值来实现。然后将待插入的元素key放到扩充后的位置上去，即a[heapsize] = key。接下来对于节点key，我们沿树向上进行调整，如果它的值大于它的父节点的值，我们就将它与其父节点进行交换，… 直到它的值不大于它的父节点的值，这时就满足了最大堆的性质，即将key插入到了堆中正确的位置上。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  addheap函数：在堆中插入一个元素key  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addheap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    i = ++heapsize;</span><br><span class="line">    a[i] = key;</span><br><span class="line">    j = parent(i);</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span> &amp;&amp; a[i] &gt; a[j]) &#123;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">        i = j;    <span class="comment">/*  更新i的值  */</span></span><br><span class="line">        j = parent(i);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们要把<strong>15</strong>插入到下列最大堆中</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap2.png?raw=true" alt=""></p><blockquote><p>它的过程如下：即将新插入的节点15沿红色路径向上进行调整，这个过程我们上面已经详细地描述过了。</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/heap7.png?raw=true" alt=""></p><p>最后的结果为：</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap8.png?raw=true" alt=""></p><hr><h5 id="缩减堆"><a href="#缩减堆" class="headerlink" title="缩减堆"></a>缩减堆</h5><p>缩减堆就是去掉堆中的最大元素。具体思想和堆排序的思想很相似。<strong><em>就是把堆的最后一个元素a[heapsize]赋给最大堆元素a[1]，然后缩减堆。对于新的a[1]，调用max_heap使之满足最大堆的性质即可。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  delheap函数：去掉并返回最大堆元素  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delheap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heapsize &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"heap underflow\n"</span>);</span><br><span class="line">    max = a[<span class="number">1</span>];</span><br><span class="line">    a[<span class="number">1</span>] = a[heapsize--];</span><br><span class="line">    <span class="comment">/*  将堆的最后一个元素赋给最大堆元素，然后缩减堆，即去除堆的最后一个元素  */</span></span><br><span class="line">    max_heap(a, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缩减堆的过程可以参照堆排序的过程去理解。</p><hr><p>参考资料：<br>[算法导论][Thomas H.Cormen / Charles E.Leiserson / Ronald L.Rivest / Clifford Stein]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;(二叉堆)是一个数组，它可以被看成一个近似的完全二叉树&lt;/em&gt;&lt;/strong&gt;。树上的每个节点对应数组中的一个元素，除了最底层外，该树是完全充满的，而且是从左向右填充。下文如果不加限定的话，所提到的堆均指二叉堆。常见的堆还有斐波那契堆等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yaomer/pictures/blob/master/array.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数组与指针那点事</title>
    <link href="https://yaoer.me/2018/10/23/arr_pointer/"/>
    <id>https://yaoer.me/2018/10/23/arr_pointer/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-10-24T05:31:15.071Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><p>说起数组名？绝大多数初学者是感到非常疑惑的，甚至哪怕是学习了好几年自以为懂的人，恐怕也不能够说得明明白白、清清楚楚。那么，它到底是个什么东西呢？</p><a id="more"></a><p><strong><em><font color="red">首先，我想先声明一点：数组名绝不是指针，也并不是常量指针。</font></em></strong></p><p>我们先以一个简单的赋值为例，说明一下<code>左值</code>和<code>右值</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y;</span><br><span class="line">这个语句的含义是：把y中的值放入x所代表的地址中去</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>左值</th><th>右值</th></tr></thead><tbody><tr><td>在这个上下文环境里，符号x的含义是x所代表的地址</td><td>在这个上下文环境中，符号y的含义是y所代表的地址中的内容</td></tr><tr><td>在编译时可知，表示存储结果的地方，即内存中的位置</td><td>直到运行时才可知，表示的是一个“值”</td></tr></tbody></table></div><p>这时就出现了一个奇怪的现象：我们都知道，只有变量才可以作为左值，而数组名是不能作为左值的。那么数组名不是变量的话，是什么呢？</p><p>如果我们查看一下对应的汇编代码，结果是显而易见的。我们会发现，汇编代码里并没有出现数组名这个东西，<strong><em>数组名只是一个符号而已，标识数组在内存中的位置</em></strong>。但是在某些情况下，编译器会对它进行隐式的转换。<strong><em><font color="red">或者我们可以像指针类型一样，将数组名理解为一个数据类型——数组类型，表示一段连续的内存空间。</font></em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">a表示：<span class="keyword">int</span> [<span class="number">5</span>]，即可以存储<span class="number">5</span>个整形元素的一段连续的内存空间。</span><br></pre></td></tr></table></figure><p>我们看下面这样一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;b;</span><br><span class="line"></span><br><span class="line">    a = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用clang编译的话，会报如下错误</p><p><code>error: array type &#39;int [2]&#39; is not assignable</code></p><hr><blockquote><ul><li>sizeof(a)，返回整个数组的长度。</li><li>&amp;a，得到一个指向整个数组的指针，即int (*)[]。</li><li>在函数参数中，数组名被转换为一个普通的指针</li><li><font color="red">在除此之外的其他情况下，</font><font color="green">数组名将被隐式转换为一个指向数组首元素的常量指针。</font></li></ul></blockquote><p>有效的指针运算方式有如下几种：</p><blockquote><ul><li>相同类型指针之间的赋值运算。</li><li>指针同整数间的加法或减法运算。</li><li>指向相同数组中元素的两个指针间的减法或比较运算。</li><li>将指针赋为0或指针与0之间的比较运算。</li><li>最后注意一点：(void *类型指针可以与其他类型指针混用）</li></ul></blockquote><hr><h3 id="数组和指针的区别"><a href="#数组和指针的区别" class="headerlink" title="数组和指针的区别"></a>数组和指针的区别</h3><p>我们先看一下这样一组声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> *x;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> y[];</span><br></pre></td></tr></table></figure><p>第一条语句声明x是一个指向int类型的指针；第二条语句声明y是一个int类型的数组，长度尚未确定，<strong><em>其存储在别处定义。</em></strong></p><p>那么，什么是声明，什么是定义呢？</p><div class="table-container"><table><thead><tr><th>声明</th><th>定义</th></tr></thead><tbody><tr><td>可以出现在多个地方</td><td>只能出现在一个地方</td></tr><tr><td>描述对象的类型，用于指代其他地方定义的对象</td><td>确定对象的类型并为之分配内存</td></tr></tbody></table></div><p>两者的主要区别在于：</p><blockquote><ul><li>声明：它所说明的并非自身，而是描述其他地方创建的对象。</li><li>定义：它为对象分配内存。</li></ul></blockquote><p><strong><em>总而言之，定义是声明的一个子集。</em></strong></p><p><strong><em>extern对象声明只是告诉编译器对象的类型和名字，对象的内存分配则在别处进行。</em></strong></p><hr><p>我们再看一个这样的问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file <span class="number">1</span>: <span class="keyword">int</span> logo[<span class="number">100</span>];</span><br><span class="line">file <span class="number">2</span>: <span class="keyword">extern</span> <span class="keyword">int</span> *logo;</span><br></pre></td></tr></table></figure><p>很明显，在file 2中的写法是错误的。正确写法应当是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file <span class="number">2</span>: <span class="keyword">extern</span> <span class="keyword">int</span> logo[]; <span class="keyword">or</span> <span class="keyword">extern</span> <span class="keyword">int</span> logo[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p>可能有人会问：这有什么错误？数组和指针不是可以互换吗？答案是<font color="red">数组下标<strong><em>表达式</em></strong>总是可以改写为指针加偏移量的表达式。</font>而且也确实存在一种数组和指针完全相同的上下文环境，但并不是所有情况下都是如此。</p><p><strong>[k&amp;r]</strong>第二版[99]中有相关的描述：<font color="red">作为函数定义的形式参数，</font><strong>char s[]</strong>和<strong>char *s</strong>是等价的。</p><hr><h3 id="数组和指针分别如何访问的？"><a href="#数组和指针分别如何访问的？" class="headerlink" title="数组和指针分别如何访问的？"></a>数组和指针分别如何访问的？</h3><blockquote><ul><li><font color="red">编译器为每个变量分配一个地址，这个地址在<strong>编译时</strong>可知，</font>而且该变量在运行时一直保存于该地址。<font color="red">相反，存储于变量中的值只有在<strong>运行时</strong>才可知。</font>如果需要用到变量中存储的值，编译器就发出指令从指定地址读入变量值并将它放入寄存器中。</li><li>这里的关键之处在于：<strong><em>如果编译器需要一个地址（可能还需要加上偏移量）来执行某种操作，它就可以直接进行操作，并不需要额外的指令首先取得具体的地址。相反，对于指针，必须在运行是取得它的当前值，然后才能对它进行解引用操作。</em></strong></li></ul></blockquote><h4 id="对数组下标的引用"><a href="#对数组下标的引用" class="headerlink" title="对数组下标的引用"></a>对数组下标的引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = <span class="string">"hello"</span>;</span><br><span class="line">c = s[i];</span><br></pre></td></tr></table></figure><p>假设编译器符号表中有一个地址100</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">取出i的值，将它与100相加</span><br><span class="line">取出地址（100 + i）中的内容</span><br></pre></td></tr></table></figure><p>这就是为什么<strong>extern int logo[100]</strong> 与<strong>extern int logo[]</strong> 等价的原因。这两个声明都提示logo是一个数组，也就是一个内存地址。<strong><em>编译器并不需要知道数组有多长，因为它只产生偏离起始地址的偏移地址</em></strong>（是否会越界访问取决于程序员本身，编译器并不会进行这样的检查）。访问数组中的一个字符，只需简单地将logo的地址加上下标即可，需要的字符就在该地址中。</p><hr><h4 id="对指针的引用"><a href="#对指针的引用" class="headerlink" title="对指针的引用"></a>对指针的引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br><span class="line">c = *p;</span><br></pre></td></tr></table></figure><p>假设编译器符号表中有一个地址1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">取出地址1024中的内容，假设是5076</span><br><span class="line">取出地址5076中的内容，就是&apos;h&apos;</span><br></pre></td></tr></table></figure><hr><h4 id="如果定义为指针，却以数组下标方式引用，会发生什么？"><a href="#如果定义为指针，却以数组下标方式引用，会发生什么？" class="headerlink" title="如果定义为指针，却以数组下标方式引用，会发生什么？"></a>如果定义为指针，却以数组下标方式引用，会发生什么？</h4><p>我们都知道，数组的引用是对内存的直接引用，而指针是对内存执行间接引用的。下面我们来分析一下对一个指针执行直接引用操作，会发生什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br><span class="line">c = p[i];</span><br></pre></td></tr></table></figure><p>假设编译器符号表中有一个p，它的地址为1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">取出地址1024中的内容，假设为5076</span><br><span class="line">取得i的值，并将它与5076相加</span><br><span class="line">取出地址（5076 + i）中的内容</span><br></pre></td></tr></table></figure><p>可见，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>; ... p[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello"</span>; ... a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>这两种情况下，都可以取得字符 <strong>‘e’</strong>，但两者的途径非常不一样。</p><p>当书写了<strong>extern char *p</strong>，然后以 <strong>p[1]</strong> 的方式来引用其中的元素时，其实质是对数组下标的引用和对指针的引用两种访问方式的组合。</p><p>总结一下上面的访问过程：</p><blockquote><ul><li>取得符号表中p的地址，提取存储于此处的指针</li><li>把下标所表示的偏移量与指针的值相加，产生一个偏移地址</li><li>取得该地址中的内容</li></ul></blockquote><p><strong><em>如果把p声明为一个指针，那么不管p原先的定义是指针还是数组，都会按照上面所示的三个步骤进行操作，但只有当p原来定义为指针时这个方法才是正确的。</em></strong></p><hr><h4 id="定义为数组，却以指针的方式引用，会发生什么？"><a href="#定义为数组，却以指针的方式引用，会发生什么？" class="headerlink" title="定义为数组，却以指针的方式引用，会发生什么？"></a>定义为数组，却以指针的方式引用，会发生什么？</h4><p>即下列情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file <span class="number">1</span>: <span class="keyword">char</span> p[<span class="number">10</span>];</span><br><span class="line">file <span class="number">2</span>: <span class="keyword">extern</span> <span class="keyword">char</span> *p;</span><br></pre></td></tr></table></figure><p>当以 <strong>p[i]</strong> 的方式访问数组中的内容时：<strong><em>首先，我们取得符号表中p的地址，提取该地址中的内容，很明显会是一个字符。但按照上面的方法，编译器却会把它当作一个地址，把ascii字符解释为地址显然是驴头不对马嘴的。如果真在程序中这样做的话，很可能会污染程序地址空间中的内容，并在以后出现莫名其妙的错误。</em></strong></p><hr><h3 id="数组和指针在什么情况下是相同的"><a href="#数组和指针在什么情况下是相同的" class="headerlink" title="数组和指针在什么情况下是相同的"></a>数组和指针在什么情况下是相同的</h3><p>在实际应用中，数组和指针可以互换的情况要比两者不可互换的情况更为常见。</p><blockquote><ul><li>数组<ul><li>声明<ul><li>extern，如extern char a[]; 不能改写成指针的形式</li><li>定义，如char a[10]; 不能改写成指针的形式</li><li>函数参数，你可以随自己喜欢，选择数组或指针形式</li></ul></li><li>在表达式中使用<ul><li>如c = a[i]; 你可以随自己喜欢，选择数组或指针形式</li></ul></li></ul></li></ul></blockquote><p><strong><em>所有作为函数参数的数组名总是可以通过编译器转换为指针。在其他情况下，数组的声明就是数组，指针的声明就是指针，两者不能混淆。但在使用数组时，两者是可以互换的。</em></strong></p><hr><h3 id="三个规则"><a href="#三个规则" class="headerlink" title="三个规则"></a>三个规则</h3><h4 id="在表达式中，对数组的引用总是可以改写为对指针的引用"><a href="#在表达式中，对数组的引用总是可以改写为对指针的引用" class="headerlink" title="在表达式中，对数组的引用总是可以改写为对指针的引用"></a>在表达式中，对数组的引用总是可以改写为对指针的引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], *p, i = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>我们可以通过以下任何一种方式访问a[i]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = a; p[i];</span><br><span class="line">p = a; *(p + i);</span><br><span class="line">p = a + i; *p;</span><br></pre></td></tr></table></figure><p>事实上，可以采用的方法更多。对数组的引用a[i]在编译时总是被编译器改写为*(a + i)的形式。C标准要求编译器必须具有这个概念性的行为。也许遵循这个规则的捷径就是记住<strong><em><font color="red">[] 表示一个取下标运算符，就像 + 表示加法运算符一样。</font></em></strong></p><p>取下标运算符取一个整数和一个指向T类型的指针，所产生的结果类型是T，一个在表达式中的数组名就变成了一个指针（除过本文开始描述的几种特殊情况）。你只要记住：在表达式中，指针和数组是可以互换的，因为它们在编译器中的最终形式都是指针，而且都可以进行取下标操作。<strong><em>就像加法一样，取下标操作符的操作数是可以互换的，</em></strong>即<font color="red">a[5] 和 5[a] 这两种情况下都是正确的。</font>第二种情况除了能把新手搞晕以外，实在没什么实际意义。</p><blockquote><p>编译器自动把下标值的步长调整为数组元素的大小，在对地址进行加法操作之前，编译器会负责计算每次增加的步长，这也就是指针之所以有类型限制的原因所在。</p></blockquote><hr><h4 id="C语言把数组下标作为指针的偏移量"><a href="#C语言把数组下标作为指针的偏移量" class="headerlink" title="C语言把数组下标作为指针的偏移量"></a>C语言把数组下标作为指针的偏移量</h4><p><font color="red">在通常情况下，使用指针比使用数组”更有效率“这个说法是错误的。</font>现代的编译器常常会对代码进行优化，两种访问方式所产生的代码不具有显著的差别。但不管怎样，数组下标是定义在指针的基础上的，所以编译器常常将它转换为更有效率的指针表达式形式。</p><p><strong><em>C语言把数组下标改写成指针加偏移量的形式的根本原因是：<font color="red">指针和偏移量是底层硬件所使用的基本模型。</font></em></strong></p><hr><h4 id="作为函数参数的数组名等同于指针"><a href="#作为函数参数的数组名等同于指针" class="headerlink" title="作为函数参数的数组名等同于指针"></a>作为函数参数的数组名等同于指针</h4><p>我们首先解释两个术语：</p><blockquote><ul><li>实参：在实际调用一个函数时传递给它的值</li><li>形参：它是一个变量，在函数定义或函数声明中定义</li></ul></blockquote><p>当用一个数组名作为参数时，由于效率原因，编译器只向该函数传递数组的地址，而不是整个数组的拷贝。</p><hr><h3 id="数组形参是如何被引用的？"><a href="#数组形参是如何被引用的？" class="headerlink" title="数组形参是如何被引用的？"></a>数组形参是如何被引用的？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun(<span class="keyword">char</span> p[]);</span><br><span class="line">fun(<span class="keyword">char</span> *p);</span><br></pre></td></tr></table></figure><p>假设编译器符号表显示p可以取地址，从堆栈指针偏移一定位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从堆栈指针偏移一定位置的地方找到函数的活动记录（栈桢），取出实参，假设为1024</span><br><span class="line">取得i的值，并与1024相加</span><br><span class="line">取出地址（1024 + i）中的内容</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br>[C专家编程][Peter Van Der Linden]</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组名&quot;&gt;&lt;a href=&quot;#数组名&quot; class=&quot;headerlink&quot; title=&quot;数组名&quot;&gt;&lt;/a&gt;数组名&lt;/h3&gt;&lt;p&gt;说起数组名？绝大多数初学者是感到非常疑惑的，甚至哪怕是学习了好几年自以为懂的人，恐怕也不能够说得明明白白、清清楚楚。那么，它到底是个什么东西呢？&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>简单计算器</title>
    <link href="https://yaoer.me/2018/10/23/calculator/"/>
    <id>https://yaoer.me/2018/10/23/calculator/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-10-24T13:02:59.933Z</updated>
    
    <content type="html"><![CDATA[<p>设计要求：</p><blockquote><p>输入一个只含有+、-、<em>、/、和%运算符的数学表达式，然后计算出其值；并且要能够处理圆括号。<br>例如：2 + 3 </em> (4 - 2)</p></blockquote><a id="more"></a><p>分析过程：</p><blockquote><ul><li>我们都知道后缀表达式是非常符合计算机的计算方式的，因为它不用考虑优先级的问题，只需要从左到右依次计算即可。</li><li>所以我们的整体思路是：<strong><em>先把输入的中缀表达式转换为后缀表达式，然后再计算出它的值。</em></strong></li></ul></blockquote><p>下面是程序的具体流程：</p><blockquote><ul><li>每次调用exp_trans函数读取一行输入，将其中的中缀表达式转换为后缀表达式，并保存在全局数组expr中；而getop函数则每次从expr中读取字符，解析生成的后缀表达式，最后借用stack计算出它的值。</li><li>为了方便计算后缀表达式，我们在解析生成的后缀表达式时对其格式作了一点简单的调整，即在每个运算符或操作数之间都加上了空格。</li><li>还应当注意的是：浮点数不能直接和0进行比较。</li></ul></blockquote><hr><p>计算后缀表达式的算法是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (下一个运算符或操作数不是EOF)</span><br><span class="line">    <span class="keyword">if</span> (是数)</span><br><span class="line">        将该数压入到栈中</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (是运算符)</span><br><span class="line">        弹出所需数目的操作数</span><br><span class="line">    执行运算</span><br><span class="line">        将结果压入到栈中</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (是\n)</span><br><span class="line">        弹出并打印栈顶值</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        出错</span><br></pre></td></tr></table></figure><hr><p>下面给出代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXEXP 200          <span class="comment">/*  允许输入的中缀表达式的最大长度  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXOP  20           <span class="comment">/*  运算符或操作数的最大长度  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER <span class="meta-string">'0'</span>          <span class="comment">/*  标识找到一个数  */</span></span></span><br></pre></td></tr></table></figure><blockquote><p>主函数主要控制表达式的计算，值得一提的是，这里便是switch语句的一个典型应用</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">main.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> expr[MAXEXP];   <span class="comment">/*  存储转换后的后缀表达式  */</span></span><br><span class="line"><span class="keyword">int</span> li = <span class="number">0</span>;         <span class="comment">/*  expr数组的索引  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[MAXOP];    <span class="comment">/*  存储获取的运算符或操作数  */</span></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">double</span> op2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((type = getop(s)) != EOF)</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> NUMBER:</span><br><span class="line">            push(atof(s));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            push(pop() + pop());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">            push(pop() * pop());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            op2 = pop();</span><br><span class="line">            push(pop() - op2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            op2 = pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(op2) &gt; DBL_EPSILON)</span><br><span class="line">                push(pop() / op2);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"error: zero divisor\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">            op2 = pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(op2) &gt; DBL_EPSILON)</span><br><span class="line">                push(<span class="built_in">fmod</span>(pop(), op2));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"error: zero divisor\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t%.8g\n"</span>, pop());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error: unknow command %s\n"</span>, s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后<strong>exp_trans</strong>完成表达式的转换，转换过程也是利用栈来完成的，和最终计算表达式是用的同一个栈。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">expts.c</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  遇见数字，输出；遇见操作符，入栈；遇见比栈顶操作符优先级更低的，弹出栈中比遇见的操作符优先级高的；</span></span><br><span class="line"><span class="comment"> *  遇见')'，弹出栈中'('之后的所有操作符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  exp_trans函数：将中缀表达式转换为后缀表达式   */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exp_trans</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, i;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c) || <span class="built_in">isdigit</span>(c) || c == <span class="string">'.'</span>) &#123;        <span class="comment">/*  原样保存空白符和数字  */</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!isempty()) &#123;        <span class="comment">/*  遇见\n，弹出栈中所有操作符  */</span></span><br><span class="line">                    expr[i++] = pop();</span><br><span class="line">                    expr[i++] = <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            expr[i++] = c;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op_prior(c) || c == <span class="string">')'</span>) &#123;    <span class="comment">/*  是运算符或')'  */</span></span><br><span class="line">            <span class="keyword">if</span> (isempty() &amp;&amp; c != <span class="string">'-'</span>) &#123;</span><br><span class="line">                push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!isempty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (top() == <span class="string">'('</span>) &#123;</span><br><span class="line">                        pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    expr[i++] = pop();</span><br><span class="line">                    expr[i++] = <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;       <span class="comment">/*  判断是负号还是减号  */</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c = getchar())) &#123;</span><br><span class="line">                        expr[i++] = <span class="string">'-'</span>;</span><br><span class="line">                        expr[i++] = c;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ungetc(c, <span class="built_in">stdin</span>);</span><br><span class="line">                        c = <span class="string">'-'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!isempty() &amp;&amp; top() != <span class="string">'('</span> &amp;&amp; op_prior(top()) &gt;= op_prior(c)) &#123;</span><br><span class="line">                    expr[i++] = pop();</span><br><span class="line">                    expr[i++] = <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    expr[i++] = c;</span><br><span class="line">    expr[i] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  op_prior函数：返回对应操作符的优先级   */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_prior</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们每次调用<strong>exp_trans</strong>函数读取一行，然后<strong>getop</strong>函数用于从中解析需要的运算符和操作数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">getop.c</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  getop函数：获取下一个运算符或操作数    */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getop</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (expr[li] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">        exp_trans();    <span class="comment">/* 如果刚开始时未读入或读到expr的末尾，就调用exp_trans函数读入新的一行  */</span></span><br><span class="line">        li = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((s[<span class="number">0</span>] = expr[li]) == <span class="string">' '</span> || expr[li] == <span class="string">'\t'</span>)</span><br><span class="line">        li++;</span><br><span class="line">    s[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(expr[li]) &amp;&amp; !<span class="built_in">islower</span>(expr[li]) &amp;&amp; expr[li] != <span class="string">'.'</span> &amp;&amp; expr[li] != <span class="string">'-'</span>)</span><br><span class="line">        <span class="keyword">return</span> expr[li++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expr[li] == <span class="string">'-'</span>) &#123;      <span class="comment">/*  判断‘-’是减号还是负号  */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(expr[++li]) || expr[li] == <span class="string">'.'</span>)</span><br><span class="line">            *++s = expr[li];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'-'</span>;</span><br><span class="line">    &#125;     <span class="comment">/*  收集数  */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(expr[li]))</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*++s = expr[++li]))</span><br><span class="line">            ;</span><br><span class="line">    <span class="keyword">if</span> (expr[li] == <span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*++s = expr[++li]))</span><br><span class="line">            ;</span><br><span class="line">    *s = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> NUMBER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是栈的实现了，很简单，没什么好说的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val[MAXVAL];    <span class="comment">/*  值栈  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;    <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将c压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull())</span><br><span class="line">        val[++sp] = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出并返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp--];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：只返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isfull函数：判断栈是否已满  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isempty函数：判断栈是否为空  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://github.com/yaomer/pictures/blob/master/v7.png?raw=true" alt=""></p><hr><p>参考资料：<br>[C程序设计语言][K&amp;R]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个只含有+、-、&lt;em&gt;、/、和%运算符的数学表达式，然后计算出其值；并且要能够处理圆括号。&lt;br&gt;例如：2 + 3 &lt;/em&gt; (4 - 2)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>栈的应用之表达式转换</title>
    <link href="https://yaoer.me/2018/10/23/expr/"/>
    <id>https://yaoer.me/2018/10/23/expr/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-11-09T05:35:21.892Z</updated>
    
    <content type="html"><![CDATA[<h3 id="中缀转后缀表达式"><a href="#中缀转后缀表达式" class="headerlink" title="中缀转后缀表达式"></a>中缀转后缀表达式</h3><p>实现的方法很简单：就是用栈来实现。</p><p>具体思路如下：</p><blockquote><ul><li>如果是数，我们就直接输出</li><li>是操作符，我们就弹出栈中比它优先级更高的操作符，然后再将它入栈</li><li>是’ ( ‘，直接入栈</li><li>是 ’ ) ‘ ，我们就弹出栈中 ‘ ( ‘ 之后的所有操作符</li><li>遇见 ‘ - ‘ 时，要判断它是负号还是减号</li><li>遇见 ’ \n ‘ ，弹出栈中所有的操作符</li></ul></blockquote><a id="more"></a><p>为了清晰美观起见，我们在输出的后缀表达式中的每个运算符或操作数之间加上了一个空格</p><p>下面是代码，都有很清晰的注释：</p><blockquote><p>首先是主函数，控制整个转换过程，当然也可以用一个函数来实现，不过这里是为了说明问题，没有必要那样。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  将中缀表达式转换为后缀表达式  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) || c == <span class="string">'.'</span>) &#123;    <span class="comment">/*  是数，就直接输出  */</span></span><br><span class="line">            <span class="built_in">putchar</span>(c);</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c = getchar()) || c == <span class="string">'.'</span>)</span><br><span class="line">                <span class="built_in">putchar</span>(c);</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">            ungetc(c, <span class="built_in">stdin</span>);     <span class="comment">/*  将多读入的字符压回到输入中  */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op_prior(c) || c == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isempty() &amp;&amp; c != <span class="string">'-'</span>)</span><br><span class="line">                push(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;     <span class="comment">/*  遇见')'，弹出栈中'('之后的所有运算符  */</span></span><br><span class="line">                <span class="keyword">while</span> (!isempty() &amp;&amp; top() != <span class="string">'('</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c "</span>, pop());</span><br><span class="line">                <span class="keyword">if</span> (!isempty())</span><br><span class="line">                    pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;     <span class="comment">/*  判断'-'是负号还是减号  */</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c = getchar())) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"-%c"</span>, c);</span><br><span class="line">                        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c = getchar()) || c == <span class="string">'.'</span>)</span><br><span class="line">                            <span class="built_in">putchar</span>(c);</span><br><span class="line">                        <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">                        ungetc(c, <span class="built_in">stdin</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ungetc(c, <span class="built_in">stdin</span>);</span><br><span class="line">                        c = <span class="string">'-'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;     <span class="comment">/*  栈顶运算符的优先级应当低于当前读入的运算符的优先级  */</span></span><br><span class="line">                <span class="keyword">while</span> (!isempty() &amp;&amp; top() != <span class="string">'('</span> &amp;&amp; op_prior(top()) &gt;= op_prior(c))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c "</span>, pop());</span><br><span class="line">                push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;    <span class="comment">/*  遇见换行符时，弹出栈中所有的运算符  */</span></span><br><span class="line">            <span class="keyword">while</span> (!isempty())</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c "</span>, pop());</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于如何返回对应操作符的优先级，我们可以用简单的数字来表示操作符的优先级，如果你想要实现更多的功能，你可以直接在<strong>op_prior</strong>函数中添加更多的操作符。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  op_prior函数：返回对应运算符的优先级  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_prior</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后便是所用到的主要的数据结构——栈了，这里很容易想到的便是用数组来实现堆栈，而非链表。原因也很简单： <strong><em><font color="red">在每一时刻，栈中的操作符数量总不会太多，栈空间用尽的可能性非常小。</font></em></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val[MAXVAL];    <span class="comment">/*  值栈  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;    <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull())</span><br><span class="line">        val[++sp] = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp--];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://github.com/yaomer/pictures/blob/master/v5.png?raw=true" alt=""></p><hr><h3 id="后缀转中缀表达式"><a href="#后缀转中缀表达式" class="headerlink" title="后缀转中缀表达式"></a>后缀转中缀表达式</h3><p>同样是用栈来实现的，有点类似于计算后缀表达式，但具体过程还是有点不同的。实现思路如下：</p><blockquote><ul><li>如果是数，就将它压入栈中</li><li>如果是运算符，就弹出对应数目的操作数，<font color="red">然而在这里我们并不计算该表达式，而是将它整个压入到栈中</font></li><li>我们都知道后缀表达式不存在优先级问题，但中缀表达式是需要考虑优先级的，因此，<strong><em>在转换过程中，我们需要在恰当的地方加上括号来保证运算过程的正确性</em></strong></li><li>对于如何加括号的问题，我是这么想的：例如中缀表达式 <strong>a  *  (b  +  c)</strong> 转换为后缀是 <strong>a  b  c  +  *</strong> ，当我们将 <strong>a  b  c  +  *</strong> 转换回去的时候就需要在  <strong>b  +  c</strong> 外面加上括号。<strong><em>如果当前运算符的优先级比上一个运算符的优先级要高，我们就给栈顶的两个子表达式加上括号。</em></strong></li><li>最后我们弹出栈顶表达式即可</li></ul></blockquote><p>思路大概就是这样，下面我会结合代码详细说明一下。</p><blockquote><p>同样，我们在主函数中控制整个转换过程，转换过程应当很简单。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXEXP 1000           <span class="comment">/*  输入的表达式的最大长度  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXOP  100            <span class="comment">/*  运算符或操作数的最大长度  */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER <span class="meta-string">'0'</span>            <span class="comment">/*  标识找到一个数  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  将后缀表达式转换为中缀表达式  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> lastc;</span><br><span class="line">    <span class="keyword">char</span> s[MAXEXP];      <span class="comment">/*  存储转换后的表达式  */</span></span><br><span class="line">    <span class="keyword">char</span> *op2;</span><br><span class="line"></span><br><span class="line">    lastc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = getop(s)) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (c == NUMBER)     <span class="comment">/*  是数  */</span></span><br><span class="line">            push(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op_prior(c)) &#123;     <span class="comment">/*  是运算符  */</span></span><br><span class="line">            op2 = top();</span><br><span class="line">            pop();</span><br><span class="line">            cat_exp(top(), s, op2, c, lastc);</span><br><span class="line">            push(s);</span><br><span class="line">            lastc = c;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, top());</span><br><span class="line">            pop();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>getop函数主要用于解析输入参数，将它们分解为运算符或操作数，为了后续的处理，我们也做了一些额外的工作，我们用空格将每个运算符或操作数分隔开。当然在处理输入时，它会丢弃多余的空白符，但如果你不加分隔符的话，它会帮你加上的。</li><li>op_prior函数很简单，我们在中缀转后缀表达式的过程中用到过它，这里和那里的是相同的</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  getop函数：从输入中获取下一个运算符或操作数  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getop</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, i;</span><br><span class="line">              </span><br><span class="line">    <span class="keyword">while</span> ((s[<span class="number">0</span>] = c = getchar()) == <span class="string">' '</span> || c == <span class="string">'\t'</span>)</span><br><span class="line">        ;     </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">'.'</span>) &#123;</span><br><span class="line">        s[<span class="number">1</span>] = <span class="string">' '</span>;</span><br><span class="line">        s[<span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;     <span class="comment">/*  收集操作数  */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))       </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getchar()))</span><br><span class="line">            ;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getchar()))</span><br><span class="line">            ;</span><br><span class="line">    s[i] = <span class="string">' '</span>;</span><br><span class="line">    s[++i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (c != EOF)</span><br><span class="line">        ungetc(c, <span class="built_in">stdin</span>);    <span class="comment">/*  将多读入的字符压回到输入中  */</span></span><br><span class="line">    <span class="keyword">return</span> NUMBER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  op_prior函数：返回对应运算符的优先级  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_prior</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码应该是这个程序的难点所在了</p><blockquote><p>cat_exp函数用当前读入的运算符把栈顶的两个子表达式连接起来，如同上面提到的，这里需要重点考虑的是加括号的问题，代码中注释的很详细，应当都能看得懂。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  cat_exp函数：连接两个子表达式  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat_exp</span><span class="params">(<span class="keyword">char</span> *op1, <span class="keyword">char</span> *s, <span class="keyword">char</span> *op2, <span class="keyword">int</span> c, <span class="keyword">int</span> lastc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp[MAXOP];</span><br><span class="line">    <span class="keyword">char</span> op[MAXOP];</span><br><span class="line">    <span class="keyword">char</span> opt[MAXOP];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, s);     <span class="comment">/*  先将已经生成的中缀表达式拷贝到tmp中  */</span></span><br><span class="line">    <span class="keyword">if</span> (lastc &amp;&amp; op_prior(c) &gt; op_prior(lastc)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isop(op1)) &#123;</span><br><span class="line">            cat(op, op1);</span><br><span class="line">            op1 = op;</span><br><span class="line">        &#125;        <span class="comment">/*  在可能需要加括号的地方都加上括号  */</span></span><br><span class="line">        <span class="keyword">if</span> (isop(op2)) &#123;</span><br><span class="line">            cat(opt, op2);</span><br><span class="line">            op2 = opt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     <span class="comment">/*  将新连接好的子表达式加入到已经生成的表达式中，然后拷贝回s中  */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s, op1);</span><br><span class="line">    <span class="built_in">strcat</span>(s, tmp);</span><br><span class="line">    <span class="built_in">strcat</span>(s, op2);</span><br><span class="line">    pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  cat函数：在表达式前后加上括号  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *s++ = <span class="string">'('</span>;</span><br><span class="line">    <span class="keyword">while</span> (*op != <span class="string">'\0'</span>)</span><br><span class="line">        *s++ = *op++;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">' '</span>)</span><br><span class="line">        s--;</span><br><span class="line">    *s++ = <span class="string">')'</span>;</span><br><span class="line">    *s++ = <span class="string">' '</span>;</span><br><span class="line">    *s = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isop函数：判断s中是否有运算符  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isop</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">if</span> (op_prior(*s++))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是栈的实现了，和中缀转后缀不同的是，这里是用指针栈来实现转换过程的，其实也就一普通的堆栈，没什么特别的。但其中也有几点是需要注意的：</p><blockquote><ul><li>我们需要实时为压入栈的表达式分配存储空间</li><li>不要忘记检查内存是否分配成功</li><li>出栈时记得释放内存</li></ul></blockquote><p><strong><em>为了方便起见，我这里用断言以防止使用NULL指针，即内存分配失败的情况。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *val[MAXVAL];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将字符串s压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull()) </span><br><span class="line">        assert((val[++sp] = strdup(s)));</span><br><span class="line">    <span class="keyword">else</span>           <span class="comment">/*  将s保存在某个安全的地方  */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty()) &#123;</span><br><span class="line">        <span class="built_in">free</span>(val[sp]);</span><br><span class="line">        val[sp--] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>运行结果：</p><p><img src="https://github.com/yaomer/pictures/blob/master/v6.png?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;中缀转后缀表达式&quot;&gt;&lt;a href=&quot;#中缀转后缀表达式&quot; class=&quot;headerlink&quot; title=&quot;中缀转后缀表达式&quot;&gt;&lt;/a&gt;中缀转后缀表达式&lt;/h3&gt;&lt;p&gt;实现的方法很简单：就是用栈来实现。&lt;/p&gt;
&lt;p&gt;具体思路如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果是数，我们就直接输出&lt;/li&gt;
&lt;li&gt;是操作符，我们就弹出栈中比它优先级更高的操作符，然后再将它入栈&lt;/li&gt;
&lt;li&gt;是’ ( ‘，直接入栈&lt;/li&gt;
&lt;li&gt;是 ’ ) ‘ ，我们就弹出栈中 ‘ ( ‘ 之后的所有操作符&lt;/li&gt;
&lt;li&gt;遇见 ‘ - ‘ 时，要判断它是负号还是减号&lt;/li&gt;
&lt;li&gt;遇见 ’ \n ‘ ，弹出栈中所有的操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>将Vim打造成一个C/C++IDE</title>
    <link href="https://yaoer.me/2018/10/22/vim-IDE/"/>
    <id>https://yaoer.me/2018/10/22/vim-IDE/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-27T01:46:23.968Z</updated>
    
    <content type="html"><![CDATA[<p>当你不知从哪里听过Vim的鼎鼎大名而信心满满的去安装它后，你打开Vim的界面后是这样的：什么也没有，就是一个黑框框。然后你想尝试打几个字，结果发现终端一直在嘟嘟的响。这时你的心里一定会大失所望，这都是什么啊。<br><a id="more"></a></p><p><img src="https://github.com/yaomer/pictures/blob/master/v2.png?raw=true" alt=""></p><p>但请不要就此放弃，你可以把Vim看作一匹充满野性的烈马，需要你付出许多努力去驯服它，从而让它乖乖地为你服务，成为你的好帮手。</p><p>实际上，Vim最大的特性就是它的<code>可定制性和可扩展性</code>。因此，当你与它初次相遇时，它就是一块未经打磨的璞玉，一柄未经开封的利刃。你需要自己去打磨它，磨亮它。让它成为一把编辑器中的<code>瑞士军刀</code>。真正的无愧于它编辑器之神的称号。</p><p>之后我推荐你去看Vim最好的入门教程，它只需花费你半小时不到的时间，然后就可以进入下面的打造之路了。</p><p><code>$ vimtutor</code></p><hr><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>我们写代码的基本需求就是要有一点语法高亮，最起码不能是那样的丑陋吧，然后可能还要有对应的行号等等这样一些基本的需求，然后我们写代码可能就会好受一些了。</p><p>这些基本配置包括后面提到的所有插件都需要用到一个叫做<code>.vimrc</code>的文件，顾名思义，这就是Vim的配置文件。在Unix/Linux系统中，它一般在家目录下，你可以使用<code>$ ls -a | grep &quot;.vimrc&quot;</code>命令检查一下，如果没有的话，就自己创建一个。</p><p>然后我们加入一些最简单、最基本的配置，Vim的模样就会变得不一样了，最起码是有点颜色了。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">filetype</span> <span class="keyword">on</span>           <span class="comment">" 开启文件类型检测</span></span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="keyword">on</span>.   <span class="comment">" 设置加载对应文件类型的插件              </span></span><br><span class="line"><span class="keyword">colorscheme</span> desert    <span class="comment">" 语法高亮主题</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>             <span class="comment">" 开启语法高亮</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>            <span class="comment">" 显示行号</span></span><br><span class="line"><span class="keyword">set</span> noerrorbells      <span class="comment">" 关闭出错响铃</span></span><br><span class="line"><span class="keyword">set</span> autoindent        <span class="comment">" 自动缩进</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span>           <span class="comment">" 使用C/C++的自动缩进方式</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span>         <span class="comment">" 将tab设置为4个空格</span></span><br><span class="line"><span class="keyword">set</span> expandtab         <span class="comment">" 将tab扩展为空格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>      <span class="comment">" 每一级缩进为4个空格</span></span><br></pre></td></tr></table></figure><p>然后在重新打开你的Vim，你就会感到有所惊喜了。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v1.png?raw=true" alt=""></p><p>当然这些配置只是最基本的，Vim还有许多别的有用的配置，这就要根据你自己的需要去配置了。在本文最后，我会给出我的<code>.vimrc</code>，大家可以略作参考。</p><p>然后我们正式进入主题。</p><hr><h3 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h3><p>在谈下面的内容之前，我们首先需要选择一款插件管理器，随着我们安装插件数量的增多，为了方便我们管理也为了以后更方便地安装新插件，这都是我们必须要做的。</p><p>我极力推荐大家使用<code>Plug</code>，它是一款极简主义的Vim插件管理器，与老旧的<code>Vundle</code>相比，它的最大优点是超高速并行安装。除此之外，它还可以延迟加载插件，从而加快Vim的启动速度，这个我们最后会提到的。</p><p><img src="https://raw.githubusercontent.com/junegunn/i/master/vim-plug/installer.gif" alt=""></p><p>运行如下命令安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>它的用法也很简单。首先在你的vimrc中加入以下两行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">'~/.vim/plugged'</span>)</span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure><p>如果你要安装一个插件，就<code>Plug &#39;插件名&#39;</code>，然后把这行加到那两行中间即可，之后在Vim中运行<code>:PlugInstall</code>即可自动安装。</p><p>因此，以下提到的插件我不再说明安装方法，都是以这种方式安装的。</p><hr><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><h4 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h4><p>Vim本身自带了一些语法高亮主题，这些主题文件一般在<code>/usr/share/vim/vim80/colors/</code>目录下。你可以自己分别尝试下，不过这些高亮都相对来说比较简单，对于函数、运算符之类的都无法高亮。</p><p>这里我推荐两种我非常喜欢的配色，<a href="https://github.com/crusoexia/vim-monokai" target="_blank" rel="noopener">monokai</a>和<a href="https://github.com/altercation/vim-colors-solarized" target="_blank" rel="noopener">solarized</a>。</p><p>我最先使用的是<code>monokai</code>，使用了很长一段时间，自己也折腾了很多，最近突然觉得它看起来有些不太合心意，在网上看到了<code>solarized</code>，可以说是一见钟情吧，它在色彩处理上可以说是非常优秀，而且是适用于各个平台。</p><p>要修改它们也很简单，只需修改不同语法的高亮颜色即可。</p><h4 id="语法高亮增强"><a href="#语法高亮增强" class="headerlink" title="语法高亮增强"></a>语法高亮增强</h4><p><a href="https://github.com/octol/vim-cpp-enhanced-highlight" target="_blank" rel="noopener">vim-cpp-enhanced-highlight</a>提供了对C++语法高亮的增强，比如STL中的容器和类型。除此之外，还可以高亮运算符，只不过需要简单的设置。</p><p>找到<code>c.vim</code>这个文件，取消下面这些行的注释即可。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" Operators</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>\(&lt;&lt;\|&gt;&gt;\|[-+*/%&amp;^|&lt;&gt;!=]\)=<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>&lt;&lt;\|&gt;&gt;\|&amp;&amp;\|||\|++\|--\|-&gt;<span class="comment">"</span></span><br><span class="line">" syn match cOperator"[.!~*&amp;%&lt;&gt;^|=,;?:+-]"</span><br><span class="line"><span class="string">" syn match cOperator"</span>/[^/*=]<span class="comment">"me=e-1</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>/$<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator  "</span>&amp;&amp;\|||<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>[][]<span class="comment">"</span></span><br></pre></td></tr></table></figure><h4 id="彩虹括号"><a href="#彩虹括号" class="headerlink" title="彩虹括号"></a>彩虹括号</h4><p>当代码中出现多级嵌套的时候，<a href="https://github.com/kien/rainbow_parentheses.vim" target="_blank" rel="noopener">rainbow_parentheses.vim</a>这个插件就会很有用。它可以很明显的显示出不同括号内的代码层次。</p><p>这里我上一张我修改过的代码高亮配色的图吧。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v3.png?raw=true" alt=""></p><p>不过这个插件已经很久不维护了，大家也可以看一下这个较新的插件<a href="https://github.com/luochen1990/rainbow" target="_blank" rel="noopener">rainbow</a><br>，它是对旧的插件的改进版本。</p><hr><h3 id="漂亮的状态栏"><a href="#漂亮的状态栏" class="headerlink" title="漂亮的状态栏"></a>漂亮的状态栏</h3><p>作为一名颜值党，暂且不提Vim别的功能，最起码要看来漂亮动人才行吧。那么没有一个好看的状态栏怎么行呢！而<a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener">vim-airline</a>正是这样一款优秀的状态栏插件，现在它基本上已经取代了<a href="https://github.com/powerline/powerline" target="_blank" rel="noopener">powerline</a>。</p><p>它的配色非常多，可以说是只要你想要的，应该都能找到，我这里选出一个我觉得漂亮的吧。</p><p><img src="https://user-images.githubusercontent.com/9622/45275524-52f45c00-b48b-11e8-8b83-a66240b10747.gif" alt=""></p><p>更多的大家自己去看吧。</p><p>还有一个需要顺带下载的插件是它的主题<a href="https://github.com/vim-airline/vim-airline-themes" target="_blank" rel="noopener">vim-airline-themes</a>，我当初就是把它主题下的所有主题都试了一遍，才找到自己喜欢的。<code>^0^</code>希望大家不要像我一样o。</p><p>airline由于要显示一些图形字符，所以它需要使用一些<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">特定的字体</a>。</p><hr><h3 id="自动补全括号"><a href="#自动补全括号" class="headerlink" title="自动补全括号"></a>自动补全括号</h3><p>当我们码代码的时候，如果每次输入一个<code>(</code>之后，稍后还得记得输入另一个配对的<code>)</code>是不是很麻烦，而且有时候还会忘记另一个<code>)</code>。</p><p><a href="https://github.com/jiangmiao/auto-pairs" target="_blank" rel="noopener">auto-pairs</a>插件正好可以胜任这个任务。</p><hr><h3 id="代码自动补全"><a href="#代码自动补全" class="headerlink" title="代码自动补全"></a>代码自动补全</h3><p>代码自动补全首推YCM了，具体的安装配置过程可以参照我的另一篇博客<a href="https://yaoer.me/2018/10/21/YCM/#more">Mac安装配置YCM</a>，在Unix/Linux下过程应该是差不多的。</p><hr><h3 id="函数参数列表补全"><a href="#函数参数列表补全" class="headerlink" title="函数参数列表补全"></a>函数参数列表补全</h3><p>如果你YCM安装成功了，在你体验着它便利的同时，你应该会有另一个棘手的问题：<strong><em>对于函数参数无法补全</em></strong>。</p><p>在补全列表中是可以看到参数列表的，当当你键入<code>(</code>后，参数列表就消失了。对于一些常见的函数，我们可能不依赖于函数参数补全。但对于一个稍显生僻的函数或者参数表特别长的函数，我们显而易见需要参数补全，因为我们可能会忘掉参数或者搞错参数顺序。</p><p><a href="https://github.com/tenfyzhong/CompleteParameter.vim" target="_blank" rel="noopener">CompleteParameter.vim</a>正是这样一个与YCM完美配合的插件。</p><p><img src="https://camo.githubusercontent.com/5ff72790ae3d6bf6c964cf3b59bdc0985268b190/687474703a2f2f7778342e73696e61696d672e636e2f6d773639302f36393437323232336779316668796a76726a68723367323068733061307162792e676966" alt=""></p><p>一旦你键入<code>(</code>后，它会将该函数的参数列表显示出来，和一般IDE的补全是没有什么两样的，填完一个参数后，你可以使用<code>ctr + j</code>跳转到下一个参数，直到填完所有参数，最后跳到<code>)</code>外面。</p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;expr&gt;</span> ( complete_parameter#pre_complete(<span class="string">"()"</span>)</span><br><span class="line"><span class="keyword">smap</span> <span class="symbol">&lt;c-j&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_next_parameter)</span><br><span class="line"><span class="keyword">imap</span> <span class="symbol">&lt;c-j&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_next_parameter)</span><br><span class="line"><span class="keyword">smap</span> <span class="symbol">&lt;c-k&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_previous_parameter)</span><br><span class="line"><span class="keyword">imap</span> <span class="symbol">&lt;c-k&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_previous_parameter)</span><br></pre></td></tr></table></figure><hr><h3 id="跳转到声明或定义处"><a href="#跳转到声明或定义处" class="headerlink" title="跳转到声明或定义处"></a>跳转到声明或定义处</h3><p>这里我们不使用<code>ctags</code>，因为对于C/C++来说，YCM原生支持这些操作，而且使用起来非常方便。</p><p>在你的vimrc中加入下面这一句：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" 跳转到声明或定义处</span></span><br><span class="line"><span class="string">nnoremap &lt;silent&gt;&lt;leader&gt;j :YcmCompleter GoToDefinitionElseDeclaration&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><p>具体的键位映射需要你根据自己的方便设置。</p><hr><h3 id="树形目录"><a href="#树形目录" class="headerlink" title="树形目录"></a>树形目录</h3><p><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">nerdtree</a>插件可以显示树形目录。</p><p><a href="https://github.com/tiagofumo/vim-nerdtree-syntax-highlight" target="_blank" rel="noopener">vim-nerdtree-syntax-highlight</a>插件可以高亮nerdtree显示的文件类型。</p><p><a href="https://github.com/Xuyuanp/nerdtree-git-plugin" target="_blank" rel="noopener">nerdtree-git-plugin</a>插件可以显示git状态。</p><p>这三个插件大家可以一起配套下载使用。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v4.png?raw=true" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" nerdtree</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span>n :NERDTreeToggle<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeFileExtensionHighlightFullName</span>    = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeExactMatchHighlightFullName</span>       = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreePatternMatchHighlightFullName</span>     = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeHighlightFolders</span>                  = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeHighlightFoldersFullName</span>          = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeDirArrowExpandable</span>                = <span class="string">'▷'</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeDirArrowCollapsible</span>               = <span class="string">'▼'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" nerdtree-git-plugin</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeIndicatorMapCustom</span> = &#123;</span><br><span class="line">            \ <span class="string">"Modified"</span>  : <span class="string">"✹"</span>,</span><br><span class="line">            \ <span class="string">"Staged"</span>    : <span class="string">"✚"</span>,</span><br><span class="line">            \ <span class="string">"Untracked"</span> : <span class="string">"✭"</span>,</span><br><span class="line">            \ <span class="string">"Renamed"</span>   : <span class="string">"➜"</span>,</span><br><span class="line">            \ <span class="string">"Unmerged"</span>  : <span class="string">"═"</span>,</span><br><span class="line">            \ <span class="string">"Deleted"</span>   : <span class="string">"✖"</span>,</span><br><span class="line">            \ <span class="string">"Dirty"</span>     : <span class="string">"✗"</span>,</span><br><span class="line">            \ <span class="string">"Clean"</span>     : <span class="string">"✔︎"</span>,</span><br><span class="line">            \ <span class="string">'Ignored'</span>   : <span class="string">'☒'</span>,</span><br><span class="line">            \ <span class="string">"Unknown"</span>   : <span class="string">"?"</span></span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="显示类、方法、变量"><a href="#显示类、方法、变量" class="headerlink" title="显示类、方法、变量"></a>显示类、方法、变量</h3><p><a href="https://github.com/majutsushi/tagbar" target="_blank" rel="noopener">tagbar</a>插件可以让我们把握文件的整体结构。</p><p><img src="https://camo.githubusercontent.com/fc85311154723793776aed28488befdfaab36c42/68747470733a2f2f692e696d6775722e636f6d2f5366394c7332722e706e67" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:tagbar_width</span> = <span class="number">30</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span>t :TagbarToggle<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="快速代码注释"><a href="#快速代码注释" class="headerlink" title="快速代码注释"></a>快速代码注释</h3><p>当我们在debug时，经常需要注释一段可能会出错的代码来查看程序的运行行为，这个时候，<a href="https://github.com/scrooloose/nerdcommenter" target="_blank" rel="noopener">nerdcommenter</a>插件就非常有用，它可以让我们非常方便的注释或者反注释代码段。</p><p>它的简单用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;leader&gt;cc         注释一行</span><br><span class="line">&lt;leader&gt;cu         取消注释</span><br><span class="line">&lt;leader&gt;cm         注释(Visual)选中的一段代码</span><br></pre></td></tr></table></figure><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDSpaceDelims</span>               = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDCompactSexyComs</span>           = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDDefaultAlign</span>              = <span class="string">'left'</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDCommentEmptyLines</span>         = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTrimTrailingWhitespace</span>    = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDToggleCheckAllLines</span>       = <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h3 id="文件模糊搜索"><a href="#文件模糊搜索" class="headerlink" title="文件模糊搜索"></a>文件模糊搜索</h3><p>文件模糊查找在我们日常工作应该经常要用到，与其使用速度较慢的<code>find</code>命令，<a href="https://github.com/Yggdroot/LeaderF" target="_blank" rel="noopener">LeaderF</a>插件可以帮助我们在大型项目中快速定位文件。而且除过模糊查找之外，它还有很多其他功能，我这里就不多说了。</p><p><img src="https://github.com/Yggdroot/Images/raw/master/leaderf/leaderf_1.gif" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> :LeaderfFile<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_WildIgnore</span> = &#123;</span><br><span class="line">            \ <span class="string">'dir'</span>: [<span class="string">'.svn'</span>,<span class="string">'.git'</span>,<span class="string">'.hg'</span>,<span class="string">'.vscode'</span>,<span class="string">'.wine'</span>,<span class="string">'.deepinwine'</span>,<span class="string">'.oh-my-zsh'</span>],</span><br><span class="line">            \ <span class="string">'file'</span>: [<span class="string">'*.sw?'</span>,<span class="string">'~$*'</span>,<span class="string">'*.bak'</span>,<span class="string">'*.exe'</span>,<span class="string">'*.o'</span>,<span class="string">'*.so'</span>,<span class="string">'*.py[co]'</span>]</span><br><span class="line">            \&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_UseCache</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h3 id="更快速高效地移动"><a href="#更快速高效地移动" class="headerlink" title="更快速高效地移动"></a>更快速高效地移动</h3><p>Vim本身已经为我们提供了许多有用的组合键来帮助我们快速高效的移动，但那些大多是小范围的局部移动，而且也并不太准确。</p><p><a href="https://github.com/easymotion/vim-easymotion" target="_blank" rel="noopener">vim-easymotion</a>插件可以帮助我们快速准确的定位，让我们的移动一击即中。</p><p><img src="https://camo.githubusercontent.com/d5f800b9602faaeccc2738c302776a8a11797a0e/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f333739373036322f323033393335392f61386539333864362d383939662d313165332d383738392d3630303235656138333635362e676966" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;Leader&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-prefix)</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:EasyMotion_do_mapping</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">j</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">j</span>)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">k</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">k</span>)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>h <span class="symbol">&lt;Plug&gt;</span>(easymotion-linebackward)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">l</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-lineforward)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>s <span class="symbol">&lt;Plug&gt;</span>(easymotion-s)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">w</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">bd</span>-<span class="keyword">w</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="延迟加载Vim插件"><a href="#延迟加载Vim插件" class="headerlink" title="延迟加载Vim插件"></a>延迟加载Vim插件</h3><p>随着我们安装插件的增多，Vim的启动速度不可避免的会变慢，当达到某个临界点之后，这种略显卡顿的启动就不是我们能接受的了。它会非常影响我们编辑文本的心情。</p><p>当幸运的是，Vim的最新版本提供了延迟加载插件的机制，这可以帮助我们将那些在初打开文件时不用的且较重的插件延迟加载，即打开文件后再加载。这样就能显著提高Vim的启动速度了。</p><p>具体操作如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" 延迟加载YCM</span></span><br><span class="line"><span class="string">Plug 'Valloric/YouCompleteMe', &#123; 'on': [] &#125;             </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 100ms后调用LoadPlug，且只调用一次</span><br><span class="line">call timer_start(100, <span class="string">'LoadPlug'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>! LoadPlug(timer) abort</span><br><span class="line">    call plug<span class="comment">#load('YouCompleteMe')</span></span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你不知从哪里听过Vim的鼎鼎大名而信心满满的去安装它后，你打开Vim的界面后是这样的：什么也没有，就是一个黑框框。然后你想尝试打几个字，结果发现终端一直在嘟嘟的响。这时你的心里一定会大失所望，这都是什么啊。&lt;br&gt;
    
    </summary>
    
      <category term="vim" scheme="https://yaoer.me/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>巧判机器的大小端</title>
    <link href="https://yaoer.me/2018/10/21/endian/"/>
    <id>https://yaoer.me/2018/10/21/endian/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-10-22T15:26:03.947Z</updated>
    
    <content type="html"><![CDATA[<p>大小端的命名来自于《格列佛游记》中一个有关吃鸡蛋先磕鸡蛋的大端还是小端的故事，大家有兴趣的话可以去了解一下。</p><p>那么什么是大端、什么是小端呢？</p><blockquote><ul><li>大端：即高位有效字节在低位地址，低位有效字节在高位地址。</li><li>小端：即高位有效字节在高位地址，低位有效字节在低位地址。</li></ul></blockquote><a id="more"></a><p>我们举个例子来说明一下：<code>char a = 1;</code></p><p>它在内存中的表示如下图：</p><blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/endian.png?raw=true" alt=""></p></blockquote><p>那么如何用C语言来判断自己所使用机器的大小端呢？<br>通常有两种方法，其本质都是依赖于<strong><em>大小端的概念。</em></strong></p><p>一种方法是借助联合的特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125; port;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    port.a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (port.b == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们知道，在联合中 <strong><em>多个成员变量共用一段内存</em></strong>。在执行完<code>port.a = 1</code>后，内存中的情况是这样的：<code>00000000 00000000 00000000 00000001</code>。它到底是如何存放的，我们目前并不清楚。当我们访问<code>port.b</code>时，我们只会访问到位于该段内存中最低地址的那一字节的内容。如果<code>port.b == 1</code>，显然我们访问到的是<code>00000001</code>这一字节的内容，即低位有效字节在低位地址，所以是<code>little-endian</code>模式。<code>big-endian</code>模式同理。</p></blockquote><p>另一种方法就是根据大小端的概念直接判断了，相比于第一种更直接点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endian</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">char</span> *)&amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (endian())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>a是一个<code>int</code>类型的整数，所以<code>&amp;a</code>可以看作一个<code>int *</code>类型的指针。如果对<code>&amp;a</code>进行解引用操作，则编译器会将其解释为：<strong><em>从当前地址开始往后数4个字节，然后取出这4个字节中的内容</em></strong>。如果我们将<code>&amp;a</code>强制类型转换为<code>char *</code>类型后再进行解引用操作，那么编译器就会将其解释为：<strong><em>取出当前地址所在的那个字节中的内容</em></strong>。这个地址一定是之前那4个内存地址中的最低位地址。通过查看该地址中的值是什么我们就能确定该机器的大小端了。</p></blockquote><p>显然，两种方法的本质都是相同的，都是通过<strong><em>查看低位地址中的内容</em></strong>来判断大小端模式的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大小端的命名来自于《格列佛游记》中一个有关吃鸡蛋先磕鸡蛋的大端还是小端的故事，大家有兴趣的话可以去了解一下。&lt;/p&gt;
&lt;p&gt;那么什么是大端、什么是小端呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;大端：即高位有效字节在低位地址，低位有效字节在高位地址。&lt;/li&gt;
&lt;li&gt;小端：即高位有效字节在高位地址，低位有效字节在低位地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="server" scheme="https://yaoer.me/categories/server/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac安装配置YCM</title>
    <link href="https://yaoer.me/2018/10/21/YCM/"/>
    <id>https://yaoer.me/2018/10/21/YCM/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-11-23T15:14:44.849Z</updated>
    
    <content type="html"><![CDATA[<p>YCM的大名在这里就不消多说了。下面我们就来说说如何安装吧。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>YCM算是Vim插件中比较重的了，而且与其他插件不同的是，它是一个带有编译组件的插件。因此也就导致了在安装过程可能会出现各种意想不到的问题。<br><a id="more"></a></p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>在正式安装YCM之前需要安装一些依赖工具。</p><h4 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h4><p>可以说是homebrew使得Mac的软件生态变得完整，因为它是一个非常好用的包管理工具。我们下面提到的一些依赖都可以通过它很方便地安装。</p><p>可以在终端运行以下ruby脚本安装brew:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>它的用法很简单，比如说安装Vim。</p><p><code>$ brew install vim</code></p><p>运行<code>brew uninstall vim</code>即可卸载。</p><h4 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h4><p>确保你的Vim版本是最新的，且要支持py2或py3。Mac系统自带的Vim版本比较老，你最好使用brew安装最新的版本。可以通过以下命令查看：</p><p><code>$ vim --version</code></p><p>如果输出中包含<code>+python或+python3</code>，就说明你的Vim支持py2或py3。</p><p>如果你的Vim不支持python，那么你可能就需要<a href="https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source" target="_blank" rel="noopener">从源码编译安装Vim</a>了，不过别担心，它的过程很简单。</p><h4 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h4><p><code>$ brew install CMake</code></p><h4 id="Command-Line-Tools"><a href="#Command-Line-Tools" class="headerlink" title="Command Line Tools"></a>Command Line Tools</h4><p>如果你需要C-Family语言补全的话，你就需要安装以上命令行工具。它们在你第一次运行clang时自动安装，也可以通过手工安装：</p><p><code>$ xcode-select --install</code></p><h4 id="pythen-dev"><a href="#pythen-dev" class="headerlink" title="pythen-dev"></a>pythen-dev</h4><p>Mac系统已经默认安装。不过这里需要注意的是：</p><blockquote><p><strong><em>你千万不要在私下去安装一个新的python2，不然会导致YCM在安装和编译中使用不同的python2版本，从而会产生冲突。</em></strong></p></blockquote><p>如果你已经使用brew安装了，那么你可能需要卸载它。这或许会使你的问题得到解决。</p><p><code>$ brew uninstall python@2</code></p><h3 id="YCM"><a href="#YCM" class="headerlink" title="YCM"></a>YCM</h3><p>安装YCM这里推荐使用Plug安装，当然你使用Vundle也可以。</p><p>在你的.vimrc中加入以下代码段。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call plug<span class="comment">#begin('~/.vim/plugged')</span></span><br><span class="line">Plug <span class="string">'Valloric/YouCompleteMe'</span></span><br><span class="line">call plug<span class="comment">#end()</span></span><br></pre></td></tr></table></figure><p>然后在Vim中输入<code>:PlugInstall</code>等待自动安装结束即可。这个过程可能会有点久，需要耐心等待。</p><p>如果你不是使用Plug或Vundle安装的，那么你就需要保证YCM安装包的完整性。可以运行下列命令检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>安装成功后，接下来就需要进入编译环节了。编译过程实际上很简单，运行一个脚本就行了。但如果在脚本运行过程中出了点问题，那么你可能就需要完整地一步一步地编译YCM了。</p><hr><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="直接运行安装脚本"><a href="#直接运行安装脚本" class="headerlink" title="直接运行安装脚本"></a>直接运行安装脚本</h3><p>如果你需要C-Family语言补全，则运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.vim/Plug/YouCompleteMe</span><br><span class="line">$ ./install.py --clang-completer</span><br></pre></td></tr></table></figure><p>否则，直接运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.vim/Plug/YouCompleteMe</span><br><span class="line">$ ./install.py</span><br></pre></td></tr></table></figure><p>如果你幸运的编译成功了，那么直接跳转到配置过程中。否则，进入下一步。</p><h3 id="一步一步编译"><a href="#一步一步编译" class="headerlink" title="一步一步编译"></a>一步一步编译</h3><p>如果你和我当初一样失败了，那么可能就需要进行下面这些比较繁琐的安装过程了。</p><h4 id="下载最新版本的libclang"><a href="#下载最新版本的libclang" class="headerlink" title="下载最新版本的libclang"></a>下载最新版本的libclang</h4><p>如果你关心C-Family语言语义支持，完成这一步骤。</p><p>libclang它提供的库用于为这些语言提供YCM语义完成引擎。</p><p>只有在你确定它是3.9或更高版本时才可以使用系统libclang，否则不能。但即使它是，YCM官方也建议尽可能使用<a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener">llvm.org</a>的官方二进制文件。这确保为你的操作系统下载正确的存档文件。</p><h4 id="编译ycm-core"><a href="#编译ycm-core" class="headerlink" title="编译ycm_core"></a>编译ycm_core</h4><p>这个库是YCM用来获得快速补全的C++引擎。</p><p>在这里，我假设你使用Plug安装了YCM。这意味着YCM的顶级目录在<code>~/.vim/Plug/YouCompleteMe</code>。</p><p>我们将创建一个新文件夹，其中将放置构建文件。运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ mkdir ycm_build</span><br><span class="line">$ cd ycm_build</span><br></pre></td></tr></table></figure><p>现在我们需要生成Makefile。如果你不关心C-Family语言的语义支持，就请在ycm_build 目录中运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -G &quot;Unix Makefiles&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</span><br></pre></td></tr></table></figure><p>如果你关心C-Family语言的语义支持，那么CMake的调用就会更复杂些。我们假设你在llvm.org中下载的LLVM + Clang的二进制发行版，你提取的存档文件放到了文件夹<code>~/ycm_temp/llvm_root_dir</code>中。</p><p>然后在<code>ycm_build</code>目录中运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -G &quot;Unix Makefiles&quot; -DPATH_TO_LLVM_ROOT=~/ycm_temp/llvm_root_dir . ~/.vim/Plug/YouCompleteMe/third_party/ycmd/cpp</span><br></pre></td></tr></table></figure><p>现在已经生成了配置文件，使用以下命令编译库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build . --target ycm_core</span><br></pre></td></tr></table></figure><p>至此YCM就已经安装完成了，<code>ycm_build</code>和<code>ycm_temp</code>目录都可以删除了，不影响使用。</p><p>如果你中间还是出现了一些问题，那么请你仔细按照以上过程重新尝试安装。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置过程需要编辑两个文件：<code>vimrc</code>和<code>.ycm_extra_conf.py</code>。</p><p>在你的终端运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo | clang -v -E -x c++ -</span><br></pre></td></tr></table></figure><p>将输出结果中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;...&quot; search starts here:</span><br><span class="line">#include &lt;...&gt; search starts here:</span><br></pre></td></tr></table></figure><p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">End of search list.z</span><br></pre></td></tr></table></figure></p><p>之间的部分添加到<code>.ycm_extra_conf.py</code>中的<code>-isystem</code>后。</p><p>然后将一下代码段加入到你的vimrc中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> g:ycm_server_python_interpreter=<span class="string">'/usr/bin/python'</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_global_ycm_extra_conf = <span class="string">'~/.vim/plugged/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py'</span></span><br><span class="line"><span class="string">" 让vim的补全菜单行为与一般IDE一致</span></span><br><span class="line"><span class="string">set completeopt=longest,menu</span></span><br><span class="line"><span class="string">"</span> 触发(符号)补全时需要键入的字符数</span><br><span class="line"><span class="built_in">let</span> g:ycm_min_num_of_chars_for_completion = 1</span><br><span class="line"><span class="string">" 补全候选项的最小字符数</span></span><br><span class="line"><span class="string">let g:ycm_min_num_identifier_candidate_chars = 0</span></span><br><span class="line"><span class="string">"</span> 关闭诊断显示功能(已经使用了ale进行异步语法检查)</span><br><span class="line"><span class="built_in">let</span> g:ycm_show_diagnostics_ui = 0</span><br><span class="line"><span class="string">" 在字符串和注释中仍会触发补全</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_comments = 1</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_strings = 1</span></span><br><span class="line"><span class="string">"</span> 禁止缓存匹配项，每次重新生成匹配项</span><br><span class="line"><span class="built_in">let</span> g:ycm_cache_omnifunc = 0</span><br><span class="line"><span class="string">" 在用户接受提供的完成字符串后自动关闭窗口</span></span><br><span class="line"><span class="string">let g:ycm_autoclose_preview_window_after_completion = 0</span></span><br><span class="line"><span class="string">"</span> 跳转到声明或定义处</span><br><span class="line">nnoremap &lt;silent&gt;&lt;leader&gt;gj :YcmCompleter GoToDefinitionElseDeclaration&lt;cr&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">" 自动触发语义补全</span></span><br><span class="line"><span class="string">let g:ycm_semantic_triggers =  &#123;</span></span><br><span class="line"><span class="string">            \ 'c,cpp,python,java,go,erlang,perl': ['re!\w&#123;1&#125;'],</span></span><br><span class="line"><span class="string">            \ 'cs,lua,javascript': ['re!\w&#123;1&#125;'],</span></span><br><span class="line"><span class="string">            \ &#125;</span></span><br><span class="line"><span class="string">"</span> 遇到下列文件时才会开启YCM</span><br><span class="line"><span class="built_in">let</span> g:ycm_filetype_whitelist = &#123;</span><br><span class="line">            \ <span class="string">"c"</span>:1,</span><br><span class="line">            \ <span class="string">"cpp"</span>:1,</span><br><span class="line">            \ <span class="string">"python"</span>:1,</span><br><span class="line">            \ <span class="string">"sh"</span>:1,</span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure><p>接下来你就可以享受YCM带来的如丝般柔滑地补全了。</p><hr><p>参考资料：<br><a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="noopener">YCM官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;YCM的大名在这里就不消多说了。下面我们就来说说如何安装吧。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;YCM算是Vim插件中比较重的了，而且与其他插件不同的是，它是一个带有编译组件的插件。因此也就导致了在安装过程可能会出现各种意想不到的问题。&lt;br&gt;
    
    </summary>
    
      <category term="vim" scheme="https://yaoer.me/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="https://yaoer.me/2018/10/20/sll/"/>
    <id>https://yaoer.me/2018/10/20/sll/</id>
    <published>2018-10-19T16:00:00.000Z</published>
    <updated>2018-12-23T13:44:06.868Z</updated>
    
    <content type="html"><![CDATA[<p>由于单链表是链表的一种，所以我们首先来介绍一下链表。</p><p>链表是一种线性表，通常由一连串节点组成，每个节点包含任意的实例数据，和一个或两个用于指向上一个或下一个节点的指针。</p><p>使用链表的优点是：</p><blockquote><ul><li>克服了数组需要预先知道数据大小的缺点</li><li>可以充分利用计算机的内存空间，实现灵活的动态内存管理</li></ul></blockquote><a id="more"></a><p>缺点是：</p><blockquote><ul><li>失去了数组随机读取的优点</li><li>由于增加了节点的指针域，空间开销比较大。</li></ul></blockquote><p>单链表是一种单向链接的链表，对链表的访问只能从表头开始，在表的末尾有一个特殊的结束标记，通常为NULL。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一些结构和变量的声明 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> <span class="title">Link</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Link *head, *tail;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> first;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>单链表的插入通常有头插和尾插两种：</p><blockquote><ul><li>头插：每次在表头插入一个节点</li><li>尾插：每次在表尾插入一个节点</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_sll_insert_head(Link *p)</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    head = p;</span><br><span class="line">    <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">        tail = head;</span><br><span class="line">        first = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sll_insert_head(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    Link *p;</span><br><span class="line"></span><br><span class="line">    assert(p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link)));</span><br><span class="line">    p-&gt;val = val;</span><br><span class="line"></span><br><span class="line">    _sll_insert_head(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sll_insert_head</strong>函数负责分配节点并赋值，然后调用<strong>_sll_insert_head</strong>函数完成插入过程。可以看到，<strong>_sll_insert_head</strong>函数实际上很简单，它只负责将<strong>p</strong>插入到<strong>head</strong>的前面，然后更新<strong>head</strong>即可，这里<strong>head</strong>是否为空是无关紧要的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Link *</span><br><span class="line">sll_find_tail(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Link *p, *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = head; p; pre = p, p = p-&gt;next)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_sll_insert_tail(Link *p)                                                                                                  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tail || (tail = sll_find_tail()))</span><br><span class="line">        tail-&gt;next = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">        head = tail;</span><br><span class="line">        first = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sll_insert_tail(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    Link *p;</span><br><span class="line"></span><br><span class="line">    assert(p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link)));</span><br><span class="line">    p-&gt;val = val;</span><br><span class="line"></span><br><span class="line">    _sll_insert_tail(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾插和头插是类似的，只有一点需要注意的是：当<strong>tail</strong>为空时，我们需要调用<strong>sll_find_tail</strong>找到表尾，这通常只会发生在链表第一次执行尾插操作时。然后我们将<strong>p</strong>接到<strong>tail</strong>的后面即可。</p><p>除此之外，倘若要在一个有序链表中间插入一个节点，情况就比较麻烦了，因为这可能需要修改头指针。但如果借助二级指针的话，我们就能极大简化其操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_sll_insert(Link *p)</span><br><span class="line">&#123;</span><br><span class="line">    Link **np = &amp;head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 找到插入位置 */</span></span><br><span class="line">    <span class="keyword">while</span> (*np &amp;&amp; (*np)-&gt;val &lt; p-&gt;val)</span><br><span class="line">        np = &amp;(*np)-&gt;next;</span><br><span class="line">    p-&gt;next = *np;</span><br><span class="line">    *np = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sll_insert(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    Link *p; </span><br><span class="line"></span><br><span class="line">    assert(p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link)));</span><br><span class="line">    p-&gt;val = val;</span><br><span class="line"></span><br><span class="line">    _sll_insert(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察单链表节点的组织形式后，我们会发现，不管是头节点也好，一般节点也好，必然有一个指针指向它。这个指针可能是head也可能它的前驱节点中的next域。这样，我们就可以把在整个有序单链表中的插入归结一种情况处理。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>利用上述三个插入函数中的任一个，我们都可以很容易地创建一个单链表。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除操作同插入操作的方法类似。我们每次让<strong>np</strong>保存待删除节点的前驱节点中的<strong>next</strong>域，如果找到了待删除节点，我们就让<strong>*np</strong>指向待删除节点之后的那个节点，从而完成删除过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sll_delete(<span class="keyword">int</span> old_val)                                                                                                    </span><br><span class="line">&#123;</span><br><span class="line">    Link **np, *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (np = &amp;head; *np; np = &amp;(*np)-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*np)-&gt;val == old_val) &#123;</span><br><span class="line">            tmp = (*np)-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(*np);</span><br><span class="line">            *np = tmp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆置"><a href="#逆置" class="headerlink" title="逆置"></a>逆置</h3><p>单链表的逆置通常有三种方法：</p><blockquote><ol><li>利用头插法创建一个单链表的思想，我们从头遍历整个链表，然后用头插法重新链接每个节点，自然就将链表逆置过来了</li><li>就地逆置，也叫三指针法，改变每个节点的next域，完成逆置过程</li><li>递归的方法</li></ol></blockquote><h4 id="头插法逆置"><a href="#头插法逆置" class="headerlink" title="头插法逆置"></a>头插法逆置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sll_reverse(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Link *p, *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tail = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        p = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        p-&gt;next = pre;</span><br><span class="line">        pre = p;</span><br><span class="line">    &#125;</span><br><span class="line">    head = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="就地逆置"><a href="#就地逆置" class="headerlink" title="就地逆置"></a>就地逆置</h4><p>我们用<strong>pre</strong>保存上一次迭代中<strong>head</strong>的值，<strong>p</strong>指向<strong>head</strong>的后继节点，然后用<strong>head</strong>遍历整个链表。<strong><em>每次我们先让p保存head的后继，然后更新当前节点head中的next域，然后pre记录当前head的值，最后让head指向p，进行下一次迭代。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sll_reverse(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Link *pre, *p;                                                                                                         </span><br><span class="line"></span><br><span class="line">    tail = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (pre = <span class="literal">NULL</span>; head; head = p) &#123;</span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    head = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Link *</span><br><span class="line">sll_search(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    Link *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = head; p; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val == val)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求长"><a href="#求长" class="headerlink" title="求长"></a>求长</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sll_length(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    Link *p = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sll_print(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Link *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = head; p; p = p-&gt;next)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;val);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sll_destroy(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Link *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; head; head = tmp) &#123;</span><br><span class="line">        tmp = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这些是单链表的基本操作，但除此之外，还有一些有趣的操作需要说一下，比如说合并两个有序单链表、判断单链表中是否有环以及找到单链表中倒数第k个节点等。它们都涉及到了对单链表性质特点的了解及应用，下面我们来简单分析一下这些问题，并给出实现。</p><h3 id="合并两个有序单链表"><a href="#合并两个有序单链表" class="headerlink" title="合并两个有序单链表"></a>合并两个有序单链表</h3><p>合并操作整体思路上同<strong>归并排序</strong>的<strong>merge</strong>操作类似，只不过对数组排序而言，我们需要一个线性附加空间，而对链表则完全不需要，我们只需要摘下对应的节点，将它接入新的链表即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Link *</span><br><span class="line">sll_merge(Link *h1, Link *h2)</span><br><span class="line">&#123;</span><br><span class="line">    Link *p, *head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!h1 || !h2)</span><br><span class="line">        <span class="keyword">return</span> h1 ? h1 : h2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h1-&gt;val &lt; h2-&gt;val) &#123;</span><br><span class="line">        head = p = h1;</span><br><span class="line">        h1 = h1-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = p = h2;</span><br><span class="line">        h2 = h2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; h1 &amp;&amp; h2; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h1-&gt;val &lt; h2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = h1;</span><br><span class="line">            h1 = h1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = h2;</span><br><span class="line">            h2 = h2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = h1 ? h1 : h2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>h1、h2可为空，也可不为空。如果有一个为空，我们返回另一个即可。如果都不为空，我们首先记录新的链表的头节点，然后逐个比较h1、h2的头节点的值，将小的摘下来插到新链表的末尾。当这个过程结束后，某个链表可能还不为空，我们再将它整体接到新链表的末尾即可。</p><h3 id="判断是否有环"><a href="#判断是否有环" class="headerlink" title="判断是否有环"></a>判断是否有环</h3><p>判断链表是否有环有多种方法，或许当你第一次接触到这个问题时，你的想法很可能是设法保存访问过的所有节点，然后把新访问到的节点与它们逐个比对，如果有相同的就说明链表中有环。或者说我们可以不必用额外的空间保存访问过的节点，我们可以先记录链表的头指针，然后利用指针比较当前节点和之前访问过的所有节点。但这些方法都不太让人满意，利用一个很巧妙的方法——<strong>快慢指针法</strong>，我们可以很容易解决这个问题，包括后面两个问题。</p><p>什么是快慢指针法呢？就是设置两个指针，一个每次走两步，一个每次走一步，如果链表中存在环，则两个指针一定会相遇（即快指针追上慢指针）；否则的话，快指针会率先遍历完整个链表。</p><p>至于为什么一定会相遇？我觉得类似于我们高中物理学过的追及相遇问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Link *</span><br><span class="line">sll_ring(<span class="keyword">void</span>)                                                                                                       </span><br><span class="line">&#123;</span><br><span class="line">    Link *fast, *slow;</span><br><span class="line"></span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回倒数第k个节点"><a href="#返回倒数第k个节点" class="headerlink" title="返回倒数第k个节点"></a>返回倒数第k个节点</h3><p>我们先让快指针走到第k个节点，然后让快慢指针同步走（每次都走一步），当快指针走到链表的末尾时，慢指针刚好走到第(n - k)个节点，即倒数第k个节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Link *</span><br><span class="line">sll_last_k(<span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    Link *fast, *slow;</span><br><span class="line"></span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; k-- &gt; <span class="number">0</span>)</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回中间节点"><a href="#返回中间节点" class="headerlink" title="返回中间节点"></a>返回中间节点</h3><p>和上面的问题类似，我们让快指针每次走两步，慢指针每次走一步，当快指针走到链表末尾时，慢指针刚好走到中间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Link *</span><br><span class="line">sll_mid(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Link *fast, *slow;</span><br><span class="line"></span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆序打印"><a href="#逆序打印" class="headerlink" title="逆序打印"></a>逆序打印</h3><p>很简单，利用递归即可。我们都知道递归是用栈来实现的，而栈的特点又是<strong>后进先出</strong>，因此很容易用它来逆序打印单链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sll_print_r(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head-&gt;next)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, head-&gt;val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sll_print_r(head-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于单链表是链表的一种，所以我们首先来介绍一下链表。&lt;/p&gt;
&lt;p&gt;链表是一种线性表，通常由一连串节点组成，每个节点包含任意的实例数据，和一个或两个用于指向上一个或下一个节点的指针。&lt;/p&gt;
&lt;p&gt;使用链表的优点是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;克服了数组需要预先知道数据大小的缺点&lt;/li&gt;
&lt;li&gt;可以充分利用计算机的内存空间，实现灵活的动态内存管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
</feed>
