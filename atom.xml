<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>若倾</title>
  
  <subtitle>若教解语应倾国，任是无情也动人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-18T13:59:56.220Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>妖儿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单链表的基本操作</title>
    <link href="http://yoursite.com/2018/10/18/sll/"/>
    <id>http://yoursite.com/2018/10/18/sll/</id>
    <published>2018-10-18T13:59:56.219Z</published>
    <updated>2018-10-18T13:59:56.220Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><p>由于单链表是链表的一种，所以我们首先来介绍一下链表。</p><p>链表是一种线性表，通常由一连串节点组成，每个节点包含任意的实例数据，和一个或两个用于指向上一个或下一个节点的指针。</p><p>使用链表的优点是：</p><blockquote><ul><li>克服了数组需要预先知道数据大小的缺点</li><li>可以充分利用计算机的内存空间，实现灵活的动态内存管理</li></ul></blockquote><p>缺点是：</p><blockquote><ul><li>失去了数组随机读取的优点</li><li>由于增加了节点的指针域，空间开销比较大。</li></ul></blockquote><p>单链表是一种单向链接的链表，对链表的访问只能从表头开始，在表的末尾有一个特殊的结束标记，通常为NULL。</p><p>下面我们给出单链表的具体实现，涉及到它的一些基本操作，如创建、插入、删除等。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> &#123;</span>    <span class="comment">/*  表节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">next</span>;</span>    <span class="comment">/*  指向下一个节点的指针  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建一个单链表通常有两种方法：<strong><em>头插法和尾插法</em></strong></p><blockquote><ul><li>所谓头插法：就是将最先创建的那个节点作为尾节点，然后不断向前延伸。这种方法对数据的存储顺序和你的输入顺序是相反的。</li><li>所谓尾插法：与头插法相反，它将最先创建的那个节点作为头节点，然后不断向后延伸，这应该比较符合我们一般的思维习惯。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  create_head_sll函数：用头插法创建一个长度为size的单链表  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">create_head_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((head = <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="keyword">new</span>-&gt;val);</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;head-&gt;val);</span><br><span class="line">        head-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span> = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  create_tail_sll函数：用尾插法创建一个长度为size的单链表  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">create_tail_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">pre</span>, *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pre = head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist ))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre-&gt;val);</span><br><span class="line">    pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="keyword">new</span>-&gt;val);</span><br><span class="line">        pre-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pre = <span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><blockquote><p>单链表的插入操作通常要分好几种情况讨论，但只要我们细心观察它们，就会发现它们之间的共性，即<font color="red">每个节点都有一个指向它的指针</font>，头节点也不例外。从这种角度来看，头指针也不过是指向一个节点的普通指针而已。因此，我们在这里使用二级指针，能极大地简化操作，并使代码简洁优雅。<font color="red">而在遍历单链表的过程中，我们只需要保存每个指向next域的指针即可，这样就将所有可能的情况转化成一种通用的情况。</font></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  insert_sll函数：在有序单链表中插入一个节点，这里假定是按升序排列的  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sll</span><span class="params">(struct nlist **nextp, <span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;val = new_val;</span><br><span class="line">    <span class="comment">/*  寻找插入位置  */</span></span><br><span class="line">    <span class="keyword">while</span> (*nextp != <span class="literal">NULL</span> &amp;&amp; (*nextp)-&gt;val &lt; new_val)</span><br><span class="line">        nextp = &amp;(*nextp)-&gt;next;   <span class="comment">/*  每次得到指向next域的指针  */</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = *nextp;</span><br><span class="line">    *nextp = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>删除操作同插入操作的方法类似，每次也只需保存指向前一个节点的next域的指针即可，原因也很简单，因为前一个节点中的next指针指向当前节点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  delete_sll函数：在单链表中删除一个节点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_sll</span><span class="params">(struct nlist **nextp, <span class="keyword">int</span> old_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*nextp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*nextp)-&gt;val == old_val) &#123;</span><br><span class="line">            tmp = (*nextp)-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(*nextp);</span><br><span class="line">            *nextp = tmp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextp = &amp;(*nextp)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆置"><a href="#逆置" class="headerlink" title="逆置"></a>逆置</h3><p>单链表的逆置通常有三种方法：</p><blockquote><ol><li>利用头插法创建一个单链表的思想，我们从头遍历整个链表，然后用头插法重新链接每个节点，自然就将链表逆置过来了</li><li>就地逆置，也叫三指针法，改变每个节点的next域，完成逆置过程</li><li>递归的方法</li></ol></blockquote><h4 id="头插法逆置"><a href="#头插法逆置" class="headerlink" title="头插法逆置"></a>头插法逆置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct nlist * <span class="title">reverse_cll</span><span class="params">(struct nlist *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">head</span>, *<span class="title">pre</span>;</span></span><br><span class="line"></span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        head = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="就地逆置"><a href="#就地逆置" class="headerlink" title="就地逆置"></a>就地逆置</h4><blockquote><p>我们用pre指向前一个节点，new指向后一个节点，而*nextp则是head指针，指向当前需要改变的节点，我们用它来遍历整个链表。<strong><em>每次我们先让new指向下一个需要改变的节点，然后再让当前结点的next指针指向之前的节点，最后我们更新pre的值。</em></strong> 至于这里用不用二级指针就随你喜欢了。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_sll</span><span class="params">(struct nlist **nextp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">pre</span>, *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (pre = <span class="literal">NULL</span>; *nextp != <span class="literal">NULL</span>; *nextp = <span class="keyword">new</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> = (*nextp)-&gt;next;</span><br><span class="line">        (*nextp)-&gt;next = pre;</span><br><span class="line">        pre = *nextp;</span><br><span class="line">    &#125;</span><br><span class="line">    *nextp = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找、求长、打印"><a href="#查找、求长、打印" class="headerlink" title="查找、求长、打印"></a>查找、求长、打印</h3><blockquote><p>单链表的查找、求长以及打印操作主要涉及到的都只是 <strong><em>遍历链表的方法</em></strong>，所以应该都很简单。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  search_sll函数：在单链表中查找一个值  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">search_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; head != <span class="literal">NULL</span>; head = head-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == val)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  length_sll函数：计算单链表的长度  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_sll</span><span class="params">(struct nlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; head != <span class="literal">NULL</span>; len++)</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  print_sll函数：打印单链表  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sll</span><span class="params">(struct nlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; head != <span class="literal">NULL</span>; head = head-&gt;next)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, head-&gt;val);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>这里销毁单链表之所以使用二级指针，我是这么想的：</p><blockquote><p><strong><em>如果我们只是简单的传回head指针，虽然它指向的节点被释放了，但它本身的值是不会改变的。</em></strong> 为了避免之后错误地引用已经被释放的head指针，我们需要将它置空，使用二级指针可以很容易做到这一点，虽然在main函数中我们可以在destruct之后手动置空head，但我认为这样更好一些。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  destruct_sll函数：销毁单链表  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destruct_sll</span><span class="params">(struct nlist **nextp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( ; *nextp != <span class="literal">NULL</span>; *nextp = tmp) &#123;</span><br><span class="line">        tmp = (*nextp)-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(*nextp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;由于单链表是链表的一种，所以我们首先来介绍一下链表。&lt;/p&gt;
&lt;p&gt;链表是一种线性表，通常由一连串节点组成，每个节点包含任意的实例数据，和一个或两个用于指向上一个或下一个节点的指针。&lt;/p&gt;
&lt;p&gt;使用链表的优点是：&lt;/p&gt;
&lt;block
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/10/18/hello-world/"/>
    <id>http://yoursite.com/2018/10/18/hello-world/</id>
    <published>2018-10-18T00:28:20.016Z</published>
    <updated>2018-10-18T00:28:20.016Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
