<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>若倾</title>
  
  <subtitle>若教解语应倾国，任是无情也动人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yaoer.me/"/>
  <updated>2019-01-28T14:51:52.189Z</updated>
  <id>https://yaoer.me/</id>
  
  <author>
    <name>妖儿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简单AI贪吃蛇</title>
    <link href="https://yaoer.me/2018/11/09/ai-snake/"/>
    <id>https://yaoer.me/2018/11/09/ai-snake/</id>
    <published>2018-11-08T16:00:00.000Z</published>
    <updated>2019-01-28T14:51:52.189Z</updated>
    
    <content type="html"><![CDATA[<p>简单的手工移动的贪吃蛇模型来自于我之前的一篇<a href="https://yaoer.me/2018/10/25/snake/">博客</a>，为了实现简单的AI功能，我只是在它的基础上添加了相关的AI部分代码而已。但就算如此，也有许多东西需要考虑。</p><p>AI贪吃蛇通俗点来说就是让蛇自己实现<strong><em>自动寻路功能</em></strong>。从这一点来说，首先应该想到的就是有关图的搜索算法了，这个我们下面会详细描述。现在我们先考虑最简单的一种情况，即<strong><em>使用某种办法，让蛇自己先动起来</em></strong>。</p><a id="more"></a><p>那么使用什么办法呢？要想让蛇自己寻找食物去吃，那么首先应该知道食物的坐标，这个不难办到（我们假设每次只会出现一个食物），然后就需要一条从蛇本身到食物的一条路径，蛇只要沿着这条路径走，就能吃到食物了。先不要去管这种方法的可行性有多高，最起码它能让蛇自己动起来，这已经是一个很好的开头了，不是吗？</p><p>那么怎么去选择这条路径呢？我们知道，两点之间的路径可以有好多种，其中直线最短，显然我们希望蛇能沿着最短路径吃到食物，但直线显然是不现实的，它无法沿着直线走。那我们可以退而求其次，选择一条<strong><em>最简单方便的路径</em></strong>，这条路径就是所谓的<strong><em>曼哈顿距离</em></strong>。它实际上很简单，在具体的编程中也很容易操作。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/08/Manhattan_distance.svg/300px-Manhattan_distance.svg.png" alt=""></p><blockquote><p>红、蓝与黄线都表示曼哈顿距离，它们都拥有一样的长度；而绿线则表示欧几里得距离。</p></blockquote><p>我们可以选择<strong>红线</strong>这种最简单的曼哈顿距离，每次我们记录下路径，然后沿着这条路径去走，直到吃到食物。在游戏初期，蛇身的长度很短时，这种方法是有一定作用的，可以让蛇坚持一段时间。<strong><em>但一旦蛇身变长，情形就显然有所不同了。</em></strong></p><p><strong><em>贪吃蛇每时每刻所面临的情形不是静态的一成不变的，而是随着它的移动不断发生变化的，前一刻所做出的安全可行的决策，在后一刻未必是安全可行的，也就是说，<font color="red">对于路径的规划应该是动态的，蛇每走一步，我们都应该重新审视蛇当前所面临的处境，重新寻找出一条可行的路径。</font></em></strong> &lt;/font&gt;</p><p>基于这种考虑，我们可以想到使用<strong><em>BFS和DFS</em></strong>来动态解决蛇的自动寻路问题。因为<strong><em>BFS</em></strong>找到的一定是最短路径，因此，我们优先考虑使用<strong><em>BFS</em></strong>。但后面我们就会意识到，<strong><em>事情有时并非绝对，并不是所有的情况下都需要走最短的路径。</em></strong></p><p>现在我们要思考几个问题：</p><blockquote><ul><li>每次只要找到最短路径，就要沿着该路径去吃食物吗？</li><li>吃到食物后，蛇有没有可能陷入绝境？</li><li>如果无法找到蛇到食物的最短路径怎么办？</li><li>。。。</li></ul></blockquote><p>这样想来，有些问题确实还挺复杂的。针对上述问题，我们先给出一个初步的算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (能找到吃食物的最短路径)</span><br><span class="line">    去吃食物</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    向安全的地方随便走一步</span><br></pre></td></tr></table></figure><p>显然上述算法也是有缺陷的，它并没有解决我们上面提出的问题。也就是说，<strong><em>它只满足于现在能吃到食物，而不去考虑这种行为是否会将自己置身于危险的境地</em></strong>。但它解决了一个问题，如果无法找到路径，只能<strong><em>wander</em></strong>一步，这种看似没有道理的<strong><em>闲逛</em></strong>，在实际中却是工作的很好。这种方案具有一定的随机性，并非完美无缺。但在绝大多数情况下它是可行的。</p><p><img src="https://github.com/yaomer/pictures/blob/master/snake.png?raw=true" alt=""></p><p>蛇在去吃食物时，显然不能只顾当前，而应该考虑的长远一点。如果仔细观察蛇身的移动，我们会发现，<strong><em>每次蛇身移动过后，蛇尾总是会空出一个位置，而这个位置一定是安全的，也是我们想要的。也就是说，每当去吃食物时，先判断一下能否找到从蛇身到蛇尾的路径，然后再作出决策。</em></strong></p><p>至于从蛇身到蛇尾的路径应该是什么样的，显然此时我们理所当然的认为应该是最短路径。但之后我们就会发现，这种方法如果运气好的话，可以让蛇运行相当长的一段时间，但它有时却会让蛇陷入到<strong><em>无限循环</em></strong> 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (能找到吃食物的最短路径)</span><br><span class="line">    <span class="keyword">if</span> (吃到食物后能找到蛇尾)</span><br><span class="line">        去吃食物</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (能找到蛇头到蛇尾的最短路径)</span><br><span class="line">            跟着蛇尾走</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            wander一步</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (能找到蛇头到蛇尾的最短路径)</span><br><span class="line">        跟着蛇尾走</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        wander一步</span><br></pre></td></tr></table></figure><p>这时的算法稍微有点复杂，但其实也不难，因为逻辑简单清楚。这里可能会出现问题的地方就是 <strong><em>wander</em></strong> 这种策略了。</p><p>我们可以试想一下这种情况：</p><blockquote><p>当蛇要走下一步时发现，它能找到吃食物的路径，但吃过后却无法找到自己的尾巴，然而却能找到从自己蛇头到蛇尾的路径。基于我们的算法策略，它认为现在去吃食物不安全，所以它决定跟着蛇尾走，但这种做法是有缺陷的，很有可能它会一直陷入这种怪圈中，因为下一步可能一直是不安全的，这样就会让它自己陷入无限循环之中，即一直追着自己的尾巴走。</p></blockquote><p>对于应该如何解决这种困境，我的初步想法是，<strong><em>在寻找到蛇尾的路径时，不能使用BFS，而应该使用DFS朝相反方向找一条相对来说较远的路径</em></strong>。这种反其道而行之的做法却是合理的，当蛇无法找到可行路径时，它就应该为自己之后的行动留有余地。</p><p>这种方法应当是有一定几率能跑完全图的。</p><p>最后要说明的一点是，不管是<strong><em>BFS</em></strong>还是<strong><em>DFS</em></strong>，都<code>盲目式</code>搜索算法，一般而言，它们都不是高效的，而使用<code>启发式</code>搜索算法显然更好一些，如大名鼎鼎的<code>A*</code>算法。我呢，希望自己以后能有时间用<code>A*</code>算法去实现一下这个<strong><em>简单的AI贪吃蛇</em></strong>。</p><p>然后呢，代码见<a href="https://yaoer.me/2018/11/09/ai-snake/">这里</a>，大家可以略作参考。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的手工移动的贪吃蛇模型来自于我之前的一篇&lt;a href=&quot;https://yaoer.me/2018/10/25/snake/&quot;&gt;博客&lt;/a&gt;，为了实现简单的AI功能，我只是在它的基础上添加了相关的AI部分代码而已。但就算如此，也有许多东西需要考虑。&lt;/p&gt;
&lt;p&gt;AI贪吃蛇通俗点来说就是让蛇自己实现&lt;strong&gt;&lt;em&gt;自动寻路功能&lt;/em&gt;&lt;/strong&gt;。从这一点来说，首先应该想到的就是有关图的搜索算法了，这个我们下面会详细描述。现在我们先考虑最简单的一种情况，即&lt;strong&gt;&lt;em&gt;使用某种办法，让蛇自己先动起来&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>常见排序算法总结</title>
    <link href="https://yaoer.me/2018/11/07/sort/"/>
    <id>https://yaoer.me/2018/11/07/sort/</id>
    <published>2018-11-06T16:00:00.000Z</published>
    <updated>2018-11-07T10:08:05.783Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中，我们对常见的排序算法作一个总结。包括：<strong><em>冒泡、选择、插入、希尔、归并、快排、堆排以及桶排。</em></strong></p><a id="more"></a><p>以上排序算法中，除了桶排序以外，其余算法都是基于<font color="red">比较</font>的。在最差情况下，任何一种比较排序至少需要<font color="red">O(n log n)</font>次比较操作。这是比较操作所获取的信息有限所导致的，或者说是全序集的模糊代数结构所导致的。</p><p>不过，比较排序<strong><em>在控制比较函数方面有显著优势，能对各种数据类型进行排序，并且可以很好地控制一个序列如何被排序</em></strong>。例如，可以通过改变比较函数从而使排序结果倒置。并且 <strong><em>一旦比较函数完成，任何比较算法都可以不经修改地使用；</em></strong>而非比较排序对数据类型的要求会更严格。</p><hr><p>排序算法分类：</p><div class="table-container"><table><thead><tr><th>插入排序</th><th>选择排序</th><th>交换排序</th></tr></thead><tbody><tr><td>直接插入</td><td>选择排序</td><td>冒泡排序</td></tr><tr><td>希尔排序</td><td>堆排序</td><td>快排</td></tr></tbody></table></div><p>各排序算法的时间复杂度：</p><div class="table-container"><table><thead><tr><th>排序算法</th><th>最坏时间复杂度</th><th>平均时间复杂度</th><th>最优时间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>插入排序</td><td>O($n^2$)</td><td>O($n^2$)</td><td>O(n)</td><td>稳定</td></tr><tr><td>冒泡排序</td><td>O($n^2$)</td><td>O($n^2$)</td><td>O(n)（优化后的）</td><td>稳定</td></tr><tr><td>选择排序</td><td>O($n^2$)</td><td>O($n^2$)</td><td>O($n^2$)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O($n^2$)</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>O(n $\log$ n)</td><td>不稳定</td></tr><tr><td>桶排序</td><td>O($n^2$)</td><td>O(n + k)</td><td>O(n)</td><td>不稳定</td></tr><tr><td>希尔排序</td><td></td><td></td><td></td><td>不稳定</td></tr></tbody></table></div><p>（注：希尔排序的时间复杂度依赖于增量序列的选择）</p><p>在接下来对各排序算法的描述中，我们用<strong><em>伪代码</em></strong>描述算法本身，并给出C语言的实现。我们假设我们所描述的排序算法都是对<strong><em>整形数组A[1..n]</em></strong>进行排序。</p><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序是一种简单直观的排序算法。它的工作原理是构建有序序列。对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong><em>插入排序对几乎已经排好序的序列是非常高效的。但一般情况下，插入排序是低效的，因为它每次只能将数据移动一位。</em></strong></p><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">2</span> to n</span><br><span class="line">    key = A[j]</span><br><span class="line">    i = j - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key</span><br><span class="line">        A[i + <span class="number">1</span>] = A[i]</span><br><span class="line">        i = i - <span class="number">1</span></span><br><span class="line">    A[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><p>C实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  insertion_sort函数：插入排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> key;    <span class="comment">/*  每次待插入的值  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        key = v[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; v[j] &gt; key; j--)</span><br><span class="line">            v[j + <span class="number">1</span>] = v[j];    <span class="comment">/*  将大于key的元素后移  */</span></span><br><span class="line">        v[j + <span class="number">1</span>] = key;    <span class="comment">/*  将key插入到相应位置  */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/2/25/Insertion_sort_animation.gif" alt=""></p><hr><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是一种简单的排序算法。<strong><em>它重复地遍历要排序的整个数列，每次比较相邻的两个元素，如果它们的顺序错误就把它们交换过来。这个算法名字的由来是因为小的元素会经由交换操作而慢慢“上浮”到排序序列的最前面。</em></strong></p><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">2</span> to n - j</span><br><span class="line">        <span class="keyword">if</span> A[i - <span class="number">1</span>] &gt; A[i]</span><br><span class="line">            swap A[i - <span class="number">1</span>] with A[i]</span><br></pre></td></tr></table></figure><p>C实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  bubble_sort函数：冒泡排序（原始版本）  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">/*  共需要进行n趟排序  */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n - i; j++)   <span class="comment">/*  每趟排序都使小数上升，大数下沉  */</span></span><br><span class="line">            <span class="keyword">if</span> (v[j - <span class="number">1</span>] &gt; v[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = v[j];</span><br><span class="line">                v[j] = v[j - <span class="number">1</span>];</span><br><span class="line">                v[j - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，当输入的序列已经是有序的时候，该排序算法仍然会做大量无用的比较操作。因此，我们可以考虑优化一下它。</p><p>我们可以考虑一下该算法完成整个排序的结束条件是什么，在现在这个原始版本中，它总要对整个待排序序列遍历n趟，即使在某一次遍历之后，已经排好序了，它仍然会像之前那样做完它应该做的所有工作，但这完全是没必要的，一旦排好序，算法就应该结束了。</p><p>为此，<strong><em>我们可以设置一个标志位exchange，标记在某一趟排序过程中，是否发生过交换，一旦没有发生过交换操作，就说明已经排好序了。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  bubble_sort函数：冒泡排序（优化版本）  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, exchange;</span><br><span class="line">    <span class="keyword">enum</span> &#123;NO, YES&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        exchange = NO;    </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (v[j - <span class="number">1</span>] &gt; v[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = v[j];</span><br><span class="line">                v[j] = v[j - <span class="number">1</span>];</span><br><span class="line">                v[j - <span class="number">1</span>] = tmp;</span><br><span class="line">                exchange = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exchange == NO)   <span class="comment">/*  上一趟排序中，没有发生过交换  */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif" alt=""></p><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是一种简单直观的排序算法。<strong><em>它每次找出从未排序序列中的最小值，然后将该最小值与未排序序列的第一个数交换，从而完成对有序区的增量。</em></strong></p><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">for</span> i = j to n</span><br><span class="line">        find A[min]</span><br><span class="line">    swap A[min] with A[j]</span><br></pre></td></tr></table></figure><p>C实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  selection_sort函数：选择排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (v[j] &lt; v[min])    <span class="comment">/*  找出未排序序列中的最小元素  */</span></span><br><span class="line">                min = j;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = v[i];</span><br><span class="line">            v[i] = v[min];</span><br><span class="line">            v[min] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" alt=""></p><hr><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序， 也称 <strong><em>缩小增量排序</em></strong>，是对直接插入排序的一种更高效的改进版本。它的基本思想是：<strong><em>先比较距离较远的元素，这样可以让每个元素一次性地朝最终位置前进一大步（而非像直接插入排序那样每次只能移动一步），从而快速减少大量无序的情况，并且减轻后续的工作。被比较的元素之间的距离逐步缩小，直到减少为1，这时就变成了直接插入排序对几近有序的序列进行排序的情况。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  shell_sort函数：希尔排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> gap;    <span class="comment">/*  步长  */</span></span><br><span class="line"><span class="comment">/*  这里采用希尔增量  */</span></span><br><span class="line">    <span class="keyword">for</span> (gap = n; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)    <span class="comment">/*  控制步长  */</span></span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; n; i++)   <span class="comment">/*  在各对元素间移动位置  */</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; v[j] &gt; v[j + gap]; j -= gap) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = v[j];    <span class="comment">/*  比较各对相距gap个位置的元素  */</span></span><br><span class="line">                v[j] = v[j + gap];</span><br><span class="line">                v[j + gap] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif" alt=""></p><p>希尔排序算法彩条：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Shell_sorting_algorithm_color_bars.svg/220px-Shell_sorting_algorithm_color_bars.svg.png" alt=""></p><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是<code>分治法</code>的一个非常典型的应用，其算法核心是<code>合并(merge)</code>操作。</p><p>因为用到了分治法，所以这里我们简述一下其思想：<strong><em>将原问题分解为若干个规模较小的类似于原问题的子问题，递归地求解这些子问题，然后再合并所有子问题的解来建立原问题的解。</em></strong></p><p>分治法都有类似以下的三个步骤：</p><blockquote><ul><li>分解：将原问题划分为若干个类似于原问题的规模较小的实例</li><li>求解：递归求解所有的子问题，若子问题规模足够小，则直接求解</li><li>合并：合并所有子问题的解，从而得到原问题的解</li></ul></blockquote><p>归并排序完全遵循上述模式，具体操作如下：</p><blockquote><ul><li>分解：将待排序的n个元素的序列划分为各具有n/2个元素的两个子序列</li><li>求解：使用归并排序递归地排序两个子序列</li><li>合并：合并两个已排好序的子序列以产生新的已排好序的序列</li></ul></blockquote><p>当待排序的序列长度为1时，<strong><em>递归“开始回升“</em></strong>，在这种情况下不需做任何工作，因为长度为1的每个序列都已排好序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  merge_sort函数：归并排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(v, left, mid);</span><br><span class="line">        merge_sort(v, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(v, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  merge函数：合并操作  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> tmp[right - left + <span class="number">1</span>];    <span class="comment">/*  用于合并操作的一个附加的临时数组  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= mid &amp;&amp; j &lt;= right; k++)</span><br><span class="line">        tmp[k] = v[i] &lt; v[j] ? v[i++] : v[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        tmp[k++] = v[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">        tmp[k++] = v[j++];</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)    <span class="comment">/*  将排好序的序列拷贝回原数组  */</span></span><br><span class="line">        v[left++] = tmp[k++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然归并排序的最坏运行时间是O(n $\log$ n)，但它很难用于主存排序，主要问题在于合并操作中所需要的线性附加内存。不过，merge例程是大多数外部排序算法的基石。</p><p>归并排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" alt=""></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c5/Merge_sort_animation2.gif/220px-Merge_sort_animation2.gif" alt=""></p><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是实践中已知的最快的排序算法，同样用到了分治法的思想。它之所以特别快的原因主要是非常精炼和高度优化的内部循环。</p><p>快排的基本算法如下：</p><p><strong><em>对于一个给定的数组，从中选择任一元素作为主元，以主元为界将其余元素划分为两个子集：一个子集中的所有元素都小于主元，另一个子集中的所有元素都大于或等于主元。对这两个子集递归地执行这一过程，当某个子集中的元素个数小于2时，该子集就不需要再次排序了，即终止递归。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  q_sort函数：快速排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">q_sort</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)    <span class="comment">/*  若某个子集的元素个数小于2，则终止递归  */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    swap(v, left, (left + right) / <span class="number">2</span>);   <span class="comment">/*  每次选取每个子集中间的元素作为主元  */</span></span><br><span class="line">    last = left;</span><br><span class="line">    <span class="keyword">for</span> (i = left + <span class="number">1</span>; i &lt;= right; i++)    <span class="comment">/*  划分子集  */</span></span><br><span class="line">        <span class="keyword">if</span> (v[i] &lt; v[left])</span><br><span class="line">            swap(v, i, ++last);</span><br><span class="line">    swap(v, left, last);     <span class="comment">/*  恢复主元  */</span></span><br><span class="line"></span><br><span class="line">    q_sort(v, left, last - <span class="number">1</span>);</span><br><span class="line">    q_sort(v, last + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  swap函数：交换两个数  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *v, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = v[i];</span><br><span class="line">    v[i] = v[j];</span><br><span class="line">    v[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序过程：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt=""></p><hr><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序可以详见我的另一篇博客<a href="https://yaoer.me/2018/10/24/heap/">堆及其应用</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本文中，我们对常见的排序算法作一个总结。包括：&lt;strong&gt;&lt;em&gt;冒泡、选择、插入、希尔、归并、快排、堆排以及桶排。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yaoer.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>浅析scanf函数</title>
    <link href="https://yaoer.me/2018/11/01/scanf/"/>
    <id>https://yaoer.me/2018/11/01/scanf/</id>
    <published>2018-10-31T16:00:00.000Z</published>
    <updated>2018-11-01T07:47:38.362Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h3><blockquote><ul><li><strong><em>函数原型</em></strong>： <code>int scanf(char *fmt, ...)</code></li><li><strong><em>参数说明</em></strong>：它的第一个参数fmt是格式字符串，包含普通字符和转换说明；第二个参数是可变长参数表，它的参数必须是指针，这是c语言 <strong><em><font color="red">传值调用语义所要求的</font></em></strong>  。它的返回值是 <strong><em><font color="red">成功匹配并赋值的输入项个数。</font></em></strong> 如果到达文件尾，它返回EOF。</li></ul></blockquote><a id="more"></a><p>我们可以举例说明一下它的返回值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果我们输入两个整数，程序将打印2；如果一个是整数，一个不是整数的话，程序则会打印1；通俗来说，<strong><em>就是我们输入的与格式字符串中转换说明匹配的参数个数将作为返回值。</em></strong></p></blockquote><h3 id="格式字符串"><a href="#格式字符串" class="headerlink" title="格式字符串"></a>格式字符串</h3><blockquote><ul><li><strong><em>普通字符</em></strong>（不包括%）：用于匹配输入流中下一个<strong>非空白字符。</strong></li><li><strong><em>转换说明</em></strong>：依次由一个<strong>%</strong>、一个可选的<strong>赋值禁止符*</strong>、一个可选的<strong>数值(指定最大字段宽度)</strong>、一个可选的<strong>h、l或L字符(指定目标对象的宽度)</strong> 以及一个<strong>转换字符</strong>组成。</li></ul></blockquote><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><ul><li>首先，逐个拿输入缓冲区内的字符与格式字符串进行匹配检查。</li><li><strong><em>对于转换说明，匹配成功则读入字符；匹配不成功，则将字符压回到输入缓冲区中，留待下次读取，然后函数返回。</em></strong></li><li><strong><em>对于普通字符和空白符，匹配成功时把字符丢弃掉；匹配不成功，则将字符压回到输入缓冲区中，函数返回。</em></strong></li><li>下一次调用scanf函数时将从上一次转换的最后一个字符的下一个字符开始继续搜索</li><li>转换说明用于控制下一个输入字段的转换。但是如果转换说明中有赋值禁止符*，则跳过该字段，不进行赋值。 <strong><em><font color="red">输入字段被定义为一个不包括空白符的字符串，其边界定义为到下一个空白符或达到指定的字段宽度。</font></em></strong> 而这表明scanf函数将越过行边界读取输入。</li><li>需要说明的是：<strong><em>scanf函数会忽略格式串中的空白符</em></strong>；当在格式串中遇见一个或多个连续的空白符时，它会重复读取，直到遇见一个非空白符为止，然后将最后遇见的非空白符重新放到输入缓冲区中。</li></ul></blockquote><h3 id="一些有趣的转换说明"><a href="#一些有趣的转换说明" class="headerlink" title="一些有趣的转换说明"></a>一些有趣的转换说明</h3><h4 id="scanf扫描集"><a href="#scanf扫描集" class="headerlink" title="scanf扫描集"></a>scanf扫描集</h4><blockquote><ul><li>使用格式是这样的：<strong>%[]</strong>。它需要一个<strong>char *</strong> 类型的参数，并且总在所有输入之后存储一个 <strong>‘\0’</strong> 字符。</li><li>方括号里可以指定匹配的所有字符，也可以指定所有不匹配的字符，只需 <strong>%<sup><a href="#fn_" id="reffn_"></a></sup></strong> 。如果想在指定的集合中包含 <strong>]</strong> ，则可以这样使用 <strong>%[]]</strong> ，例如 <strong>%[][]</strong> 可以扫描方括号。 <strong><em><font color="red">不能将空字符包含在指定的字符集合中。</font></em></strong></li></ul></blockquote><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[123]"</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);</span><br><span class="line">    <span class="comment">/*  它会扫描整个输入，直到遇见空格、制表或其他字符(非123)，然后将之前的字符保存在字符数组s中  */</span></span><br><span class="line">    <span class="comment">/*  如果你想要遇见数字就停止，可以这样使用  */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^0-9]"</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);</span><br><span class="line">    <span class="comment">/*  怎么样，是不是有点正则表达式的范儿了  */</span></span><br><span class="line">    <span class="comment">/*  我们都知道，scanf函数无法读取含空白符的字串，而我们使用扫描集就可以解决这个问题  */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^\n]"</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);</span><br><span class="line">    <span class="comment">/*  将一行输入保存到s中，包括空白和制表符  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很有趣啊<code>^o^</code></p><h4 id="转换说明-n"><a href="#转换说明-n" class="headerlink" title="转换说明%n"></a>转换说明<code>%n</code></h4><blockquote><ul><li>它不读取输入，需要一个<strong>int *</strong> 类型的参数，这个整数 <strong><em>记录了scanf函数从输入流中读取的字符总数。</em></strong></li><li><strong><em>执行一个%n不会增加scanf函数匹配并赋值的输入项个数</em></strong>，即它的返回值不会增加。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%n"</span>, s, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n);</span><br><span class="line">    <span class="comment">/*  如果我们输入hello，则输出结果为:5  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>我们的重点主要在于 <strong><em>参数的处理</em></strong>，所以，minscanf函数只处理格式字符串和参数，格式转换则通过调用scanf函数实现。</p><p>在此之前，我们先说明一下<strong>stdarg.h</strong>中包含的一组宏定义，它们对 <strong><em>如何遍历可变参数表</em></strong> 作了定义。该头文件的实现因不同的机器而不同，但提供的接口是一致的。</p><div class="table-container"><table><thead><tr><th>宏</th><th>说明</th></tr></thead><tbody><tr><td>va_list</td><td>用于声明一个变量，该变量将依次引用各无名参数。</td></tr><tr><td>va_start</td><td>将ap初始化为指向第一个无名参数的指针。在使用ap之前，该宏必须被调用一次。参数表必须至少包含一个有名参数，va_start将最后一个有名参数作为起点。</td></tr><tr><td>va_arg</td><td>每次调用va_arg，该函数都将返回一个参数，并将ap指向下一个参数。</td></tr><tr><td>va_end</td><td>必须在函数返回之前调用以作一些必要的清理工作。</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  minscanf函数：带有可变参数表的简化的scanf函数  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minscanf</span><span class="params">(<span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;    <span class="comment">/*  声明一个变量ap，该变量将依次指向每个无名参数  */</span></span><br><span class="line">    <span class="keyword">char</span> *p, *sval;</span><br><span class="line">    <span class="keyword">char</span> format[FORMAT];</span><br><span class="line">    <span class="keyword">int</span> i, *ival;</span><br><span class="line">    <span class="keyword">unsigned</span> *uval;</span><br><span class="line">    <span class="keyword">double</span> *dval;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    va_start(ap, fmt);    <span class="comment">/*  将ap指向第一个无名参数  */</span></span><br><span class="line">    <span class="keyword">for</span> (p = fmt; *p != <span class="string">'\0'</span>; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p != <span class="string">'%'</span>) &#123;</span><br><span class="line">            format[i++] = *p;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        format[i++] = <span class="string">'%'</span>;</span><br><span class="line">        <span class="keyword">while</span> (*(p + <span class="number">1</span>) &amp;&amp; !<span class="built_in">isalpha</span>(*(p + <span class="number">1</span>)))    <span class="comment">/*  保存%后的可选字符  */</span></span><br><span class="line">            format[i++] = *++p;</span><br><span class="line">        format[i++] = *++p;    <span class="comment">/*  保存转换字符  */</span></span><br><span class="line">        format[i] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'i'</span>:  </span><br><span class="line">            ival = va_arg(ap, <span class="keyword">int</span> *);</span><br><span class="line">            <span class="built_in">scanf</span>(format, ival);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'x'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">            uval = va_arg(ap, <span class="keyword">unsigned</span> *);</span><br><span class="line">            <span class="built_in">scanf</span>(format, uval);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">            dval = va_arg(ap, <span class="keyword">double</span> *);</span><br><span class="line">            <span class="built_in">scanf</span>(format, dval);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">            sval = va_arg(ap, <span class="keyword">char</span> *);</span><br><span class="line">            <span class="built_in">scanf</span>(format, sval);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br>[C程序设计语言][K&amp;R]</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本说明&quot;&gt;&lt;a href=&quot;#基本说明&quot; class=&quot;headerlink&quot; title=&quot;基本说明&quot;&gt;&lt;/a&gt;基本说明&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;函数原型&lt;/em&gt;&lt;/strong&gt;： &lt;code&gt;int scanf(char *fmt, ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;参数说明&lt;/em&gt;&lt;/strong&gt;：它的第一个参数fmt是格式字符串，包含普通字符和转换说明；第二个参数是可变长参数表，它的参数必须是指针，这是c语言 &lt;strong&gt;&lt;em&gt;&lt;font color=&quot;red&quot;&gt;传值调用语义所要求的&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;  。它的返回值是 &lt;strong&gt;&lt;em&gt;&lt;font color=&quot;red&quot;&gt;成功匹配并赋值的输入项个数。&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt; 如果到达文件尾，它返回EOF。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>约瑟夫环问题详解</title>
    <link href="https://yaoer.me/2018/10/25/joseph/"/>
    <id>https://yaoer.me/2018/10/25/joseph/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2018-10-25T01:35:28.445Z</updated>
    
    <content type="html"><![CDATA[<p>我们先看一下对该问题的描述：</p><blockquote><p>已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。</p></blockquote><a id="more"></a><p>解决该问题通常有两种方法：</p><blockquote><ul><li><font color="red">模拟法</font>（模拟整个游戏的运行过程）<ul><li><strong><em>循环链表</em></strong></li><li><strong><em>数组</em></strong></li></ul></li><li><font color="red">数学公式法</font>（直接通过公式推导得出结果，不关心具体过程）</li></ul></blockquote><p>谈不上哪种更简单，只在于思考问题、解决问题的方式不同而已。</p><blockquote><ul><li>模拟法的时间复杂度为O(mn)，当n和m很大时，程序将很难在短时间内得到结果。<ul><li>模拟法的一个优点是：程序的设计思路很清晰。</li></ul></li><li>数学公式法的时间复杂度为O(n)。<ul><li>数学方法虽然使最终的程序编写起来很简单，但前提是，你得有足够强的抽象思维能力，能够得出最终的公式。</li></ul></li></ul></blockquote><p>下面我们给出以上各种方法的实现：</p><hr><h3 id="模拟法"><a href="#模拟法" class="headerlink" title="模拟法"></a>模拟法</h3><h4 id="循环链表模拟"><a href="#循环链表模拟" class="headerlink" title="循环链表模拟"></a>循环链表模拟</h4><blockquote><p>确切说来，我们具体使用的是单向循环链表。我们从1，2，3，…n给每个人编号。一旦他出列，我们就将他从链表中删去，直到剩下最后一个人，即为获胜者。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> number;     <span class="comment">/*  编号  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意的是删除操作。我们都知道，每个节点都有一个next指针指向它，为了将删除所有位置的节点看作一种通用的情况，我们需要一个指向next域的指针，即一个二级指针。而且在删除过程中，要注意保证链表不断裂。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *head, **np, *tmp;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"></span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((head = creat_cll(head, n)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">/*  初始化链表  */</span></span><br><span class="line">    <span class="keyword">for</span> (np = &amp;head-&gt;next; *np != head; np = &amp;(*np)-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> ((*np)-&gt;number == k)    <span class="comment">/*  找到开始报数的人  */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((*np)-&gt;next != *np) &#123;    <span class="comment">/*  剩下最后一个节点，循环终止  */</span></span><br><span class="line">        <span class="keyword">if</span> (k++ == m) &#123;     <span class="comment">/*  删除应该出列的人  */</span></span><br><span class="line">            tmp = (*np)-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(*np);</span><br><span class="line">            *np = tmp;</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            np = &amp;(*np)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (*np)-&gt;number);   <span class="comment">/*  打印出获胜者  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面的操作类似于单链表的创建，只是最后我们需要把链表的首尾连接起来而已。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  creat_cll函数：创建一个单向循环链表，并初始化  */</span></span><br><span class="line"><span class="function">Node *<span class="title">creat_cll</span><span class="params">(Node *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *<span class="keyword">new</span>, *pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pre = <span class="keyword">new</span> = head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;number = n;</span><br><span class="line">    <span class="keyword">while</span> (--n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = pre;</span><br><span class="line">        pre = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;number = n;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = <span class="keyword">new</span>;    <span class="comment">/*  连接链表的首尾  */</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环链表还有一种方法，就是采用惰性删除</p><blockquote><p>意思就是我们并不真正地删除链表节点，而只是将它标记为已删除状态。因为我们的编号都是大于0的数，所以一旦某个人出列，我们只需将他的number置为0即可。</p></blockquote><p>具体过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *head, *p;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"></span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((head = creat_cll(head, n)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = head-&gt;next; p != head; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;number == k)    <span class="comment">/*  找到开始报数的人  */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k++ == m) &#123;</span><br><span class="line">            p-&gt;number = <span class="number">0</span>;</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;    <span class="comment">/*  每次遍历链表的时候，需要跳过那些已出列的节点，即number域为0的节点  */</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!p-&gt;number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;number);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们并没有销毁链表，你可以自行加上该操作。</p><hr><h4 id="数组模拟"><a href="#数组模拟" class="headerlink" title="数组模拟"></a>数组模拟</h4><blockquote><p>数组模拟方法的难点在于我们要循环使用一个线性数组，其实稍微认真思考一下，也不是很难。每当遍历到数组末尾的时候，我们就从头重新开始遍历，一旦某个人出列，就将该处的值置为0，直到剩下最后一个人。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p, *q, </span><br><span class="line">    <span class="keyword">char</span> *eq;    <span class="comment">/*  指向数组末尾  */</span></span><br><span class="line">    <span class="keyword">int</span> n, m, k, i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">if</span> ((q = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">/*  为使用的数组分配内存空间  */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        q[i] = i + <span class="number">1</span>;    <span class="comment">/*  初始化数组  */</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    eq = q + n;</span><br><span class="line">    p = q + k - <span class="number">1</span>;     <span class="comment">/*  指向开始报数的人  */</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i++ == m) &#123;</span><br><span class="line">            *p = <span class="number">0</span>;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (++p &gt;= eq)    <span class="comment">/*  到达数组末尾后，就从头重新开始遍历  */</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!*p);    <span class="comment">/*  跳过已出列的人  */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数学公式法"><a href="#数学公式法" class="headerlink" title="数学公式法"></a>数学公式法</h3><p>利用下面这个递推公式，我们就能得到我们想要的结果。</p><script type="math/tex; mode=display">f(N,M)=(f(N-1,M)+M)modN</script><p>$f(N, M)$表示：N个人报数，杀掉报M的那个人，最终胜利者的编号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n;    <span class="comment">/* 总人数 */</span></span><br><span class="line">    <span class="keyword">int</span> m;    <span class="comment">/* 数到m出列 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        p = (p + m) % i;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"winner is %d\n"</span>, p + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们先看一下对该问题的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下的贪吃蛇小游戏</title>
    <link href="https://yaoer.me/2018/10/25/snake/"/>
    <id>https://yaoer.me/2018/10/25/snake/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2018-10-25T05:27:34.692Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主要设计思路"><a href="#主要设计思路" class="headerlink" title="主要设计思路"></a>主要设计思路</h3><blockquote><ul><li>主要数据结构：单链表</li><li>蛇的移动：每次在蛇头添加2个节点，在蛇尾删除2个节点</li><li>蛇的转向：通过一组方向坐标与蛇的位置坐标的运算来实现转向</li><li>蛇吃食物：只在蛇头添加2个节点，而不必在蛇尾删除2个节点</li><li>蛇的死亡：撞上边界或自身</li></ul></blockquote><a id="more"></a><p>然后给出实现中的一点说明：</p><blockquote><ul><li>之所以每次操作2个节点，是因为我所绘制的游戏界面比较大，这样能使游戏效果更明显点</li><li>而且为了当蛇身比较长的时候，对蛇身的折叠缠绕能够明显的区分开，而不是混成一团，我们让蛇每次移动2行或2列</li><li>还有一个需要注意的点：当你给普通字符着色后，它所对应的一个整形值就不再是原来的值了，它会在原来的基础上附加上颜色属性。所以不同颜色的相同字符其实是不同的，不能一概视之</li></ul></blockquote><p>游戏的核心逻辑：</p><blockquote><p><strong><em><font color="red">正常情况下，程序一直处于监听键盘的状态，但一旦有信号中断(这里是超时)产生，就转而去执行display_snake函数；执行完毕后，又处于监听键盘的状态… 直至程序运行结束。</font></em></strong>(这里用到了一点简单的signal方面的知识)。这个机制应该是整个程序设计的难点了，我也是在参考了许多博客，再加上一段时间的思考之后，才想明白的。</p></blockquote><p>还有一点就是，你得确保你的电脑上有curses库，绝大多数unix系统应该会自带curses库，如果没有的话，那么你得自行安装，安装方法很简单，网上也有很多，这里就不多说了。</p><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY  150    <span class="comment">/*  设置延时  */</span>                                                                                                            </span></span><br><span class="line"><span class="comment">/*  蛇的活动地图的大小  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW    (LINES - 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COL    (COLS - 24) </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">snake</span> &#123;</span>     <span class="comment">/*  蛇身节点  */</span></span><br><span class="line">    <span class="keyword">int</span> sx;       <span class="comment">/*  行坐标  */</span></span><br><span class="line">    <span class="keyword">int</span> sy;       <span class="comment">/*  列坐标  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snake</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Snake;</span><br></pre></td></tr></table></figure><blockquote><p>主函数很简单。<code>(^_^)a</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Snake *head, *tail;   <span class="comment">/*  蛇头、蛇尾  */</span></span><br><span class="line"><span class="keyword">int</span> dx, dy;           <span class="comment">/*  一组方向坐标  */</span></span><br><span class="line"><span class="keyword">int</span> score;            <span class="comment">/*  得分  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    signal(SIGALRM, display_snake);</span><br><span class="line">    get_keyboard();     <span class="comment">/*  监听键盘  */</span></span><br><span class="line">    endwin();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  init函数：游戏初始化  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initscr();   <span class="comment">/*  初始化curses  */</span></span><br><span class="line">    start_color();  <span class="comment">/*  初始化颜色表  */</span></span><br><span class="line">    set_color();    <span class="comment">/*  设置颜色  */</span></span><br><span class="line">    box(stdscr, ACS_VLINE, ACS_HLINE);   <span class="comment">/*  绘制一个同物理终端大小相同的窗口  */</span></span><br><span class="line">    noecho();    <span class="comment">/*  关闭键入字符的回显  */</span></span><br><span class="line">    cbreak();    <span class="comment">/*  字符一键入，直接传递给程序  */</span></span><br><span class="line">    curs_set(<span class="number">0</span>);    <span class="comment">/*  隐藏光标  */</span></span><br><span class="line">    keypad(stdscr, <span class="literal">true</span>);    <span class="comment">/*  开启逻辑键  */</span></span><br><span class="line">    draw_initscr();</span><br><span class="line">    draw_map();</span><br><span class="line">    creat_snake();</span><br><span class="line">    creat_food();</span><br><span class="line">    display_score();</span><br><span class="line">    refresh();   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  display_snake函数：游戏的主要控制逻辑  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_snake</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_crash())</span><br><span class="line">        over();</span><br><span class="line">    <span class="keyword">if</span> (is_eat_food()) &#123;</span><br><span class="line">        add_snake();</span><br><span class="line">        creat_food();</span><br><span class="line">        display_score();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        add_snake();</span><br><span class="line">        del_snake();</span><br><span class="line">    &#125;</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  over函数：游戏结束  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">over</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    draw_overscr();</span><br><span class="line">    endwin();    <span class="comment">/*  结束调用curses  */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面是与蛇的移动有关的代码，也是游戏的核心部分代码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  creat_snake函数：初始化蛇身  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_snake</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(head = tail = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Snake)));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    srand(clock());   <span class="comment">/*  以当前挂钟时间作随机种子数  */</span></span><br><span class="line">    <span class="keyword">while</span> ((head-&gt;sx = rand() % (ROW - <span class="number">3</span>) + <span class="number">3</span>) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">while</span> ((head-&gt;sy = rand() % (COL - <span class="number">4</span>) + <span class="number">4</span>) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">    mvaddch(head-&gt;sx, head-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  creat_food函数：初始化食物  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_food</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    srand(clock());</span><br><span class="line">    <span class="keyword">while</span> ((i = rand() % (ROW - <span class="number">3</span>) + <span class="number">3</span>) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">while</span> ((j = rand() % (COL - <span class="number">4</span>) + <span class="number">4</span>) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    move(i, j);</span><br><span class="line">    <span class="keyword">if</span> (inch() == <span class="number">288</span>)    <span class="comment">/*  食物不能覆盖蛇身  */</span></span><br><span class="line">        creat_food();</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">2</span>));</span><br><span class="line">    addch(<span class="string">' '</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  add_snake函数：在蛇头增加2个节点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_snake</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Snake *p, *q;</span><br><span class="line"></span><br><span class="line">    assert(p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Snake)));</span><br><span class="line">    assert(q = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Snake)));</span><br><span class="line">    head-&gt;next = p;</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">    p-&gt;sx = head-&gt;sx + dx;</span><br><span class="line">    p-&gt;sy = head-&gt;sy + dy;</span><br><span class="line">    mvaddch(p-&gt;sx, p-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    q-&gt;sx = p-&gt;sx + dx;</span><br><span class="line">    q-&gt;sy = p-&gt;sy + dy;</span><br><span class="line">    mvaddch(q-&gt;sx, q-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">    head = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  del_snake函数：在蛇尾删除2个节点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_snake</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Snake *tmp;</span><br><span class="line"></span><br><span class="line">    mvaddch(tail-&gt;sx, tail-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    mvaddch(tail-&gt;next-&gt;sx, tail-&gt;next-&gt;sy, <span class="string">' '</span>);</span><br><span class="line">    tmp = tail-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(tail-&gt;next);</span><br><span class="line">    <span class="built_in">free</span>(tail);</span><br><span class="line">    tail = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  is_eat_food函数：判断是否吃到食物  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_eat_food</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inch() == <span class="number">544</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  is_crash函数：判断是否撞到障碍物  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_crash</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    move(head-&gt;sx + <span class="number">2</span> * dx, head-&gt;sy + <span class="number">2</span> * dy);</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;sx &lt;= <span class="number">2</span> || head-&gt;sx &gt;= ROW + <span class="number">1</span>|| </span><br><span class="line">        head-&gt;sy &lt;= <span class="number">3</span> || head-&gt;sy &gt;= COL + <span class="number">1</span>)   <span class="comment">/*  撞到边界  */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (inch() == <span class="number">288</span>)   <span class="comment">/*  撞到自身  */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  get_keyboard函数：监听键盘  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_keyboard</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((c = getch()) != <span class="string">'q'</span>) &#123;   <span class="comment">/*  按q键可以退出游戏  */</span></span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> KEY_UP:</span><br><span class="line">            dx = <span class="number">-1</span>; dy = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KEY_DOWN:</span><br><span class="line">            dx = <span class="number">1</span>; dy = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KEY_LEFT:</span><br><span class="line">            dx = <span class="number">0</span>; dy = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KEY_RIGHT:</span><br><span class="line">            dx = <span class="number">0</span>; dy = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_snake();</span><br><span class="line">        set_ticker(DELAY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  lock_snake函数：防止蛇身反向移动  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_snake</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lx, ly;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dx &amp;&amp; dx + lx == <span class="number">0</span>)</span><br><span class="line">        dx = lx;</span><br><span class="line">    <span class="keyword">if</span> (dy &amp;&amp; dy + ly == <span class="number">0</span>)</span><br><span class="line">        dy = ly;</span><br><span class="line">    lx = dx;</span><br><span class="line">    ly = dy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>游戏界面的绘制就是个细心活喽，大家按自己的喜好绘制就可以了，说实话，这个界面我是尝试了好多好多次，挺无聊的。<code>^o^(逃</code></p><p>注意：这个界面是按我的终端大小绘制的，你应该根据你的终端大小作一点调整。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  draw_initscr函数：绘制游戏开始界面  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_initscr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    attron(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = COLS / <span class="number">2</span> - <span class="number">20</span>; i &lt;= COLS / <span class="number">2</span> + <span class="number">20</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        mvaddch(LINES / <span class="number">2</span> - <span class="number">4</span>, i, <span class="string">'@'</span>);</span><br><span class="line">        mvaddch(LINES / <span class="number">2</span> + <span class="number">6</span>, i, <span class="string">'@'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = LINES / <span class="number">2</span> - <span class="number">3</span>; i &lt;= LINES / <span class="number">2</span> + <span class="number">5</span>; i++) &#123;</span><br><span class="line">        mvaddch(i, COLS / <span class="number">2</span> - <span class="number">22</span>, <span class="string">'@'</span>);</span><br><span class="line">        mvaddch(i, COLS / <span class="number">2</span> + <span class="number">22</span>, <span class="string">'@'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">8</span>, COLS / <span class="number">2</span> - <span class="number">13</span>, <span class="string">"Press any key to continue..."</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> - <span class="number">2</span>, COLS / <span class="number">2</span> - <span class="number">8</span>, <span class="string">"Welcome to snake"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> - <span class="number">1</span>, COLS / <span class="number">2</span> - <span class="number">10</span>, <span class="string">"emmmmmmmmm, however,"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span>, COLS / <span class="number">2</span> - <span class="number">20</span>, <span class="string">"now that you are here, you must be greedy!"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">1</span>, COLS / <span class="number">2</span> - <span class="number">11</span>, <span class="string">"~~o~~o~~o~~o~~o~~o~~o~~"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">2</span>, COLS / <span class="number">2</span> - <span class="number">5</span>, <span class="string">"Game Rules:"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">3</span>, COLS / <span class="number">2</span> - <span class="number">18</span>, <span class="string">"1. use direciton keys to move snake"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">4</span>, COLS / <span class="number">2</span> - <span class="number">18</span>, <span class="string">"2. snake is green space, food is red"</span>);</span><br><span class="line">    getch();</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    refresh();</span><br><span class="line">    clear();   <span class="comment">/*  清屏  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  draw_map函数：绘制游戏地图  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_map</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    attron(COLOR_PAIR(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; COLS - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        mvaddch(<span class="number">2</span>, i, <span class="string">' '</span>);</span><br><span class="line">        mvaddch(LINES - <span class="number">2</span>, i, <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; LINES - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        mvaddch(i, <span class="number">3</span>, <span class="string">' '</span>);</span><br><span class="line">        mvaddch(i, COL + <span class="number">1</span>, <span class="string">' '</span>);</span><br><span class="line">        mvaddch(i, COLS - <span class="number">3</span>, <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">3</span>));</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    mvaddstr(<span class="number">10</span>, <span class="number">132</span>, <span class="string">"Your Score:"</span>);</span><br><span class="line">    mvaddstr(<span class="number">12</span>, <span class="number">130</span>, <span class="string">"^0^ smiling ^0^"</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  draw_overscr函数：绘制结束界面  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_overscr</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    clear();</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = COLS / <span class="number">2</span> - <span class="number">16</span>; i &lt;= COLS / <span class="number">2</span> + <span class="number">16</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        mvaddch(LINES / <span class="number">2</span> - <span class="number">4</span>, i, <span class="string">'@'</span>);</span><br><span class="line">        mvaddch(LINES / <span class="number">2</span> + <span class="number">3</span>, i, <span class="string">'@'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = LINES / <span class="number">2</span> - <span class="number">3</span>; i &lt;= LINES / <span class="number">2</span> + <span class="number">2</span>; i++) &#123;</span><br><span class="line">        mvaddch(i, COLS / <span class="number">2</span> - <span class="number">18</span>, <span class="string">'@'</span>);</span><br><span class="line">        mvaddch(i, COLS / <span class="number">2</span> + <span class="number">18</span>, <span class="string">'@'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> + <span class="number">5</span>, COLS / <span class="number">2</span> - <span class="number">13</span>, <span class="string">"Press any key to continue..."</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">4</span>));</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span> - <span class="number">1</span>, COLS / <span class="number">2</span> - <span class="number">13</span>, <span class="string">"I'm sorry, the game is over"</span>);</span><br><span class="line">    mvaddstr(LINES / <span class="number">2</span>, COLS / <span class="number">2</span> - <span class="number">9</span>, <span class="string">"But expect you back"</span>);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    refresh();</span><br><span class="line">    getch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  display_score函数：显示当前得分  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_score</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    attron(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">    move(<span class="number">11</span>, <span class="number">136</span>);</span><br><span class="line">    printw(<span class="string">"%d"</span>, score++);</span><br><span class="line">    attroff(COLOR_PAIR(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  set_color函数：设置颜色  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_color</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_pair(<span class="number">1</span>, COLOR_GREEN, COLOR_GREEN);</span><br><span class="line">    init_pair(<span class="number">2</span>, COLOR_RED, COLOR_RED);</span><br><span class="line">    init_pair(<span class="number">3</span>, COLOR_WHITE, COLOR_WHITE);</span><br><span class="line">    init_pair(<span class="number">4</span>, COLOR_YELLOW, COLOR_BLACK);</span><br><span class="line">    init_pair(<span class="number">5</span>, COLOR_RED, COLOR_BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  set_ticker函数：设置间隔计时器(ms)  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_ticker</span><span class="params">(<span class="keyword">int</span> n_msecs)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_timeset</span>;</span>  </span><br><span class="line">    <span class="keyword">long</span> n_sec, n_usecs;  </span><br><span class="line">  </span><br><span class="line">    n_sec = n_msecs / <span class="number">1000</span>;      </span><br><span class="line">    n_usecs = (n_msecs % <span class="number">1000</span>) * <span class="number">1000L</span>;      </span><br><span class="line">    </span><br><span class="line">    new_timeset.it_interval.tv_sec = n_sec;   <span class="comment">/*  设置初始间隔  */</span>  </span><br><span class="line">    new_timeset.it_interval.tv_usec = n_usecs;  </span><br><span class="line"></span><br><span class="line">    new_timeset.it_value.tv_sec = n_sec;      <span class="comment">/*  设置重复间隔  */</span>  </span><br><span class="line">    new_timeset.it_value.tv_usec = n_usecs;  </span><br><span class="line">    <span class="keyword">return</span> setitimer(ITIMER_REAL, &amp;new_timeset, <span class="literal">NULL</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后说明一点：当你编译运行的时候需要链接至curses库哦，在编译命令后加上<code>-lcurses</code>就可以了</p><p>emmm，然后呢，希望大家能多多提出建议<code>^o^</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主要设计思路&quot;&gt;&lt;a href=&quot;#主要设计思路&quot; class=&quot;headerlink&quot; title=&quot;主要设计思路&quot;&gt;&lt;/a&gt;主要设计思路&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;主要数据结构：单链表&lt;/li&gt;
&lt;li&gt;蛇的移动：每次在蛇头添加2个节点，在蛇尾删除2个节点&lt;/li&gt;
&lt;li&gt;蛇的转向：通过一组方向坐标与蛇的位置坐标的运算来实现转向&lt;/li&gt;
&lt;li&gt;蛇吃食物：只在蛇头添加2个节点，而不必在蛇尾删除2个节点&lt;/li&gt;
&lt;li&gt;蛇的死亡：撞上边界或自身&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>数组与指针那点事</title>
    <link href="https://yaoer.me/2018/10/23/arr_pointer/"/>
    <id>https://yaoer.me/2018/10/23/arr_pointer/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-10-24T05:31:15.071Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><p>说起数组名？绝大多数初学者是感到非常疑惑的，甚至哪怕是学习了好几年自以为懂的人，恐怕也不能够说得明明白白、清清楚楚。那么，它到底是个什么东西呢？</p><a id="more"></a><p><strong><em><font color="red">首先，我想先声明一点：数组名绝不是指针，也并不是常量指针。</font></em></strong></p><p>我们先以一个简单的赋值为例，说明一下<code>左值</code>和<code>右值</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y;</span><br><span class="line">这个语句的含义是：把y中的值放入x所代表的地址中去</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>左值</th><th>右值</th></tr></thead><tbody><tr><td>在这个上下文环境里，符号x的含义是x所代表的地址</td><td>在这个上下文环境中，符号y的含义是y所代表的地址中的内容</td></tr><tr><td>在编译时可知，表示存储结果的地方，即内存中的位置</td><td>直到运行时才可知，表示的是一个“值”</td></tr></tbody></table></div><p>这时就出现了一个奇怪的现象：我们都知道，只有变量才可以作为左值，而数组名是不能作为左值的。那么数组名不是变量的话，是什么呢？</p><p>如果我们查看一下对应的汇编代码，结果是显而易见的。我们会发现，汇编代码里并没有出现数组名这个东西，<strong><em>数组名只是一个符号而已，标识数组在内存中的位置</em></strong>。但是在某些情况下，编译器会对它进行隐式的转换。<strong><em><font color="red">或者我们可以像指针类型一样，将数组名理解为一个数据类型——数组类型，表示一段连续的内存空间。</font></em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">a表示：<span class="keyword">int</span> [<span class="number">5</span>]，即可以存储<span class="number">5</span>个整形元素的一段连续的内存空间。</span><br></pre></td></tr></table></figure><p>我们看下面这样一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;b;</span><br><span class="line"></span><br><span class="line">    a = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用clang编译的话，会报如下错误</p><p><code>error: array type &#39;int [2]&#39; is not assignable</code></p><hr><blockquote><ul><li>sizeof(a)，返回整个数组的长度。</li><li>&amp;a，得到一个指向整个数组的指针，即int (*)[]。</li><li>在函数参数中，数组名被转换为一个普通的指针</li><li><font color="red">在除此之外的其他情况下，</font><font color="green">数组名将被隐式转换为一个指向数组首元素的常量指针。</font></li></ul></blockquote><p>有效的指针运算方式有如下几种：</p><blockquote><ul><li>相同类型指针之间的赋值运算。</li><li>指针同整数间的加法或减法运算。</li><li>指向相同数组中元素的两个指针间的减法或比较运算。</li><li>将指针赋为0或指针与0之间的比较运算。</li><li>最后注意一点：(void *类型指针可以与其他类型指针混用）</li></ul></blockquote><hr><h3 id="数组和指针的区别"><a href="#数组和指针的区别" class="headerlink" title="数组和指针的区别"></a>数组和指针的区别</h3><p>我们先看一下这样一组声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> *x;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> y[];</span><br></pre></td></tr></table></figure><p>第一条语句声明x是一个指向int类型的指针；第二条语句声明y是一个int类型的数组，长度尚未确定，<strong><em>其存储在别处定义。</em></strong></p><p>那么，什么是声明，什么是定义呢？</p><div class="table-container"><table><thead><tr><th>声明</th><th>定义</th></tr></thead><tbody><tr><td>可以出现在多个地方</td><td>只能出现在一个地方</td></tr><tr><td>描述对象的类型，用于指代其他地方定义的对象</td><td>确定对象的类型并为之分配内存</td></tr></tbody></table></div><p>两者的主要区别在于：</p><blockquote><ul><li>声明：它所说明的并非自身，而是描述其他地方创建的对象。</li><li>定义：它为对象分配内存。</li></ul></blockquote><p><strong><em>总而言之，定义是声明的一个子集。</em></strong></p><p><strong><em>extern对象声明只是告诉编译器对象的类型和名字，对象的内存分配则在别处进行。</em></strong></p><hr><p>我们再看一个这样的问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file <span class="number">1</span>: <span class="keyword">int</span> logo[<span class="number">100</span>];</span><br><span class="line">file <span class="number">2</span>: <span class="keyword">extern</span> <span class="keyword">int</span> *logo;</span><br></pre></td></tr></table></figure><p>很明显，在file 2中的写法是错误的。正确写法应当是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file <span class="number">2</span>: <span class="keyword">extern</span> <span class="keyword">int</span> logo[]; <span class="keyword">or</span> <span class="keyword">extern</span> <span class="keyword">int</span> logo[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p>可能有人会问：这有什么错误？数组和指针不是可以互换吗？答案是<font color="red">数组下标<strong><em>表达式</em></strong>总是可以改写为指针加偏移量的表达式。</font>而且也确实存在一种数组和指针完全相同的上下文环境，但并不是所有情况下都是如此。</p><p><strong>[k&amp;r]</strong>第二版[99]中有相关的描述：<font color="red">作为函数定义的形式参数，</font><strong>char s[]</strong>和<strong>char *s</strong>是等价的。</p><hr><h3 id="数组和指针分别如何访问的？"><a href="#数组和指针分别如何访问的？" class="headerlink" title="数组和指针分别如何访问的？"></a>数组和指针分别如何访问的？</h3><blockquote><ul><li><font color="red">编译器为每个变量分配一个地址，这个地址在<strong>编译时</strong>可知，</font>而且该变量在运行时一直保存于该地址。<font color="red">相反，存储于变量中的值只有在<strong>运行时</strong>才可知。</font>如果需要用到变量中存储的值，编译器就发出指令从指定地址读入变量值并将它放入寄存器中。</li><li>这里的关键之处在于：<strong><em>如果编译器需要一个地址（可能还需要加上偏移量）来执行某种操作，它就可以直接进行操作，并不需要额外的指令首先取得具体的地址。相反，对于指针，必须在运行是取得它的当前值，然后才能对它进行解引用操作。</em></strong></li></ul></blockquote><h4 id="对数组下标的引用"><a href="#对数组下标的引用" class="headerlink" title="对数组下标的引用"></a>对数组下标的引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = <span class="string">"hello"</span>;</span><br><span class="line">c = s[i];</span><br></pre></td></tr></table></figure><p>假设编译器符号表中有一个地址100</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">取出i的值，将它与100相加</span><br><span class="line">取出地址（100 + i）中的内容</span><br></pre></td></tr></table></figure><p>这就是为什么<strong>extern int logo[100]</strong> 与<strong>extern int logo[]</strong> 等价的原因。这两个声明都提示logo是一个数组，也就是一个内存地址。<strong><em>编译器并不需要知道数组有多长，因为它只产生偏离起始地址的偏移地址</em></strong>（是否会越界访问取决于程序员本身，编译器并不会进行这样的检查）。访问数组中的一个字符，只需简单地将logo的地址加上下标即可，需要的字符就在该地址中。</p><hr><h4 id="对指针的引用"><a href="#对指针的引用" class="headerlink" title="对指针的引用"></a>对指针的引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br><span class="line">c = *p;</span><br></pre></td></tr></table></figure><p>假设编译器符号表中有一个地址1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">取出地址1024中的内容，假设是5076</span><br><span class="line">取出地址5076中的内容，就是&apos;h&apos;</span><br></pre></td></tr></table></figure><hr><h4 id="如果定义为指针，却以数组下标方式引用，会发生什么？"><a href="#如果定义为指针，却以数组下标方式引用，会发生什么？" class="headerlink" title="如果定义为指针，却以数组下标方式引用，会发生什么？"></a>如果定义为指针，却以数组下标方式引用，会发生什么？</h4><p>我们都知道，数组的引用是对内存的直接引用，而指针是对内存执行间接引用的。下面我们来分析一下对一个指针执行直接引用操作，会发生什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br><span class="line">c = p[i];</span><br></pre></td></tr></table></figure><p>假设编译器符号表中有一个p，它的地址为1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">取出地址1024中的内容，假设为5076</span><br><span class="line">取得i的值，并将它与5076相加</span><br><span class="line">取出地址（5076 + i）中的内容</span><br></pre></td></tr></table></figure><p>可见，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>; ... p[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello"</span>; ... a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>这两种情况下，都可以取得字符 <strong>‘e’</strong>，但两者的途径非常不一样。</p><p>当书写了<strong>extern char *p</strong>，然后以 <strong>p[1]</strong> 的方式来引用其中的元素时，其实质是对数组下标的引用和对指针的引用两种访问方式的组合。</p><p>总结一下上面的访问过程：</p><blockquote><ul><li>取得符号表中p的地址，提取存储于此处的指针</li><li>把下标所表示的偏移量与指针的值相加，产生一个偏移地址</li><li>取得该地址中的内容</li></ul></blockquote><p><strong><em>如果把p声明为一个指针，那么不管p原先的定义是指针还是数组，都会按照上面所示的三个步骤进行操作，但只有当p原来定义为指针时这个方法才是正确的。</em></strong></p><hr><h4 id="定义为数组，却以指针的方式引用，会发生什么？"><a href="#定义为数组，却以指针的方式引用，会发生什么？" class="headerlink" title="定义为数组，却以指针的方式引用，会发生什么？"></a>定义为数组，却以指针的方式引用，会发生什么？</h4><p>即下列情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file <span class="number">1</span>: <span class="keyword">char</span> p[<span class="number">10</span>];</span><br><span class="line">file <span class="number">2</span>: <span class="keyword">extern</span> <span class="keyword">char</span> *p;</span><br></pre></td></tr></table></figure><p>当以 <strong>p[i]</strong> 的方式访问数组中的内容时：<strong><em>首先，我们取得符号表中p的地址，提取该地址中的内容，很明显会是一个字符。但按照上面的方法，编译器却会把它当作一个地址，把ascii字符解释为地址显然是驴头不对马嘴的。如果真在程序中这样做的话，很可能会污染程序地址空间中的内容，并在以后出现莫名其妙的错误。</em></strong></p><hr><h3 id="数组和指针在什么情况下是相同的"><a href="#数组和指针在什么情况下是相同的" class="headerlink" title="数组和指针在什么情况下是相同的"></a>数组和指针在什么情况下是相同的</h3><p>在实际应用中，数组和指针可以互换的情况要比两者不可互换的情况更为常见。</p><blockquote><ul><li>数组<ul><li>声明<ul><li>extern，如extern char a[]; 不能改写成指针的形式</li><li>定义，如char a[10]; 不能改写成指针的形式</li><li>函数参数，你可以随自己喜欢，选择数组或指针形式</li></ul></li><li>在表达式中使用<ul><li>如c = a[i]; 你可以随自己喜欢，选择数组或指针形式</li></ul></li></ul></li></ul></blockquote><p><strong><em>所有作为函数参数的数组名总是可以通过编译器转换为指针。在其他情况下，数组的声明就是数组，指针的声明就是指针，两者不能混淆。但在使用数组时，两者是可以互换的。</em></strong></p><hr><h3 id="三个规则"><a href="#三个规则" class="headerlink" title="三个规则"></a>三个规则</h3><h4 id="在表达式中，对数组的引用总是可以改写为对指针的引用"><a href="#在表达式中，对数组的引用总是可以改写为对指针的引用" class="headerlink" title="在表达式中，对数组的引用总是可以改写为对指针的引用"></a>在表达式中，对数组的引用总是可以改写为对指针的引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], *p, i = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>我们可以通过以下任何一种方式访问a[i]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = a; p[i];</span><br><span class="line">p = a; *(p + i);</span><br><span class="line">p = a + i; *p;</span><br></pre></td></tr></table></figure><p>事实上，可以采用的方法更多。对数组的引用a[i]在编译时总是被编译器改写为*(a + i)的形式。C标准要求编译器必须具有这个概念性的行为。也许遵循这个规则的捷径就是记住<strong><em><font color="red">[] 表示一个取下标运算符，就像 + 表示加法运算符一样。</font></em></strong></p><p>取下标运算符取一个整数和一个指向T类型的指针，所产生的结果类型是T，一个在表达式中的数组名就变成了一个指针（除过本文开始描述的几种特殊情况）。你只要记住：在表达式中，指针和数组是可以互换的，因为它们在编译器中的最终形式都是指针，而且都可以进行取下标操作。<strong><em>就像加法一样，取下标操作符的操作数是可以互换的，</em></strong>即<font color="red">a[5] 和 5[a] 这两种情况下都是正确的。</font>第二种情况除了能把新手搞晕以外，实在没什么实际意义。</p><blockquote><p>编译器自动把下标值的步长调整为数组元素的大小，在对地址进行加法操作之前，编译器会负责计算每次增加的步长，这也就是指针之所以有类型限制的原因所在。</p></blockquote><hr><h4 id="C语言把数组下标作为指针的偏移量"><a href="#C语言把数组下标作为指针的偏移量" class="headerlink" title="C语言把数组下标作为指针的偏移量"></a>C语言把数组下标作为指针的偏移量</h4><p><font color="red">在通常情况下，使用指针比使用数组”更有效率“这个说法是错误的。</font>现代的编译器常常会对代码进行优化，两种访问方式所产生的代码不具有显著的差别。但不管怎样，数组下标是定义在指针的基础上的，所以编译器常常将它转换为更有效率的指针表达式形式。</p><p><strong><em>C语言把数组下标改写成指针加偏移量的形式的根本原因是：<font color="red">指针和偏移量是底层硬件所使用的基本模型。</font></em></strong></p><hr><h4 id="作为函数参数的数组名等同于指针"><a href="#作为函数参数的数组名等同于指针" class="headerlink" title="作为函数参数的数组名等同于指针"></a>作为函数参数的数组名等同于指针</h4><p>我们首先解释两个术语：</p><blockquote><ul><li>实参：在实际调用一个函数时传递给它的值</li><li>形参：它是一个变量，在函数定义或函数声明中定义</li></ul></blockquote><p>当用一个数组名作为参数时，由于效率原因，编译器只向该函数传递数组的地址，而不是整个数组的拷贝。</p><hr><h3 id="数组形参是如何被引用的？"><a href="#数组形参是如何被引用的？" class="headerlink" title="数组形参是如何被引用的？"></a>数组形参是如何被引用的？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun(<span class="keyword">char</span> p[]);</span><br><span class="line">fun(<span class="keyword">char</span> *p);</span><br></pre></td></tr></table></figure><p>假设编译器符号表显示p可以取地址，从堆栈指针偏移一定位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从堆栈指针偏移一定位置的地方找到函数的活动记录（栈桢），取出实参，假设为1024</span><br><span class="line">取得i的值，并与1024相加</span><br><span class="line">取出地址（1024 + i）中的内容</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br>[C专家编程][Peter Van Der Linden]</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组名&quot;&gt;&lt;a href=&quot;#数组名&quot; class=&quot;headerlink&quot; title=&quot;数组名&quot;&gt;&lt;/a&gt;数组名&lt;/h3&gt;&lt;p&gt;说起数组名？绝大多数初学者是感到非常疑惑的，甚至哪怕是学习了好几年自以为懂的人，恐怕也不能够说得明明白白、清清楚楚。那么，它到底是个什么东西呢？&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>栈的应用之表达式转换</title>
    <link href="https://yaoer.me/2018/10/23/expr/"/>
    <id>https://yaoer.me/2018/10/23/expr/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-11-09T05:35:21.892Z</updated>
    
    <content type="html"><![CDATA[<h3 id="中缀转后缀表达式"><a href="#中缀转后缀表达式" class="headerlink" title="中缀转后缀表达式"></a>中缀转后缀表达式</h3><p>实现的方法很简单：就是用栈来实现。</p><p>具体思路如下：</p><blockquote><ul><li>如果是数，我们就直接输出</li><li>是操作符，我们就弹出栈中比它优先级更高的操作符，然后再将它入栈</li><li>是’ ( ‘，直接入栈</li><li>是 ’ ) ‘ ，我们就弹出栈中 ‘ ( ‘ 之后的所有操作符</li><li>遇见 ‘ - ‘ 时，要判断它是负号还是减号</li><li>遇见 ’ \n ‘ ，弹出栈中所有的操作符</li></ul></blockquote><a id="more"></a><p>为了清晰美观起见，我们在输出的后缀表达式中的每个运算符或操作数之间加上了一个空格</p><p>下面是代码，都有很清晰的注释：</p><blockquote><p>首先是主函数，控制整个转换过程，当然也可以用一个函数来实现，不过这里是为了说明问题，没有必要那样。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  将中缀表达式转换为后缀表达式  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) || c == <span class="string">'.'</span>) &#123;    <span class="comment">/*  是数，就直接输出  */</span></span><br><span class="line">            <span class="built_in">putchar</span>(c);</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c = getchar()) || c == <span class="string">'.'</span>)</span><br><span class="line">                <span class="built_in">putchar</span>(c);</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">            ungetc(c, <span class="built_in">stdin</span>);     <span class="comment">/*  将多读入的字符压回到输入中  */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op_prior(c) || c == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isempty() &amp;&amp; c != <span class="string">'-'</span>)</span><br><span class="line">                push(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;     <span class="comment">/*  遇见')'，弹出栈中'('之后的所有运算符  */</span></span><br><span class="line">                <span class="keyword">while</span> (!isempty() &amp;&amp; top() != <span class="string">'('</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c "</span>, pop());</span><br><span class="line">                <span class="keyword">if</span> (!isempty())</span><br><span class="line">                    pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;     <span class="comment">/*  判断'-'是负号还是减号  */</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c = getchar())) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"-%c"</span>, c);</span><br><span class="line">                        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c = getchar()) || c == <span class="string">'.'</span>)</span><br><span class="line">                            <span class="built_in">putchar</span>(c);</span><br><span class="line">                        <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">                        ungetc(c, <span class="built_in">stdin</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ungetc(c, <span class="built_in">stdin</span>);</span><br><span class="line">                        c = <span class="string">'-'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;     <span class="comment">/*  栈顶运算符的优先级应当低于当前读入的运算符的优先级  */</span></span><br><span class="line">                <span class="keyword">while</span> (!isempty() &amp;&amp; top() != <span class="string">'('</span> &amp;&amp; op_prior(top()) &gt;= op_prior(c))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c "</span>, pop());</span><br><span class="line">                push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;    <span class="comment">/*  遇见换行符时，弹出栈中所有的运算符  */</span></span><br><span class="line">            <span class="keyword">while</span> (!isempty())</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c "</span>, pop());</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于如何返回对应操作符的优先级，我们可以用简单的数字来表示操作符的优先级，如果你想要实现更多的功能，你可以直接在<strong>op_prior</strong>函数中添加更多的操作符。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  op_prior函数：返回对应运算符的优先级  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_prior</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后便是所用到的主要的数据结构——栈了，这里很容易想到的便是用数组来实现堆栈，而非链表。原因也很简单： <strong><em><font color="red">在每一时刻，栈中的操作符数量总不会太多，栈空间用尽的可能性非常小。</font></em></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val[MAXVAL];    <span class="comment">/*  值栈  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;    <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull())</span><br><span class="line">        val[++sp] = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp--];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://github.com/yaomer/pictures/blob/master/v5.png?raw=true" alt=""></p><hr><h3 id="后缀转中缀表达式"><a href="#后缀转中缀表达式" class="headerlink" title="后缀转中缀表达式"></a>后缀转中缀表达式</h3><p>同样是用栈来实现的，有点类似于计算后缀表达式，但具体过程还是有点不同的。实现思路如下：</p><blockquote><ul><li>如果是数，就将它压入栈中</li><li>如果是运算符，就弹出对应数目的操作数，<font color="red">然而在这里我们并不计算该表达式，而是将它整个压入到栈中</font></li><li>我们都知道后缀表达式不存在优先级问题，但中缀表达式是需要考虑优先级的，因此，<strong><em>在转换过程中，我们需要在恰当的地方加上括号来保证运算过程的正确性</em></strong></li><li>对于如何加括号的问题，我是这么想的：例如中缀表达式 <strong>a  *  (b  +  c)</strong> 转换为后缀是 <strong>a  b  c  +  *</strong> ，当我们将 <strong>a  b  c  +  *</strong> 转换回去的时候就需要在  <strong>b  +  c</strong> 外面加上括号。<strong><em>如果当前运算符的优先级比上一个运算符的优先级要高，我们就给栈顶的两个子表达式加上括号。</em></strong></li><li>最后我们弹出栈顶表达式即可</li></ul></blockquote><p>思路大概就是这样，下面我会结合代码详细说明一下。</p><blockquote><p>同样，我们在主函数中控制整个转换过程，转换过程应当很简单。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXEXP 1000           <span class="comment">/*  输入的表达式的最大长度  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXOP  100            <span class="comment">/*  运算符或操作数的最大长度  */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER <span class="meta-string">'0'</span>            <span class="comment">/*  标识找到一个数  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  将后缀表达式转换为中缀表达式  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> lastc;</span><br><span class="line">    <span class="keyword">char</span> s[MAXEXP];      <span class="comment">/*  存储转换后的表达式  */</span></span><br><span class="line">    <span class="keyword">char</span> *op2;</span><br><span class="line"></span><br><span class="line">    lastc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = getop(s)) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (c == NUMBER)     <span class="comment">/*  是数  */</span></span><br><span class="line">            push(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op_prior(c)) &#123;     <span class="comment">/*  是运算符  */</span></span><br><span class="line">            op2 = top();</span><br><span class="line">            pop();</span><br><span class="line">            cat_exp(top(), s, op2, c, lastc);</span><br><span class="line">            push(s);</span><br><span class="line">            lastc = c;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, top());</span><br><span class="line">            pop();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>getop函数主要用于解析输入参数，将它们分解为运算符或操作数，为了后续的处理，我们也做了一些额外的工作，我们用空格将每个运算符或操作数分隔开。当然在处理输入时，它会丢弃多余的空白符，但如果你不加分隔符的话，它会帮你加上的。</li><li>op_prior函数很简单，我们在中缀转后缀表达式的过程中用到过它，这里和那里的是相同的</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  getop函数：从输入中获取下一个运算符或操作数  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getop</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, i;</span><br><span class="line">              </span><br><span class="line">    <span class="keyword">while</span> ((s[<span class="number">0</span>] = c = getchar()) == <span class="string">' '</span> || c == <span class="string">'\t'</span>)</span><br><span class="line">        ;     </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">'.'</span>) &#123;</span><br><span class="line">        s[<span class="number">1</span>] = <span class="string">' '</span>;</span><br><span class="line">        s[<span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;     <span class="comment">/*  收集操作数  */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))       </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getchar()))</span><br><span class="line">            ;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getchar()))</span><br><span class="line">            ;</span><br><span class="line">    s[i] = <span class="string">' '</span>;</span><br><span class="line">    s[++i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (c != EOF)</span><br><span class="line">        ungetc(c, <span class="built_in">stdin</span>);    <span class="comment">/*  将多读入的字符压回到输入中  */</span></span><br><span class="line">    <span class="keyword">return</span> NUMBER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  op_prior函数：返回对应运算符的优先级  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_prior</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码应该是这个程序的难点所在了</p><blockquote><p>cat_exp函数用当前读入的运算符把栈顶的两个子表达式连接起来，如同上面提到的，这里需要重点考虑的是加括号的问题，代码中注释的很详细，应当都能看得懂。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  cat_exp函数：连接两个子表达式  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat_exp</span><span class="params">(<span class="keyword">char</span> *op1, <span class="keyword">char</span> *s, <span class="keyword">char</span> *op2, <span class="keyword">int</span> c, <span class="keyword">int</span> lastc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp[MAXOP];</span><br><span class="line">    <span class="keyword">char</span> op[MAXOP];</span><br><span class="line">    <span class="keyword">char</span> opt[MAXOP];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, s);     <span class="comment">/*  先将已经生成的中缀表达式拷贝到tmp中  */</span></span><br><span class="line">    <span class="keyword">if</span> (lastc &amp;&amp; op_prior(c) &gt; op_prior(lastc)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isop(op1)) &#123;</span><br><span class="line">            cat(op, op1);</span><br><span class="line">            op1 = op;</span><br><span class="line">        &#125;        <span class="comment">/*  在可能需要加括号的地方都加上括号  */</span></span><br><span class="line">        <span class="keyword">if</span> (isop(op2)) &#123;</span><br><span class="line">            cat(opt, op2);</span><br><span class="line">            op2 = opt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     <span class="comment">/*  将新连接好的子表达式加入到已经生成的表达式中，然后拷贝回s中  */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s, op1);</span><br><span class="line">    <span class="built_in">strcat</span>(s, tmp);</span><br><span class="line">    <span class="built_in">strcat</span>(s, op2);</span><br><span class="line">    pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  cat函数：在表达式前后加上括号  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *s++ = <span class="string">'('</span>;</span><br><span class="line">    <span class="keyword">while</span> (*op != <span class="string">'\0'</span>)</span><br><span class="line">        *s++ = *op++;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">' '</span>)</span><br><span class="line">        s--;</span><br><span class="line">    *s++ = <span class="string">')'</span>;</span><br><span class="line">    *s++ = <span class="string">' '</span>;</span><br><span class="line">    *s = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isop函数：判断s中是否有运算符  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isop</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">if</span> (op_prior(*s++))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是栈的实现了，和中缀转后缀不同的是，这里是用指针栈来实现转换过程的，其实也就一普通的堆栈，没什么特别的。但其中也有几点是需要注意的：</p><blockquote><ul><li>我们需要实时为压入栈的表达式分配存储空间</li><li>不要忘记检查内存是否分配成功</li><li>出栈时记得释放内存</li></ul></blockquote><p><strong><em>为了方便起见，我这里用断言以防止使用NULL指针，即内存分配失败的情况。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *val[MAXVAL];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将字符串s压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull()) </span><br><span class="line">        assert((val[++sp] = strdup(s)));</span><br><span class="line">    <span class="keyword">else</span>           <span class="comment">/*  将s保存在某个安全的地方  */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty()) &#123;</span><br><span class="line">        <span class="built_in">free</span>(val[sp]);</span><br><span class="line">        val[sp--] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>运行结果：</p><p><img src="https://github.com/yaomer/pictures/blob/master/v6.png?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;中缀转后缀表达式&quot;&gt;&lt;a href=&quot;#中缀转后缀表达式&quot; class=&quot;headerlink&quot; title=&quot;中缀转后缀表达式&quot;&gt;&lt;/a&gt;中缀转后缀表达式&lt;/h3&gt;&lt;p&gt;实现的方法很简单：就是用栈来实现。&lt;/p&gt;
&lt;p&gt;具体思路如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果是数，我们就直接输出&lt;/li&gt;
&lt;li&gt;是操作符，我们就弹出栈中比它优先级更高的操作符，然后再将它入栈&lt;/li&gt;
&lt;li&gt;是’ ( ‘，直接入栈&lt;/li&gt;
&lt;li&gt;是 ’ ) ‘ ，我们就弹出栈中 ‘ ( ‘ 之后的所有操作符&lt;/li&gt;
&lt;li&gt;遇见 ‘ - ‘ 时，要判断它是负号还是减号&lt;/li&gt;
&lt;li&gt;遇见 ’ \n ‘ ，弹出栈中所有的操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>将Vim打造成一个C/C++IDE</title>
    <link href="https://yaoer.me/2018/10/22/vim-IDE/"/>
    <id>https://yaoer.me/2018/10/22/vim-IDE/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-27T01:46:23.968Z</updated>
    
    <content type="html"><![CDATA[<p>当你不知从哪里听过Vim的鼎鼎大名而信心满满的去安装它后，你打开Vim的界面后是这样的：什么也没有，就是一个黑框框。然后你想尝试打几个字，结果发现终端一直在嘟嘟的响。这时你的心里一定会大失所望，这都是什么啊。<br><a id="more"></a></p><p><img src="https://github.com/yaomer/pictures/blob/master/v2.png?raw=true" alt=""></p><p>但请不要就此放弃，你可以把Vim看作一匹充满野性的烈马，需要你付出许多努力去驯服它，从而让它乖乖地为你服务，成为你的好帮手。</p><p>实际上，Vim最大的特性就是它的<code>可定制性和可扩展性</code>。因此，当你与它初次相遇时，它就是一块未经打磨的璞玉，一柄未经开封的利刃。你需要自己去打磨它，磨亮它。让它成为一把编辑器中的<code>瑞士军刀</code>。真正的无愧于它编辑器之神的称号。</p><p>之后我推荐你去看Vim最好的入门教程，它只需花费你半小时不到的时间，然后就可以进入下面的打造之路了。</p><p><code>$ vimtutor</code></p><hr><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>我们写代码的基本需求就是要有一点语法高亮，最起码不能是那样的丑陋吧，然后可能还要有对应的行号等等这样一些基本的需求，然后我们写代码可能就会好受一些了。</p><p>这些基本配置包括后面提到的所有插件都需要用到一个叫做<code>.vimrc</code>的文件，顾名思义，这就是Vim的配置文件。在Unix/Linux系统中，它一般在家目录下，你可以使用<code>$ ls -a | grep &quot;.vimrc&quot;</code>命令检查一下，如果没有的话，就自己创建一个。</p><p>然后我们加入一些最简单、最基本的配置，Vim的模样就会变得不一样了，最起码是有点颜色了。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">filetype</span> <span class="keyword">on</span>           <span class="comment">" 开启文件类型检测</span></span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="keyword">on</span>.   <span class="comment">" 设置加载对应文件类型的插件              </span></span><br><span class="line"><span class="keyword">colorscheme</span> desert    <span class="comment">" 语法高亮主题</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>             <span class="comment">" 开启语法高亮</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>            <span class="comment">" 显示行号</span></span><br><span class="line"><span class="keyword">set</span> noerrorbells      <span class="comment">" 关闭出错响铃</span></span><br><span class="line"><span class="keyword">set</span> autoindent        <span class="comment">" 自动缩进</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span>           <span class="comment">" 使用C/C++的自动缩进方式</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span>         <span class="comment">" 将tab设置为4个空格</span></span><br><span class="line"><span class="keyword">set</span> expandtab         <span class="comment">" 将tab扩展为空格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>      <span class="comment">" 每一级缩进为4个空格</span></span><br></pre></td></tr></table></figure><p>然后在重新打开你的Vim，你就会感到有所惊喜了。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v1.png?raw=true" alt=""></p><p>当然这些配置只是最基本的，Vim还有许多别的有用的配置，这就要根据你自己的需要去配置了。在本文最后，我会给出我的<code>.vimrc</code>，大家可以略作参考。</p><p>然后我们正式进入主题。</p><hr><h3 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h3><p>在谈下面的内容之前，我们首先需要选择一款插件管理器，随着我们安装插件数量的增多，为了方便我们管理也为了以后更方便地安装新插件，这都是我们必须要做的。</p><p>我极力推荐大家使用<code>Plug</code>，它是一款极简主义的Vim插件管理器，与老旧的<code>Vundle</code>相比，它的最大优点是超高速并行安装。除此之外，它还可以延迟加载插件，从而加快Vim的启动速度，这个我们最后会提到的。</p><p><img src="https://raw.githubusercontent.com/junegunn/i/master/vim-plug/installer.gif" alt=""></p><p>运行如下命令安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>它的用法也很简单。首先在你的vimrc中加入以下两行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">'~/.vim/plugged'</span>)</span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure><p>如果你要安装一个插件，就<code>Plug &#39;插件名&#39;</code>，然后把这行加到那两行中间即可，之后在Vim中运行<code>:PlugInstall</code>即可自动安装。</p><p>因此，以下提到的插件我不再说明安装方法，都是以这种方式安装的。</p><hr><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><h4 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h4><p>Vim本身自带了一些语法高亮主题，这些主题文件一般在<code>/usr/share/vim/vim80/colors/</code>目录下。你可以自己分别尝试下，不过这些高亮都相对来说比较简单，对于函数、运算符之类的都无法高亮。</p><p>这里我推荐两种我非常喜欢的配色，<a href="https://github.com/crusoexia/vim-monokai" target="_blank" rel="noopener">monokai</a>和<a href="https://github.com/altercation/vim-colors-solarized" target="_blank" rel="noopener">solarized</a>。</p><p>我最先使用的是<code>monokai</code>，使用了很长一段时间，自己也折腾了很多，最近突然觉得它看起来有些不太合心意，在网上看到了<code>solarized</code>，可以说是一见钟情吧，它在色彩处理上可以说是非常优秀，而且是适用于各个平台。</p><p>要修改它们也很简单，只需修改不同语法的高亮颜色即可。</p><h4 id="语法高亮增强"><a href="#语法高亮增强" class="headerlink" title="语法高亮增强"></a>语法高亮增强</h4><p><a href="https://github.com/octol/vim-cpp-enhanced-highlight" target="_blank" rel="noopener">vim-cpp-enhanced-highlight</a>提供了对C++语法高亮的增强，比如STL中的容器和类型。除此之外，还可以高亮运算符，只不过需要简单的设置。</p><p>找到<code>c.vim</code>这个文件，取消下面这些行的注释即可。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" Operators</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>\(&lt;&lt;\|&gt;&gt;\|[-+*/%&amp;^|&lt;&gt;!=]\)=<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>&lt;&lt;\|&gt;&gt;\|&amp;&amp;\|||\|++\|--\|-&gt;<span class="comment">"</span></span><br><span class="line">" syn match cOperator"[.!~*&amp;%&lt;&gt;^|=,;?:+-]"</span><br><span class="line"><span class="string">" syn match cOperator"</span>/[^/*=]<span class="comment">"me=e-1</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>/$<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator  "</span>&amp;&amp;\|||<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>[][]<span class="comment">"</span></span><br></pre></td></tr></table></figure><h4 id="彩虹括号"><a href="#彩虹括号" class="headerlink" title="彩虹括号"></a>彩虹括号</h4><p>当代码中出现多级嵌套的时候，<a href="https://github.com/kien/rainbow_parentheses.vim" target="_blank" rel="noopener">rainbow_parentheses.vim</a>这个插件就会很有用。它可以很明显的显示出不同括号内的代码层次。</p><p>这里我上一张我修改过的代码高亮配色的图吧。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v3.png?raw=true" alt=""></p><p>不过这个插件已经很久不维护了，大家也可以看一下这个较新的插件<a href="https://github.com/luochen1990/rainbow" target="_blank" rel="noopener">rainbow</a><br>，它是对旧的插件的改进版本。</p><hr><h3 id="漂亮的状态栏"><a href="#漂亮的状态栏" class="headerlink" title="漂亮的状态栏"></a>漂亮的状态栏</h3><p>作为一名颜值党，暂且不提Vim别的功能，最起码要看来漂亮动人才行吧。那么没有一个好看的状态栏怎么行呢！而<a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener">vim-airline</a>正是这样一款优秀的状态栏插件，现在它基本上已经取代了<a href="https://github.com/powerline/powerline" target="_blank" rel="noopener">powerline</a>。</p><p>它的配色非常多，可以说是只要你想要的，应该都能找到，我这里选出一个我觉得漂亮的吧。</p><p><img src="https://user-images.githubusercontent.com/9622/45275524-52f45c00-b48b-11e8-8b83-a66240b10747.gif" alt=""></p><p>更多的大家自己去看吧。</p><p>还有一个需要顺带下载的插件是它的主题<a href="https://github.com/vim-airline/vim-airline-themes" target="_blank" rel="noopener">vim-airline-themes</a>，我当初就是把它主题下的所有主题都试了一遍，才找到自己喜欢的。<code>^0^</code>希望大家不要像我一样o。</p><p>airline由于要显示一些图形字符，所以它需要使用一些<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">特定的字体</a>。</p><hr><h3 id="自动补全括号"><a href="#自动补全括号" class="headerlink" title="自动补全括号"></a>自动补全括号</h3><p>当我们码代码的时候，如果每次输入一个<code>(</code>之后，稍后还得记得输入另一个配对的<code>)</code>是不是很麻烦，而且有时候还会忘记另一个<code>)</code>。</p><p><a href="https://github.com/jiangmiao/auto-pairs" target="_blank" rel="noopener">auto-pairs</a>插件正好可以胜任这个任务。</p><hr><h3 id="代码自动补全"><a href="#代码自动补全" class="headerlink" title="代码自动补全"></a>代码自动补全</h3><p>代码自动补全首推YCM了，具体的安装配置过程可以参照我的另一篇博客<a href="https://yaoer.me/2018/10/21/YCM/#more">Mac安装配置YCM</a>，在Unix/Linux下过程应该是差不多的。</p><hr><h3 id="函数参数列表补全"><a href="#函数参数列表补全" class="headerlink" title="函数参数列表补全"></a>函数参数列表补全</h3><p>如果你YCM安装成功了，在你体验着它便利的同时，你应该会有另一个棘手的问题：<strong><em>对于函数参数无法补全</em></strong>。</p><p>在补全列表中是可以看到参数列表的，当当你键入<code>(</code>后，参数列表就消失了。对于一些常见的函数，我们可能不依赖于函数参数补全。但对于一个稍显生僻的函数或者参数表特别长的函数，我们显而易见需要参数补全，因为我们可能会忘掉参数或者搞错参数顺序。</p><p><a href="https://github.com/tenfyzhong/CompleteParameter.vim" target="_blank" rel="noopener">CompleteParameter.vim</a>正是这样一个与YCM完美配合的插件。</p><p><img src="https://camo.githubusercontent.com/5ff72790ae3d6bf6c964cf3b59bdc0985268b190/687474703a2f2f7778342e73696e61696d672e636e2f6d773639302f36393437323232336779316668796a76726a68723367323068733061307162792e676966" alt=""></p><p>一旦你键入<code>(</code>后，它会将该函数的参数列表显示出来，和一般IDE的补全是没有什么两样的，填完一个参数后，你可以使用<code>ctr + j</code>跳转到下一个参数，直到填完所有参数，最后跳到<code>)</code>外面。</p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;expr&gt;</span> ( complete_parameter#pre_complete(<span class="string">"()"</span>)</span><br><span class="line"><span class="keyword">smap</span> <span class="symbol">&lt;c-j&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_next_parameter)</span><br><span class="line"><span class="keyword">imap</span> <span class="symbol">&lt;c-j&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_next_parameter)</span><br><span class="line"><span class="keyword">smap</span> <span class="symbol">&lt;c-k&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_previous_parameter)</span><br><span class="line"><span class="keyword">imap</span> <span class="symbol">&lt;c-k&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_previous_parameter)</span><br></pre></td></tr></table></figure><hr><h3 id="跳转到声明或定义处"><a href="#跳转到声明或定义处" class="headerlink" title="跳转到声明或定义处"></a>跳转到声明或定义处</h3><p>这里我们不使用<code>ctags</code>，因为对于C/C++来说，YCM原生支持这些操作，而且使用起来非常方便。</p><p>在你的vimrc中加入下面这一句：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" 跳转到声明或定义处</span></span><br><span class="line"><span class="string">nnoremap &lt;silent&gt;&lt;leader&gt;j :YcmCompleter GoToDefinitionElseDeclaration&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><p>具体的键位映射需要你根据自己的方便设置。</p><hr><h3 id="树形目录"><a href="#树形目录" class="headerlink" title="树形目录"></a>树形目录</h3><p><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">nerdtree</a>插件可以显示树形目录。</p><p><a href="https://github.com/tiagofumo/vim-nerdtree-syntax-highlight" target="_blank" rel="noopener">vim-nerdtree-syntax-highlight</a>插件可以高亮nerdtree显示的文件类型。</p><p><a href="https://github.com/Xuyuanp/nerdtree-git-plugin" target="_blank" rel="noopener">nerdtree-git-plugin</a>插件可以显示git状态。</p><p>这三个插件大家可以一起配套下载使用。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v4.png?raw=true" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" nerdtree</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span>n :NERDTreeToggle<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeFileExtensionHighlightFullName</span>    = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeExactMatchHighlightFullName</span>       = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreePatternMatchHighlightFullName</span>     = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeHighlightFolders</span>                  = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeHighlightFoldersFullName</span>          = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeDirArrowExpandable</span>                = <span class="string">'▷'</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeDirArrowCollapsible</span>               = <span class="string">'▼'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" nerdtree-git-plugin</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeIndicatorMapCustom</span> = &#123;</span><br><span class="line">            \ <span class="string">"Modified"</span>  : <span class="string">"✹"</span>,</span><br><span class="line">            \ <span class="string">"Staged"</span>    : <span class="string">"✚"</span>,</span><br><span class="line">            \ <span class="string">"Untracked"</span> : <span class="string">"✭"</span>,</span><br><span class="line">            \ <span class="string">"Renamed"</span>   : <span class="string">"➜"</span>,</span><br><span class="line">            \ <span class="string">"Unmerged"</span>  : <span class="string">"═"</span>,</span><br><span class="line">            \ <span class="string">"Deleted"</span>   : <span class="string">"✖"</span>,</span><br><span class="line">            \ <span class="string">"Dirty"</span>     : <span class="string">"✗"</span>,</span><br><span class="line">            \ <span class="string">"Clean"</span>     : <span class="string">"✔︎"</span>,</span><br><span class="line">            \ <span class="string">'Ignored'</span>   : <span class="string">'☒'</span>,</span><br><span class="line">            \ <span class="string">"Unknown"</span>   : <span class="string">"?"</span></span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="显示类、方法、变量"><a href="#显示类、方法、变量" class="headerlink" title="显示类、方法、变量"></a>显示类、方法、变量</h3><p><a href="https://github.com/majutsushi/tagbar" target="_blank" rel="noopener">tagbar</a>插件可以让我们把握文件的整体结构。</p><p><img src="https://camo.githubusercontent.com/fc85311154723793776aed28488befdfaab36c42/68747470733a2f2f692e696d6775722e636f6d2f5366394c7332722e706e67" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:tagbar_width</span> = <span class="number">30</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span>t :TagbarToggle<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="快速代码注释"><a href="#快速代码注释" class="headerlink" title="快速代码注释"></a>快速代码注释</h3><p>当我们在debug时，经常需要注释一段可能会出错的代码来查看程序的运行行为，这个时候，<a href="https://github.com/scrooloose/nerdcommenter" target="_blank" rel="noopener">nerdcommenter</a>插件就非常有用，它可以让我们非常方便的注释或者反注释代码段。</p><p>它的简单用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;leader&gt;cc         注释一行</span><br><span class="line">&lt;leader&gt;cu         取消注释</span><br><span class="line">&lt;leader&gt;cm         注释(Visual)选中的一段代码</span><br></pre></td></tr></table></figure><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDSpaceDelims</span>               = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDCompactSexyComs</span>           = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDDefaultAlign</span>              = <span class="string">'left'</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDCommentEmptyLines</span>         = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTrimTrailingWhitespace</span>    = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDToggleCheckAllLines</span>       = <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h3 id="文件模糊搜索"><a href="#文件模糊搜索" class="headerlink" title="文件模糊搜索"></a>文件模糊搜索</h3><p>文件模糊查找在我们日常工作应该经常要用到，与其使用速度较慢的<code>find</code>命令，<a href="https://github.com/Yggdroot/LeaderF" target="_blank" rel="noopener">LeaderF</a>插件可以帮助我们在大型项目中快速定位文件。而且除过模糊查找之外，它还有很多其他功能，我这里就不多说了。</p><p><img src="https://github.com/Yggdroot/Images/raw/master/leaderf/leaderf_1.gif" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> :LeaderfFile<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_WildIgnore</span> = &#123;</span><br><span class="line">            \ <span class="string">'dir'</span>: [<span class="string">'.svn'</span>,<span class="string">'.git'</span>,<span class="string">'.hg'</span>,<span class="string">'.vscode'</span>,<span class="string">'.wine'</span>,<span class="string">'.deepinwine'</span>,<span class="string">'.oh-my-zsh'</span>],</span><br><span class="line">            \ <span class="string">'file'</span>: [<span class="string">'*.sw?'</span>,<span class="string">'~$*'</span>,<span class="string">'*.bak'</span>,<span class="string">'*.exe'</span>,<span class="string">'*.o'</span>,<span class="string">'*.so'</span>,<span class="string">'*.py[co]'</span>]</span><br><span class="line">            \&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_UseCache</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h3 id="更快速高效地移动"><a href="#更快速高效地移动" class="headerlink" title="更快速高效地移动"></a>更快速高效地移动</h3><p>Vim本身已经为我们提供了许多有用的组合键来帮助我们快速高效的移动，但那些大多是小范围的局部移动，而且也并不太准确。</p><p><a href="https://github.com/easymotion/vim-easymotion" target="_blank" rel="noopener">vim-easymotion</a>插件可以帮助我们快速准确的定位，让我们的移动一击即中。</p><p><img src="https://camo.githubusercontent.com/d5f800b9602faaeccc2738c302776a8a11797a0e/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f333739373036322f323033393335392f61386539333864362d383939662d313165332d383738392d3630303235656138333635362e676966" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;Leader&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-prefix)</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:EasyMotion_do_mapping</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">j</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">j</span>)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">k</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">k</span>)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>h <span class="symbol">&lt;Plug&gt;</span>(easymotion-linebackward)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">l</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-lineforward)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>s <span class="symbol">&lt;Plug&gt;</span>(easymotion-s)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">w</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">bd</span>-<span class="keyword">w</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="延迟加载Vim插件"><a href="#延迟加载Vim插件" class="headerlink" title="延迟加载Vim插件"></a>延迟加载Vim插件</h3><p>随着我们安装插件的增多，Vim的启动速度不可避免的会变慢，当达到某个临界点之后，这种略显卡顿的启动就不是我们能接受的了。它会非常影响我们编辑文本的心情。</p><p>当幸运的是，Vim的最新版本提供了延迟加载插件的机制，这可以帮助我们将那些在初打开文件时不用的且较重的插件延迟加载，即打开文件后再加载。这样就能显著提高Vim的启动速度了。</p><p>具体操作如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" 延迟加载YCM</span></span><br><span class="line"><span class="string">Plug 'Valloric/YouCompleteMe', &#123; 'on': [] &#125;             </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 100ms后调用LoadPlug，且只调用一次</span><br><span class="line">call timer_start(100, <span class="string">'LoadPlug'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>! LoadPlug(timer) abort</span><br><span class="line">    call plug<span class="comment">#load('YouCompleteMe')</span></span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你不知从哪里听过Vim的鼎鼎大名而信心满满的去安装它后，你打开Vim的界面后是这样的：什么也没有，就是一个黑框框。然后你想尝试打几个字，结果发现终端一直在嘟嘟的响。这时你的心里一定会大失所望，这都是什么啊。&lt;br&gt;
    
    </summary>
    
      <category term="vim" scheme="https://yaoer.me/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac安装配置YCM</title>
    <link href="https://yaoer.me/2018/10/21/YCM/"/>
    <id>https://yaoer.me/2018/10/21/YCM/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-11-23T15:14:44.849Z</updated>
    
    <content type="html"><![CDATA[<p>YCM的大名在这里就不消多说了。下面我们就来说说如何安装吧。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>YCM算是Vim插件中比较重的了，而且与其他插件不同的是，它是一个带有编译组件的插件。因此也就导致了在安装过程可能会出现各种意想不到的问题。<br><a id="more"></a></p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>在正式安装YCM之前需要安装一些依赖工具。</p><h4 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h4><p>可以说是homebrew使得Mac的软件生态变得完整，因为它是一个非常好用的包管理工具。我们下面提到的一些依赖都可以通过它很方便地安装。</p><p>可以在终端运行以下ruby脚本安装brew:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>它的用法很简单，比如说安装Vim。</p><p><code>$ brew install vim</code></p><p>运行<code>brew uninstall vim</code>即可卸载。</p><h4 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h4><p>确保你的Vim版本是最新的，且要支持py2或py3。Mac系统自带的Vim版本比较老，你最好使用brew安装最新的版本。可以通过以下命令查看：</p><p><code>$ vim --version</code></p><p>如果输出中包含<code>+python或+python3</code>，就说明你的Vim支持py2或py3。</p><p>如果你的Vim不支持python，那么你可能就需要<a href="https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source" target="_blank" rel="noopener">从源码编译安装Vim</a>了，不过别担心，它的过程很简单。</p><h4 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h4><p><code>$ brew install CMake</code></p><h4 id="Command-Line-Tools"><a href="#Command-Line-Tools" class="headerlink" title="Command Line Tools"></a>Command Line Tools</h4><p>如果你需要C-Family语言补全的话，你就需要安装以上命令行工具。它们在你第一次运行clang时自动安装，也可以通过手工安装：</p><p><code>$ xcode-select --install</code></p><h4 id="pythen-dev"><a href="#pythen-dev" class="headerlink" title="pythen-dev"></a>pythen-dev</h4><p>Mac系统已经默认安装。不过这里需要注意的是：</p><blockquote><p><strong><em>你千万不要在私下去安装一个新的python2，不然会导致YCM在安装和编译中使用不同的python2版本，从而会产生冲突。</em></strong></p></blockquote><p>如果你已经使用brew安装了，那么你可能需要卸载它。这或许会使你的问题得到解决。</p><p><code>$ brew uninstall python@2</code></p><h3 id="YCM"><a href="#YCM" class="headerlink" title="YCM"></a>YCM</h3><p>安装YCM这里推荐使用Plug安装，当然你使用Vundle也可以。</p><p>在你的.vimrc中加入以下代码段。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call plug<span class="comment">#begin('~/.vim/plugged')</span></span><br><span class="line">Plug <span class="string">'Valloric/YouCompleteMe'</span></span><br><span class="line">call plug<span class="comment">#end()</span></span><br></pre></td></tr></table></figure><p>然后在Vim中输入<code>:PlugInstall</code>等待自动安装结束即可。这个过程可能会有点久，需要耐心等待。</p><p>如果你不是使用Plug或Vundle安装的，那么你就需要保证YCM安装包的完整性。可以运行下列命令检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>安装成功后，接下来就需要进入编译环节了。编译过程实际上很简单，运行一个脚本就行了。但如果在脚本运行过程中出了点问题，那么你可能就需要完整地一步一步地编译YCM了。</p><hr><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="直接运行安装脚本"><a href="#直接运行安装脚本" class="headerlink" title="直接运行安装脚本"></a>直接运行安装脚本</h3><p>如果你需要C-Family语言补全，则运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.vim/Plug/YouCompleteMe</span><br><span class="line">$ ./install.py --clang-completer</span><br></pre></td></tr></table></figure><p>否则，直接运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.vim/Plug/YouCompleteMe</span><br><span class="line">$ ./install.py</span><br></pre></td></tr></table></figure><p>如果你幸运的编译成功了，那么直接跳转到配置过程中。否则，进入下一步。</p><h3 id="一步一步编译"><a href="#一步一步编译" class="headerlink" title="一步一步编译"></a>一步一步编译</h3><p>如果你和我当初一样失败了，那么可能就需要进行下面这些比较繁琐的安装过程了。</p><h4 id="下载最新版本的libclang"><a href="#下载最新版本的libclang" class="headerlink" title="下载最新版本的libclang"></a>下载最新版本的libclang</h4><p>如果你关心C-Family语言语义支持，完成这一步骤。</p><p>libclang它提供的库用于为这些语言提供YCM语义完成引擎。</p><p>只有在你确定它是3.9或更高版本时才可以使用系统libclang，否则不能。但即使它是，YCM官方也建议尽可能使用<a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener">llvm.org</a>的官方二进制文件。这确保为你的操作系统下载正确的存档文件。</p><h4 id="编译ycm-core"><a href="#编译ycm-core" class="headerlink" title="编译ycm_core"></a>编译ycm_core</h4><p>这个库是YCM用来获得快速补全的C++引擎。</p><p>在这里，我假设你使用Plug安装了YCM。这意味着YCM的顶级目录在<code>~/.vim/Plug/YouCompleteMe</code>。</p><p>我们将创建一个新文件夹，其中将放置构建文件。运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ mkdir ycm_build</span><br><span class="line">$ cd ycm_build</span><br></pre></td></tr></table></figure><p>现在我们需要生成Makefile。如果你不关心C-Family语言的语义支持，就请在ycm_build 目录中运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -G &quot;Unix Makefiles&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</span><br></pre></td></tr></table></figure><p>如果你关心C-Family语言的语义支持，那么CMake的调用就会更复杂些。我们假设你在llvm.org中下载的LLVM + Clang的二进制发行版，你提取的存档文件放到了文件夹<code>~/ycm_temp/llvm_root_dir</code>中。</p><p>然后在<code>ycm_build</code>目录中运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -G &quot;Unix Makefiles&quot; -DPATH_TO_LLVM_ROOT=~/ycm_temp/llvm_root_dir . ~/.vim/Plug/YouCompleteMe/third_party/ycmd/cpp</span><br></pre></td></tr></table></figure><p>现在已经生成了配置文件，使用以下命令编译库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build . --target ycm_core</span><br></pre></td></tr></table></figure><p>至此YCM就已经安装完成了，<code>ycm_build</code>和<code>ycm_temp</code>目录都可以删除了，不影响使用。</p><p>如果你中间还是出现了一些问题，那么请你仔细按照以上过程重新尝试安装。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置过程需要编辑两个文件：<code>vimrc</code>和<code>.ycm_extra_conf.py</code>。</p><p>在你的终端运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo | clang -v -E -x c++ -</span><br></pre></td></tr></table></figure><p>将输出结果中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;...&quot; search starts here:</span><br><span class="line">#include &lt;...&gt; search starts here:</span><br></pre></td></tr></table></figure><p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">End of search list.z</span><br></pre></td></tr></table></figure></p><p>之间的部分添加到<code>.ycm_extra_conf.py</code>中的<code>-isystem</code>后。</p><p>然后将一下代码段加入到你的vimrc中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> g:ycm_server_python_interpreter=<span class="string">'/usr/bin/python'</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_global_ycm_extra_conf = <span class="string">'~/.vim/plugged/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py'</span></span><br><span class="line"><span class="string">" 让vim的补全菜单行为与一般IDE一致</span></span><br><span class="line"><span class="string">set completeopt=longest,menu</span></span><br><span class="line"><span class="string">"</span> 触发(符号)补全时需要键入的字符数</span><br><span class="line"><span class="built_in">let</span> g:ycm_min_num_of_chars_for_completion = 1</span><br><span class="line"><span class="string">" 补全候选项的最小字符数</span></span><br><span class="line"><span class="string">let g:ycm_min_num_identifier_candidate_chars = 0</span></span><br><span class="line"><span class="string">"</span> 关闭诊断显示功能(已经使用了ale进行异步语法检查)</span><br><span class="line"><span class="built_in">let</span> g:ycm_show_diagnostics_ui = 0</span><br><span class="line"><span class="string">" 在字符串和注释中仍会触发补全</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_comments = 1</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_strings = 1</span></span><br><span class="line"><span class="string">"</span> 禁止缓存匹配项，每次重新生成匹配项</span><br><span class="line"><span class="built_in">let</span> g:ycm_cache_omnifunc = 0</span><br><span class="line"><span class="string">" 在用户接受提供的完成字符串后自动关闭窗口</span></span><br><span class="line"><span class="string">let g:ycm_autoclose_preview_window_after_completion = 0</span></span><br><span class="line"><span class="string">"</span> 跳转到声明或定义处</span><br><span class="line">nnoremap &lt;silent&gt;&lt;leader&gt;gj :YcmCompleter GoToDefinitionElseDeclaration&lt;cr&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">" 自动触发语义补全</span></span><br><span class="line"><span class="string">let g:ycm_semantic_triggers =  &#123;</span></span><br><span class="line"><span class="string">            \ 'c,cpp,python,java,go,erlang,perl': ['re!\w&#123;1&#125;'],</span></span><br><span class="line"><span class="string">            \ 'cs,lua,javascript': ['re!\w&#123;1&#125;'],</span></span><br><span class="line"><span class="string">            \ &#125;</span></span><br><span class="line"><span class="string">"</span> 遇到下列文件时才会开启YCM</span><br><span class="line"><span class="built_in">let</span> g:ycm_filetype_whitelist = &#123;</span><br><span class="line">            \ <span class="string">"c"</span>:1,</span><br><span class="line">            \ <span class="string">"cpp"</span>:1,</span><br><span class="line">            \ <span class="string">"python"</span>:1,</span><br><span class="line">            \ <span class="string">"sh"</span>:1,</span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure><p>接下来你就可以享受YCM带来的如丝般柔滑地补全了。</p><hr><p>参考资料：<br><a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="noopener">YCM官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;YCM的大名在这里就不消多说了。下面我们就来说说如何安装吧。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;YCM算是Vim插件中比较重的了，而且与其他插件不同的是，它是一个带有编译组件的插件。因此也就导致了在安装过程可能会出现各种意想不到的问题。&lt;br&gt;
    
    </summary>
    
      <category term="vim" scheme="https://yaoer.me/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>巧判机器的大小端</title>
    <link href="https://yaoer.me/2018/10/21/endian/"/>
    <id>https://yaoer.me/2018/10/21/endian/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-10-22T15:26:03.947Z</updated>
    
    <content type="html"><![CDATA[<p>大小端的命名来自于《格列佛游记》中一个有关吃鸡蛋先磕鸡蛋的大端还是小端的故事，大家有兴趣的话可以去了解一下。</p><p>那么什么是大端、什么是小端呢？</p><blockquote><ul><li>大端：即高位有效字节在低位地址，低位有效字节在高位地址。</li><li>小端：即高位有效字节在高位地址，低位有效字节在低位地址。</li></ul></blockquote><a id="more"></a><p>我们举个例子来说明一下：<code>char a = 1;</code></p><p>它在内存中的表示如下图：</p><blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/endian.png?raw=true" alt=""></p></blockquote><p>那么如何用C语言来判断自己所使用机器的大小端呢？<br>通常有两种方法，其本质都是依赖于<strong><em>大小端的概念。</em></strong></p><p>一种方法是借助联合的特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125; port;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    port.a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (port.b == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们知道，在联合中 <strong><em>多个成员变量共用一段内存</em></strong>。在执行完<code>port.a = 1</code>后，内存中的情况是这样的：<code>00000000 00000000 00000000 00000001</code>。它到底是如何存放的，我们目前并不清楚。当我们访问<code>port.b</code>时，我们只会访问到位于该段内存中最低地址的那一字节的内容。如果<code>port.b == 1</code>，显然我们访问到的是<code>00000001</code>这一字节的内容，即低位有效字节在低位地址，所以是<code>little-endian</code>模式。<code>big-endian</code>模式同理。</p></blockquote><p>另一种方法就是根据大小端的概念直接判断了，相比于第一种更直接点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endian</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">char</span> *)&amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (endian())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>a是一个<code>int</code>类型的整数，所以<code>&amp;a</code>可以看作一个<code>int *</code>类型的指针。如果对<code>&amp;a</code>进行解引用操作，则编译器会将其解释为：<strong><em>从当前地址开始往后数4个字节，然后取出这4个字节中的内容</em></strong>。如果我们将<code>&amp;a</code>强制类型转换为<code>char *</code>类型后再进行解引用操作，那么编译器就会将其解释为：<strong><em>取出当前地址所在的那个字节中的内容</em></strong>。这个地址一定是之前那4个内存地址中的最低位地址。通过查看该地址中的值是什么我们就能确定该机器的大小端了。</p></blockquote><p>显然，两种方法的本质都是相同的，都是通过<strong><em>查看低位地址中的内容</em></strong>来判断大小端模式的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大小端的命名来自于《格列佛游记》中一个有关吃鸡蛋先磕鸡蛋的大端还是小端的故事，大家有兴趣的话可以去了解一下。&lt;/p&gt;
&lt;p&gt;那么什么是大端、什么是小端呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;大端：即高位有效字节在低位地址，低位有效字节在高位地址。&lt;/li&gt;
&lt;li&gt;小端：即高位有效字节在高位地址，低位有效字节在低位地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="server" scheme="https://yaoer.me/categories/server/"/>
    
    
  </entry>
  
</feed>
