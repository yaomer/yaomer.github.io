<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>若倾</title>
  
  <subtitle>若教解语应倾国，任是无情也动人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yaoer.me/"/>
  <updated>2018-10-24T12:56:56.771Z</updated>
  <id>https://yaoer.me/</id>
  
  <author>
    <name>妖儿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简单计算器</title>
    <link href="https://yaoer.me/2018/10/24/calculator/"/>
    <id>https://yaoer.me/2018/10/24/calculator/</id>
    <published>2018-10-24T12:56:56.771Z</published>
    <updated>2018-10-24T12:56:56.771Z</updated>
    
    <content type="html"><![CDATA[<p>设计要求：</p><blockquote><p>输入一个只含有+、-、<em>、/、和%运算符的数学表达式，然后计算出其值；并且要能够处理圆括号。<br>例如：2 + 3 </em> (4 - 2)</p></blockquote><a id="more"></a><p>分析过程：</p><blockquote><ul><li>我们都知道后缀表达式是非常符合计算机的计算方式的，因为它不用考虑优先级的问题，只需要从左到右依次计算即可。</li><li>所以我们的整体思路是：<strong><em>先把输入的中缀表达式转换为后缀表达式，然后再计算出它的值。</em></strong></li></ul></blockquote><p>下面是程序的具体流程：</p><blockquote><ul><li>每次调用exp_trans函数读取一行输入，将其中的中缀表达式转换为后缀表达式，并保存在全局数组expr中；而getop函数则每次从expr中读取字符，解析生成的后缀表达式，最后借用stack计算出它的值。</li><li>为了方便计算后缀表达式，我们在解析生成的后缀表达式时对其格式作了一点简单的调整，即在每个运算符或操作数之间都加上了空格。</li><li>还应当注意的是：浮点数不能直接和0进行比较。</li></ul></blockquote><hr><p>计算后缀表达式的算法是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (下一个运算符或操作数不是EOF)</span><br><span class="line">    <span class="keyword">if</span> (是数)</span><br><span class="line">        将该数压入到栈中</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (是运算符)</span><br><span class="line">        弹出所需数目的操作数</span><br><span class="line">    执行运算</span><br><span class="line">        将结果压入到栈中</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (是\n)</span><br><span class="line">        弹出并打印栈顶值</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        出错</span><br></pre></td></tr></table></figure><hr><p>下面给出代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXEXP 200          <span class="comment">/*  允许输入的中缀表达式的最大长度  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXOP  20           <span class="comment">/*  运算符或操作数的最大长度  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER <span class="meta-string">'0'</span>          <span class="comment">/*  标识找到一个数  */</span></span></span><br></pre></td></tr></table></figure><blockquote><p>主函数主要控制表达式的计算，值得一提的是，这里便是switch语句的一个典型应用</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">main.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> expr[MAXEXP];   <span class="comment">/*  存储转换后的后缀表达式  */</span></span><br><span class="line"><span class="keyword">int</span> li = <span class="number">0</span>;         <span class="comment">/*  expr数组的索引  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[MAXOP];    <span class="comment">/*  存储获取的运算符或操作数  */</span></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">double</span> op2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((type = getop(s)) != EOF)</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> NUMBER:</span><br><span class="line">            push(atof(s));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            push(pop() + pop());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">            push(pop() * pop());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            op2 = pop();</span><br><span class="line">            push(pop() - op2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            op2 = pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(op2) &gt; DBL_EPSILON)</span><br><span class="line">                push(pop() / op2);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"error: zero divisor\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">            op2 = pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(op2) &gt; DBL_EPSILON)</span><br><span class="line">                push(<span class="built_in">fmod</span>(pop(), op2));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"error: zero divisor\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t%.8g\n"</span>, pop());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error: unknow command %s\n"</span>, s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后<strong>exp_trans</strong>完成表达式的转换，转换过程也是利用栈来完成的，和最终计算表达式是用的同一个栈。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">expts.c</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  遇见数字，输出；遇见操作符，入栈；遇见比栈顶操作符优先级更低的，弹出栈中比遇见的操作符优先级高的；</span></span><br><span class="line"><span class="comment"> *  遇见')'，弹出栈中'('之后的所有操作符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  exp_trans函数：将中缀表达式转换为后缀表达式   */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exp_trans</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, i;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c) || <span class="built_in">isdigit</span>(c) || c == <span class="string">'.'</span>) &#123;        <span class="comment">/*  原样保存空白符和数字  */</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!isempty()) &#123;        <span class="comment">/*  遇见\n，弹出栈中所有操作符  */</span></span><br><span class="line">                    expr[i++] = pop();</span><br><span class="line">                    expr[i++] = <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            expr[i++] = c;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op_prior(c) || c == <span class="string">')'</span>) &#123;    <span class="comment">/*  是运算符或')'  */</span></span><br><span class="line">            <span class="keyword">if</span> (isempty() &amp;&amp; c != <span class="string">'-'</span>) &#123;</span><br><span class="line">                push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!isempty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (top() == <span class="string">'('</span>) &#123;</span><br><span class="line">                        pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    expr[i++] = pop();</span><br><span class="line">                    expr[i++] = <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;       <span class="comment">/*  判断是负号还是减号  */</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c = getchar())) &#123;</span><br><span class="line">                        expr[i++] = <span class="string">'-'</span>;</span><br><span class="line">                        expr[i++] = c;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ungetc(c, <span class="built_in">stdin</span>);</span><br><span class="line">                        c = <span class="string">'-'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!isempty() &amp;&amp; top() != <span class="string">'('</span> &amp;&amp; op_prior(top()) &gt;= op_prior(c)) &#123;</span><br><span class="line">                    expr[i++] = pop();</span><br><span class="line">                    expr[i++] = <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    expr[i++] = c;</span><br><span class="line">    expr[i] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  op_prior函数：返回对应操作符的优先级   */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_prior</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们每次调用<strong>exp_trans</strong>函数读取一行，然后<strong>getop</strong>函数用于从中解析需要的运算符和操作数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">getop.c</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  getop函数：获取下一个运算符或操作数    */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getop</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (expr[li] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">        exp_trans();    <span class="comment">/* 如果刚开始时未读入或读到expr的末尾，就调用exp_trans函数读入新的一行  */</span></span><br><span class="line">        li = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((s[<span class="number">0</span>] = expr[li]) == <span class="string">' '</span> || expr[li] == <span class="string">'\t'</span>)</span><br><span class="line">        li++;</span><br><span class="line">    s[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(expr[li]) &amp;&amp; !<span class="built_in">islower</span>(expr[li]) &amp;&amp; expr[li] != <span class="string">'.'</span> &amp;&amp; expr[li] != <span class="string">'-'</span>)</span><br><span class="line">        <span class="keyword">return</span> expr[li++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expr[li] == <span class="string">'-'</span>) &#123;      <span class="comment">/*  判断‘-’是减号还是负号  */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(expr[++li]) || expr[li] == <span class="string">'.'</span>)</span><br><span class="line">            *++s = expr[li];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'-'</span>;</span><br><span class="line">    &#125;     <span class="comment">/*  收集数  */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(expr[li]))</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*++s = expr[++li]))</span><br><span class="line">            ;</span><br><span class="line">    <span class="keyword">if</span> (expr[li] == <span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*++s = expr[++li]))</span><br><span class="line">            ;</span><br><span class="line">    *s = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> NUMBER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是栈的实现了，很简单，没什么好说的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val[MAXVAL];    <span class="comment">/*  值栈  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;    <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将c压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull())</span><br><span class="line">        val[++sp] = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出并返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp--];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：只返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isfull函数：判断栈是否已满  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isempty函数：判断栈是否为空  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="https://github.com/yaomer/pictures/blob/master/v7.png?raw=true" alt=""></p><hr><p>参考资料：<br>[C程序设计语言][K&amp;R]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个只含有+、-、&lt;em&gt;、/、和%运算符的数学表达式，然后计算出其值；并且要能够处理圆括号。&lt;br&gt;例如：2 + 3 &lt;/em&gt; (4 - 2)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>堆及其应用</title>
    <link href="https://yaoer.me/2018/10/24/heap/"/>
    <id>https://yaoer.me/2018/10/24/heap/</id>
    <published>2018-10-23T16:00:00.000Z</published>
    <updated>2018-10-24T12:56:16.683Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>(二叉堆)是一个数组，它可以被看成一个近似的完全二叉树</em></strong>。树上的每个节点对应数组中的一个元素，除了最底层外，该树是完全充满的，而且是从左向右填充。下文如果不加限定的话，所提到的堆均指二叉堆。常见的堆还有斐波那契堆等。</p><p><img src="https://github.com/yaomer/pictures/blob/master/array.png?raw=true" alt=""><br><a id="more"></a></p><blockquote><p>数组的每个下标对应堆中的一个节点。而给定一个下标，我们可以很容易得到其父亲和儿子的下标。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉堆可以分为两种形式：<strong><em>最大堆（大根堆）和最小堆（小根堆）</em></strong> 。</p><blockquote><ul><li><strong><em>最大堆</em></strong> 是指除了根节点以外的其他节点i都要满足：<strong>A[parent(i)] &gt;= A[i]</strong>。也就是说某个节点的值至多与其父节点一样大</li><li><strong><em>最小堆</em></strong> 是指除了根节点以外的其他节点i都要满足：<strong>A[parent(i)] &lt;= A[i]</strong></li></ul></blockquote><p>由于最大堆和最小堆非常相似，所以我们下面只讨论一下最大堆。并且为了方便起见，下面给出的C代码中数组下标均从1开始。要做到这一点其实是很容易的，只需为数组多开辟一个元素的空间，然后令下标从1开始，不使用A[0]即可。</p><hr><h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><p>首先我们定义一个全局变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 表示有多少个堆元素存储在该数组中，也就是堆中的元素个数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> heapsize;</span><br></pre></td></tr></table></figure><p>在下面的代码中，我们略去了一些错误检查，比如在实际应用中，你必须保证heapsize的值是有效的，即 <strong><em>heapsize不能大于数组的长度。</em></strong></p><h4 id="维护堆的性质"><a href="#维护堆的性质" class="headerlink" title="维护堆的性质"></a>维护堆的性质</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  max_heap函数：维护最大堆的性质  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> l, r, largest;</span><br><span class="line">    </span><br><span class="line">    l = left(i);</span><br><span class="line">    r = right(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  找出a[i]、a[l]、a[r]中的最大值  */</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= heapsize &amp;&amp; a[l] &gt; a[i])</span><br><span class="line">        largest = l;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        largest = i;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= heapsize &amp;&amp; a[r] &gt; a[largest])</span><br><span class="line">        largest = r;</span><br><span class="line">    <span class="comment">/* 如果a[i]是最大的，那么以该节点为根的子树已满足最大堆的性质，函数结束；</span></span><br><span class="line"><span class="comment">     * 否则，最大元素是其某个孩子节点，我们交换a[i]和a[largest]，从而使a[i]</span></span><br><span class="line"><span class="comment">     * 及其孩子都满足最大堆的性质</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(a, i, largest);</span><br><span class="line">        <span class="comment">/* 当a[largest]成为a[i]之后，以该节点为根的子树可能会违反最大堆的性质</span></span><br><span class="line"><span class="comment">         * 所以要对该子树递归调用max_heap</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        max_heap(a, largest);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  swap函数：交换两个数  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[i]; </span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码中注释的已经非常清楚了， <strong><em><font color="red">我们通过让a[i]在最大堆中“逐级下降“，从而使得以a[i]为根节点的子树重新遵循最大堆的性质。</font></em></strong></p></blockquote><hr><p>下面我们举例说明一下，下图是<strong>max_heap(a, 2)，heapsize = 10</strong>的执行过程：</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap.png?raw=true" alt=""></p><blockquote><p>a[2]违背了最大堆的性质，因为它不大于它的孩子，所以要将它和它的孩子中最大的进行交换，即swap(a[2], a[4])。递归调用max_heap(a, 4, 10)，发现a[4]同样不满足最大堆的性质，所以要swap(a[4], a[9])。再递归调用max_heap(a, 9, 10)，发现以a[9]为根的子树满足最大堆的性质。</p></blockquote><hr><p>维护最小堆的性质与之类似，我们只需 <strong><em>将不满足最小堆性质的节点与其孩子中最小的一个进行交换，然后递归下降即可。直到遇见满足最小堆性质的节点。</em></strong></p><hr><h4 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  build_max_heap函数：构建一个最大堆  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*  a[n / 2]..a[n]中的元素都是树的叶节点，所以</span></span><br><span class="line"><span class="comment">     *  我们对树中的其他节点都调用一次max_heap即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    heapsize = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        max_heap(a, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>构建一个最大堆就是对于以a[n / 2] .. a[n]为根节点的每个子树，使它们分别都满足最大堆的性质，也就是对它们的根节点分别都执行一次max_heap即可。这样整棵树都满足了最大堆的性质，即构建成了一个最大堆</em></strong>。因为a[1] .. a[n / 2]都是树叶，显然满足最大堆的性质。</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap1.png?raw=true" alt=""></p><blockquote><p>如上图所示，要将该数组构建成为一个最大堆，只需对红色区域的节点各执行一次max_heap即可。</p></blockquote><hr><h3 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h3><p>堆主要有两个应用：<strong><em>堆排序</em></strong> 和 <strong><em>优先队列</em></strong>。</p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong><em>堆排序先利用build_max_heap将整个数组构建成为一个最大堆。因为数组中的最大元素总存放在根节点a[1]中，通过把它与a[n]交换，我们能将它放到正确的位置上。然后我们从堆中去掉该节点，可以通过减少heapsize的值来实现。新的根节点可能会违背最大堆的性质，所以我们对该节点执行max_heap以维护最大堆的性质，从而在a[1] .. a[n - 1]上构建出一个新的最大堆</em></strong>。堆排序会不断重复这一过程，直到堆的大小下降为2。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  heap_sort函数：堆排序  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    build_max_heap(a, n);   <span class="comment">/*  将数组构建为一个最大堆  */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">        swap(a, <span class="number">1</span>, i);    <span class="comment">/*  将最大堆元素与堆中的最后一个元素交换  */</span></span><br><span class="line">        heapsize--;      <span class="comment">/*  从堆中去掉a[i]，即最大堆元素  */</span></span><br><span class="line">        max_heap(a, <span class="number">1</span>);  <span class="comment">/*  每次在剩余节点上构建一个新的最大堆  */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>我们这里举两个例子 <strong>(i = 10 和 i = 9)</strong> 来说明一下排序过程。</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap2.png?raw=true" alt=""></p><p><img src="https://github.com/yaomer/pictures/blob/master/heap3.png?raw=true" alt=""></p><blockquote><p>我们先将a[1]与a[10]交换，然后从堆中去掉a[10]，a[1]并不满足最大堆的性质，所以我们对它调用一次max_heap，沿红色路径进行调整，使之重新满足最大堆的性质。调整后的结果为：</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/heap4.png?raw=true" alt=""></p><p><img src="https://github.com/yaomer/pictures/blob/master/heap5.png?raw=true" alt=""></p><blockquote><p>我们将a[1]与a[9]交换，然后从堆中去掉a[9]，a[1]并不满足最大堆的性质，所以我们对它调用一次max_heap，沿红色路径进行调整，使之重新满足最大堆的性质。调整后的结果为：</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/heap6.png?raw=true" alt=""></p><hr><p>堆排序过程：<br><img src="https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif" alt=""></p><hr><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>和堆一样，优先队列也有两种形式：最大优先队列和最小优先队列。这里我们只讨论最大优先队列的有关操作。显而易见，在这里它就是基于最大堆来实现的。</p><p>最大优先队列的应用有很多，其中有一个就是<strong>作业调度问题</strong>。最大优先队列记录将要执行的各个作业以及它们之间的相对优先级。当一个作业完成或者被中断后，调度器从所有等待的作业中选出具有最高优先级的作业来执行。在任何时候，调度器可以把一个新作业加入到队列中。</p><h5 id="返回最大堆元素"><a href="#返回最大堆元素" class="headerlink" title="返回最大堆元素"></a>返回最大堆元素</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  topheap函数：返回最大堆元素  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topheap</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扩充堆"><a href="#扩充堆" class="headerlink" title="扩充堆"></a>扩充堆</h5><p>扩充堆就是将一个新的元素插入到堆中。具体方法就是：<strong><em>我们先对堆进行扩充，可以通过增加heapsize的值来实现。然后将待插入的元素key放到扩充后的位置上去，即a[heapsize] = key。接下来对于节点key，我们沿树向上进行调整，如果它的值大于它的父节点的值，我们就将它与其父节点进行交换，… 直到它的值不大于它的父节点的值，这时就满足了最大堆的性质，即将key插入到了堆中正确的位置上。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  addheap函数：在堆中插入一个元素key  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addheap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    i = ++heapsize;</span><br><span class="line">    a[i] = key;</span><br><span class="line">    j = parent(i);</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span> &amp;&amp; a[i] &gt; a[j]) &#123;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">        i = j;    <span class="comment">/*  更新i的值  */</span></span><br><span class="line">        j = parent(i);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们要把<strong>15</strong>插入到下列最大堆中</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap2.png?raw=true" alt=""></p><blockquote><p>它的过程如下：即将新插入的节点15沿红色路径向上进行调整，这个过程我们上面已经详细地描述过了。</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/heap7.png?raw=true" alt=""></p><p>最后的结果为：</p><p><img src="https://github.com/yaomer/pictures/blob/master/heap8.png?raw=true" alt=""></p><hr><h5 id="缩减堆"><a href="#缩减堆" class="headerlink" title="缩减堆"></a>缩减堆</h5><p>缩减堆就是去掉堆中的最大元素。具体思想和堆排序的思想很相似。<strong><em>就是把堆的最后一个元素a[heapsize]赋给最大堆元素a[1]，然后缩减堆。对于新的a[1]，调用max_heap使之满足最大堆的性质即可。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  delheap函数：去掉并返回最大堆元素  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delheap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heapsize &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"heap underflow\n"</span>);</span><br><span class="line">    max = a[<span class="number">1</span>];</span><br><span class="line">    a[<span class="number">1</span>] = a[heapsize--];</span><br><span class="line">    <span class="comment">/*  将堆的最后一个元素赋给最大堆元素，然后缩减堆，即去除堆的最后一个元素  */</span></span><br><span class="line">    max_heap(a, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缩减堆的过程可以参照堆排序的过程去理解。</p><hr><p>参考资料：<br><a href="Thomas H.Cormen / Charles E.Leiserson / Ronald L.Rivest / Clifford Stein">算法导论</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;(二叉堆)是一个数组，它可以被看成一个近似的完全二叉树&lt;/em&gt;&lt;/strong&gt;。树上的每个节点对应数组中的一个元素，除了最底层外，该树是完全充满的，而且是从左向右填充。下文如果不加限定的话，所提到的堆均指二叉堆。常见的堆还有斐波那契堆等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yaomer/pictures/blob/master/array.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>栈的应用之表达式转换</title>
    <link href="https://yaoer.me/2018/10/23/expr/"/>
    <id>https://yaoer.me/2018/10/23/expr/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-10-24T00:57:02.216Z</updated>
    
    <content type="html"><![CDATA[<h3 id="中缀转后缀表达式"><a href="#中缀转后缀表达式" class="headerlink" title="中缀转后缀表达式"></a>中缀转后缀表达式</h3><p>实现的方法很简单：就是用栈来实现。</p><p>具体思路如下：</p><a id="more"></a><blockquote><ul><li>如果是数，我们就直接输出</li><li>是操作符，我们就弹出栈中比它优先级更高的操作符，然后再将它入栈</li><li>是’ ( ‘，直接入栈</li><li>是 ’ ) ‘ ，我们就弹出栈中 ‘ ( ‘ 之后的所有操作符</li><li>遇见 ‘ - ‘ 时，要判断它是负号还是减号</li><li>遇见 ’ \n ‘ ，弹出栈中所有的操作符</li></ul></blockquote><p>为了清晰美观起见，我们在输出的后缀表达式中的每个运算符或操作数之间加上了一个空格</p><p>下面是代码，都有很清晰的注释：</p><blockquote><p>首先是主函数，控制整个转换过程，当然也可以用一个函数来实现，不过这里是为了说明问题，没有必要那样。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  将中缀表达式转换为后缀表达式  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) || c == <span class="string">'.'</span>) &#123;    <span class="comment">/*  是数，就直接输出  */</span></span><br><span class="line">            <span class="built_in">putchar</span>(c);</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c = getchar()) || c == <span class="string">'.'</span>)</span><br><span class="line">                <span class="built_in">putchar</span>(c);</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">            ungetc(c, <span class="built_in">stdin</span>);     <span class="comment">/*  将多读入的字符压回到输入中  */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op_prior(c) || c == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isempty() &amp;&amp; c != <span class="string">'-'</span>)</span><br><span class="line">                push(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;     <span class="comment">/*  遇见')'，弹出栈中'('之后的所有运算符  */</span></span><br><span class="line">                <span class="keyword">while</span> (!isempty() &amp;&amp; top() != <span class="string">'('</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c "</span>, pop());</span><br><span class="line">                <span class="keyword">if</span> (!isempty())</span><br><span class="line">                    pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;     <span class="comment">/*  判断'-'是负号还是减号  */</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c = getchar())) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"-%c"</span>, c);</span><br><span class="line">                        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c = getchar()) || c == <span class="string">'.'</span>)</span><br><span class="line">                            <span class="built_in">putchar</span>(c);</span><br><span class="line">                        <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">                        ungetc(c, <span class="built_in">stdin</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ungetc(c, <span class="built_in">stdin</span>);</span><br><span class="line">                        c = <span class="string">'-'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;     <span class="comment">/*  栈顶运算符的优先级应当低于当前读入的运算符的优先级  */</span></span><br><span class="line">                <span class="keyword">while</span> (!isempty() &amp;&amp; top() != <span class="string">'('</span> &amp;&amp; op_prior(top()) &gt;= op_prior(c))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c "</span>, pop());</span><br><span class="line">                push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;    <span class="comment">/*  遇见换行符时，弹出栈中所有的运算符  */</span></span><br><span class="line">            <span class="keyword">while</span> (!isempty())</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c "</span>, pop());</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于如何返回对应操作符的优先级，我们可以用简单的数字来表示操作符的优先级，如果你想要实现更多的功能，你可以直接在<strong>op_prior</strong>函数中添加更多的操作符。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  op_prior函数：返回对应运算符的优先级  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_prior</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后便是所用到的主要的数据结构——栈了，这里很容易想到的便是用数组来实现堆栈，而非链表。原因也很简单： <strong><em><font color="red">在每一时刻，栈中的操作符数量总不会太多，栈空间用尽的可能性非常小。</font></em></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val[MAXVAL];    <span class="comment">/*  值栈  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;    <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull())</span><br><span class="line">        val[++sp] = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp--];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://github.com/yaomer/pictures/blob/master/v5.png?raw=true" alt=""></p><hr><h3 id="后缀转中缀表达式"><a href="#后缀转中缀表达式" class="headerlink" title="后缀转中缀表达式"></a>后缀转中缀表达式</h3><p>同样是用栈来实现的，有点类似于计算后缀表达式，但具体过程还是有点不同的。实现思路如下：</p><blockquote><ul><li>如果是数，就将它压入栈中</li><li>如果是运算符，就弹出对应数目的操作数，<font color="red">然而在这里我们并不计算该表达式，而是将它整个压入到栈中</font></li><li>我们都知道后缀表达式不存在优先级问题，但中缀表达式是需要考虑优先级的，因此，<strong><em>在转换过程中，我们需要在恰当的地方加上括号来保证运算过程的正确性</em></strong></li><li>对于如何加括号的问题，我是这么想的：例如中缀表达式 <strong>a  *  (b  +  c)</strong> 转换为后缀是 <strong>a  b  c  +  *</strong> ，当我们将 <strong>a  b  c  +  *</strong> 转换回去的时候就需要在  <strong>b  +  c</strong> 外面加上括号。<strong><em>如果当前运算符的优先级比上一个运算符的优先级要高，我们就给栈顶的两个子表达式加上括号。</em></strong></li><li>最后我们弹出栈顶表达式即可</li></ul></blockquote><p>思路大概就是这样，下面我会结合代码详细说明一下。</p><blockquote><p>同样，我们在主函数中控制整个转换过程，转换过程应当很简单。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXEXP 1000           <span class="comment">/*  输入的表达式的最大长度  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXOP  100            <span class="comment">/*  运算符或操作数的最大长度  */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER <span class="meta-string">'0'</span>            <span class="comment">/*  标识找到一个数  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  将后缀表达式转换为中缀表达式  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> lastc;</span><br><span class="line">    <span class="keyword">char</span> s[MAXEXP];      <span class="comment">/*  存储转换后的表达式  */</span></span><br><span class="line">    <span class="keyword">char</span> *op2;</span><br><span class="line"></span><br><span class="line">    lastc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = getop(s)) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (c == NUMBER)     <span class="comment">/*  是数  */</span></span><br><span class="line">            push(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op_prior(c)) &#123;     <span class="comment">/*  是运算符  */</span></span><br><span class="line">            op2 = top();</span><br><span class="line">            pop();</span><br><span class="line">            cat_exp(top(), s, op2, c, lastc);</span><br><span class="line">            push(s);</span><br><span class="line">            lastc = c;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, top());</span><br><span class="line">            pop();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>getop函数主要用于解析输入参数，将它们分解为运算符或操作数，为了后续的处理，我们也做了一些额外的工作，我们用空格将每个运算符或操作数分隔开。当然在处理输入时，它会丢弃多余的空白符，但如果你不加分隔符的话，它会帮你加上的。</li><li>op_prior函数很简单，我们在中缀转后缀表达式的过程中用到过它，这里和那里的是相同的</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  getop函数：从输入中获取下一个运算符或操作数  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getop</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, i;</span><br><span class="line">              </span><br><span class="line">    <span class="keyword">while</span> ((s[<span class="number">0</span>] = c = getchar()) == <span class="string">' '</span> || c == <span class="string">'\t'</span>)</span><br><span class="line">        ;     </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">'.'</span>) &#123;</span><br><span class="line">        s[<span class="number">1</span>] = <span class="string">' '</span>;</span><br><span class="line">        s[<span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;     <span class="comment">/*  收集操作数  */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))       </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getchar()))</span><br><span class="line">            ;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getchar()))</span><br><span class="line">            ;</span><br><span class="line">    s[i] = <span class="string">' '</span>;</span><br><span class="line">    s[++i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (c != EOF)</span><br><span class="line">        ungetc(c, <span class="built_in">stdin</span>);    <span class="comment">/*  将多读入的字符压回到输入中  */</span></span><br><span class="line">    <span class="keyword">return</span> NUMBER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  op_prior函数：返回对应运算符的优先级  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_prior</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码应该是这个程序的难点所在了</p><blockquote><p>cat_exp函数用当前读入的运算符把栈顶的两个子表达式连接起来，如同上面提到的，这里需要重点考虑的是加括号的问题，代码中注释的很详细，应当都能看得懂。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  cat_exp函数：连接两个子表达式  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat_exp</span><span class="params">(<span class="keyword">char</span> *op1, <span class="keyword">char</span> *s, <span class="keyword">char</span> *op2, <span class="keyword">int</span> c, <span class="keyword">int</span> lastc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp[MAXOP];</span><br><span class="line">    <span class="keyword">char</span> op[MAXOP];</span><br><span class="line">    <span class="keyword">char</span> opt[MAXOP];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, s);     <span class="comment">/*  先将已经生成的中缀表达式拷贝到tmp中  */</span></span><br><span class="line">    <span class="keyword">if</span> (lastc &amp;&amp; op_prior(c) &gt; op_prior(lastc)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isop(op1)) &#123;</span><br><span class="line">            cat(op, op1);</span><br><span class="line">            op1 = op;</span><br><span class="line">        &#125;        <span class="comment">/*  在可能需要加括号的地方都加上括号  */</span></span><br><span class="line">        <span class="keyword">if</span> (isop(op2)) &#123;</span><br><span class="line">            cat(opt, op2);</span><br><span class="line">            op2 = opt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     <span class="comment">/*  将新连接好的子表达式加入到已经生成的表达式中，然后拷贝回s中  */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s, op1);</span><br><span class="line">    <span class="built_in">strcat</span>(s, tmp);</span><br><span class="line">    <span class="built_in">strcat</span>(s, op2);</span><br><span class="line">    pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  cat函数：在表达式前后加上括号  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *s++ = <span class="string">'('</span>;</span><br><span class="line">    <span class="keyword">while</span> (*op != <span class="string">'\0'</span>)</span><br><span class="line">        *s++ = *op++;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">' '</span>)</span><br><span class="line">        s--;</span><br><span class="line">    *s++ = <span class="string">')'</span>;</span><br><span class="line">    *s++ = <span class="string">' '</span>;</span><br><span class="line">    *s = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isop函数：判断s中是否有运算符  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isop</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">if</span> (op_prior(*s++))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是栈的实现了，和中缀转后缀不同的是，这里是用指针栈来实现转换过程的，其实也就一普通的堆栈，没什么特别的。但其中也有几点是需要注意的：</p><blockquote><ul><li>我们需要实时为压入栈的表达式分配存储空间</li><li>不要忘记检查内存是否分配成功</li><li>出栈时记得释放内存</li></ul></blockquote><p><strong><em>为了方便起见，我这里用断言以防止使用NULL指针，即内存分配失败的情况。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *val[MAXVAL];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将字符串s压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull()) </span><br><span class="line">        assert((val[++sp] = strdup(s)));</span><br><span class="line">    <span class="keyword">else</span>           <span class="comment">/*  将s保存在某个安全的地方  */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty()) &#123;</span><br><span class="line">        <span class="built_in">free</span>(val[sp]);</span><br><span class="line">        val[sp--] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>运行结果：</p><p><img src="https://github.com/yaomer/pictures/blob/master/v6.png?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;中缀转后缀表达式&quot;&gt;&lt;a href=&quot;#中缀转后缀表达式&quot; class=&quot;headerlink&quot; title=&quot;中缀转后缀表达式&quot;&gt;&lt;/a&gt;中缀转后缀表达式&lt;/h3&gt;&lt;p&gt;实现的方法很简单：就是用栈来实现。&lt;/p&gt;
&lt;p&gt;具体思路如下：&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数组与指针那点事</title>
    <link href="https://yaoer.me/2018/10/23/arr_pointer/"/>
    <id>https://yaoer.me/2018/10/23/arr_pointer/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-10-24T05:31:15.071Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><p>说起数组名？绝大多数初学者是感到非常疑惑的，甚至哪怕是学习了好几年自以为懂的人，恐怕也不能够说得明明白白、清清楚楚。那么，它到底是个什么东西呢？</p><a id="more"></a><p><strong><em><font color="red">首先，我想先声明一点：数组名绝不是指针，也并不是常量指针。</font></em></strong></p><p>我们先以一个简单的赋值为例，说明一下<code>左值</code>和<code>右值</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y;</span><br><span class="line">这个语句的含义是：把y中的值放入x所代表的地址中去</span><br></pre></td></tr></table></figure><table><thead><tr><th>左值</th><th>右值</th></tr></thead><tbody><tr><td>在这个上下文环境里，符号x的含义是x所代表的地址</td><td>在这个上下文环境中，符号y的含义是y所代表的地址中的内容</td></tr><tr><td>在编译时可知，表示存储结果的地方，即内存中的位置</td><td>直到运行时才可知，表示的是一个“值”</td></tr></tbody></table><p>这时就出现了一个奇怪的现象：我们都知道，只有变量才可以作为左值，而数组名是不能作为左值的。那么数组名不是变量的话，是什么呢？</p><p>如果我们查看一下对应的汇编代码，结果是显而易见的。我们会发现，汇编代码里并没有出现数组名这个东西，<strong><em>数组名只是一个符号而已，标识数组在内存中的位置</em></strong>。但是在某些情况下，编译器会对它进行隐式的转换。<strong><em><font color="red">或者我们可以像指针类型一样，将数组名理解为一个数据类型——数组类型，表示一段连续的内存空间。</font></em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">a表示：<span class="keyword">int</span> [<span class="number">5</span>]，即可以存储<span class="number">5</span>个整形元素的一段连续的内存空间。</span><br></pre></td></tr></table></figure><p>我们看下面这样一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;b;</span><br><span class="line"></span><br><span class="line">    a = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用clang编译的话，会报如下错误</p><p><code>error: array type &#39;int [2]&#39; is not assignable</code></p><hr><blockquote><ul><li>sizeof(a)，返回整个数组的长度。</li><li>&amp;a，得到一个指向整个数组的指针，即int (*)[]。</li><li>在函数参数中，数组名被转换为一个普通的指针</li><li><font color="red">在除此之外的其他情况下，</font><font color="green">数组名将被隐式转换为一个指向数组首元素的常量指针。</font></li></ul></blockquote><p>有效的指针运算方式有如下几种：</p><blockquote><ul><li>相同类型指针之间的赋值运算。</li><li>指针同整数间的加法或减法运算。</li><li>指向相同数组中元素的两个指针间的减法或比较运算。</li><li>将指针赋为0或指针与0之间的比较运算。</li><li>最后注意一点：(void *类型指针可以与其他类型指针混用）</li></ul></blockquote><hr><h3 id="数组和指针的区别"><a href="#数组和指针的区别" class="headerlink" title="数组和指针的区别"></a>数组和指针的区别</h3><p>我们先看一下这样一组声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> *x;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> y[];</span><br></pre></td></tr></table></figure><p>第一条语句声明x是一个指向int类型的指针；第二条语句声明y是一个int类型的数组，长度尚未确定，<strong><em>其存储在别处定义。</em></strong></p><p>那么，什么是声明，什么是定义呢？</p><table><thead><tr><th>声明</th><th>定义</th></tr></thead><tbody><tr><td>可以出现在多个地方</td><td>只能出现在一个地方</td></tr><tr><td>描述对象的类型，用于指代其他地方定义的对象</td><td>确定对象的类型并为之分配内存</td></tr></tbody></table><p>两者的主要区别在于：</p><blockquote><ul><li>声明：它所说明的并非自身，而是描述其他地方创建的对象。</li><li>定义：它为对象分配内存。</li></ul></blockquote><p><strong><em>总而言之，定义是声明的一个子集。</em></strong></p><p><strong><em>extern对象声明只是告诉编译器对象的类型和名字，对象的内存分配则在别处进行。</em></strong></p><hr><p>我们再看一个这样的问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file <span class="number">1</span>: <span class="keyword">int</span> logo[<span class="number">100</span>];</span><br><span class="line">file <span class="number">2</span>: <span class="keyword">extern</span> <span class="keyword">int</span> *logo;</span><br></pre></td></tr></table></figure><p>很明显，在file 2中的写法是错误的。正确写法应当是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file <span class="number">2</span>: <span class="keyword">extern</span> <span class="keyword">int</span> logo[]; <span class="keyword">or</span> <span class="keyword">extern</span> <span class="keyword">int</span> logo[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p>可能有人会问：这有什么错误？数组和指针不是可以互换吗？答案是<font color="red">数组下标<strong><em>表达式</em></strong>总是可以改写为指针加偏移量的表达式。</font>而且也确实存在一种数组和指针完全相同的上下文环境，但并不是所有情况下都是如此。</p><p><strong>[k&amp;r]</strong>第二版[99]中有相关的描述：<font color="red">作为函数定义的形式参数，</font><strong>char s[]</strong>和<strong>char *s</strong>是等价的。</p><hr><h3 id="数组和指针分别如何访问的？"><a href="#数组和指针分别如何访问的？" class="headerlink" title="数组和指针分别如何访问的？"></a>数组和指针分别如何访问的？</h3><blockquote><ul><li><font color="red">编译器为每个变量分配一个地址，这个地址在<strong>编译时</strong>可知，</font>而且该变量在运行时一直保存于该地址。<font color="red">相反，存储于变量中的值只有在<strong>运行时</strong>才可知。</font>如果需要用到变量中存储的值，编译器就发出指令从指定地址读入变量值并将它放入寄存器中。</li><li>这里的关键之处在于：<strong><em>如果编译器需要一个地址（可能还需要加上偏移量）来执行某种操作，它就可以直接进行操作，并不需要额外的指令首先取得具体的地址。相反，对于指针，必须在运行是取得它的当前值，然后才能对它进行解引用操作。</em></strong></li></ul></blockquote><h4 id="对数组下标的引用"><a href="#对数组下标的引用" class="headerlink" title="对数组下标的引用"></a>对数组下标的引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = <span class="string">"hello"</span>;</span><br><span class="line">c = s[i];</span><br></pre></td></tr></table></figure><p>假设编译器符号表中有一个地址100</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">取出i的值，将它与100相加</span><br><span class="line">取出地址（100 + i）中的内容</span><br></pre></td></tr></table></figure><p>这就是为什么<strong>extern int logo[100]</strong> 与<strong>extern int logo[]</strong> 等价的原因。这两个声明都提示logo是一个数组，也就是一个内存地址。<strong><em>编译器并不需要知道数组有多长，因为它只产生偏离起始地址的偏移地址</em></strong>（是否会越界访问取决于程序员本身，编译器并不会进行这样的检查）。访问数组中的一个字符，只需简单地将logo的地址加上下标即可，需要的字符就在该地址中。</p><hr><h4 id="对指针的引用"><a href="#对指针的引用" class="headerlink" title="对指针的引用"></a>对指针的引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br><span class="line">c = *p;</span><br></pre></td></tr></table></figure><p>假设编译器符号表中有一个地址1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">取出地址1024中的内容，假设是5076</span><br><span class="line">取出地址5076中的内容，就是&apos;h&apos;</span><br></pre></td></tr></table></figure><hr><h4 id="如果定义为指针，却以数组下标方式引用，会发生什么？"><a href="#如果定义为指针，却以数组下标方式引用，会发生什么？" class="headerlink" title="如果定义为指针，却以数组下标方式引用，会发生什么？"></a>如果定义为指针，却以数组下标方式引用，会发生什么？</h4><p>我们都知道，数组的引用是对内存的直接引用，而指针是对内存执行间接引用的。下面我们来分析一下对一个指针执行直接引用操作，会发生什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br><span class="line">c = p[i];</span><br></pre></td></tr></table></figure><p>假设编译器符号表中有一个p，它的地址为1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">取出地址1024中的内容，假设为5076</span><br><span class="line">取得i的值，并将它与5076相加</span><br><span class="line">取出地址（5076 + i）中的内容</span><br></pre></td></tr></table></figure><p>可见，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>; ... p[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello"</span>; ... a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>这两种情况下，都可以取得字符 <strong>‘e’</strong>，但两者的途径非常不一样。</p><p>当书写了<strong>extern char *p</strong>，然后以 <strong>p[1]</strong> 的方式来引用其中的元素时，其实质是对数组下标的引用和对指针的引用两种访问方式的组合。</p><p>总结一下上面的访问过程：</p><blockquote><ul><li>取得符号表中p的地址，提取存储于此处的指针</li><li>把下标所表示的偏移量与指针的值相加，产生一个偏移地址</li><li>取得该地址中的内容</li></ul></blockquote><p><strong><em>如果把p声明为一个指针，那么不管p原先的定义是指针还是数组，都会按照上面所示的三个步骤进行操作，但只有当p原来定义为指针时这个方法才是正确的。</em></strong></p><hr><h4 id="定义为数组，却以指针的方式引用，会发生什么？"><a href="#定义为数组，却以指针的方式引用，会发生什么？" class="headerlink" title="定义为数组，却以指针的方式引用，会发生什么？"></a>定义为数组，却以指针的方式引用，会发生什么？</h4><p>即下列情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file <span class="number">1</span>: <span class="keyword">char</span> p[<span class="number">10</span>];</span><br><span class="line">file <span class="number">2</span>: <span class="keyword">extern</span> <span class="keyword">char</span> *p;</span><br></pre></td></tr></table></figure><p>当以 <strong>p[i]</strong> 的方式访问数组中的内容时：<strong><em>首先，我们取得符号表中p的地址，提取该地址中的内容，很明显会是一个字符。但按照上面的方法，编译器却会把它当作一个地址，把ascii字符解释为地址显然是驴头不对马嘴的。如果真在程序中这样做的话，很可能会污染程序地址空间中的内容，并在以后出现莫名其妙的错误。</em></strong></p><hr><h3 id="数组和指针在什么情况下是相同的"><a href="#数组和指针在什么情况下是相同的" class="headerlink" title="数组和指针在什么情况下是相同的"></a>数组和指针在什么情况下是相同的</h3><p>在实际应用中，数组和指针可以互换的情况要比两者不可互换的情况更为常见。</p><blockquote><ul><li>数组<ul><li>声明<ul><li>extern，如extern char a[]; 不能改写成指针的形式</li><li>定义，如char a[10]; 不能改写成指针的形式</li><li>函数参数，你可以随自己喜欢，选择数组或指针形式</li></ul></li><li>在表达式中使用<ul><li>如c = a[i]; 你可以随自己喜欢，选择数组或指针形式</li></ul></li></ul></li></ul></blockquote><p><strong><em>所有作为函数参数的数组名总是可以通过编译器转换为指针。在其他情况下，数组的声明就是数组，指针的声明就是指针，两者不能混淆。但在使用数组时，两者是可以互换的。</em></strong></p><hr><h3 id="三个规则"><a href="#三个规则" class="headerlink" title="三个规则"></a>三个规则</h3><h4 id="在表达式中，对数组的引用总是可以改写为对指针的引用"><a href="#在表达式中，对数组的引用总是可以改写为对指针的引用" class="headerlink" title="在表达式中，对数组的引用总是可以改写为对指针的引用"></a>在表达式中，对数组的引用总是可以改写为对指针的引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], *p, i = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>我们可以通过以下任何一种方式访问a[i]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = a; p[i];</span><br><span class="line">p = a; *(p + i);</span><br><span class="line">p = a + i; *p;</span><br></pre></td></tr></table></figure><p>事实上，可以采用的方法更多。对数组的引用a[i]在编译时总是被编译器改写为*(a + i)的形式。C标准要求编译器必须具有这个概念性的行为。也许遵循这个规则的捷径就是记住<strong><em><font color="red">[] 表示一个取下标运算符，就像 + 表示加法运算符一样。</font></em></strong></p><p>取下标运算符取一个整数和一个指向T类型的指针，所产生的结果类型是T，一个在表达式中的数组名就变成了一个指针（除过本文开始描述的几种特殊情况）。你只要记住：在表达式中，指针和数组是可以互换的，因为它们在编译器中的最终形式都是指针，而且都可以进行取下标操作。<strong><em>就像加法一样，取下标操作符的操作数是可以互换的，</em></strong>即<font color="red">a[5] 和 5[a] 这两种情况下都是正确的。</font>第二种情况除了能把新手搞晕以外，实在没什么实际意义。</p><blockquote><p>编译器自动把下标值的步长调整为数组元素的大小，在对地址进行加法操作之前，编译器会负责计算每次增加的步长，这也就是指针之所以有类型限制的原因所在。</p></blockquote><hr><h4 id="C语言把数组下标作为指针的偏移量"><a href="#C语言把数组下标作为指针的偏移量" class="headerlink" title="C语言把数组下标作为指针的偏移量"></a>C语言把数组下标作为指针的偏移量</h4><p><font color="red">在通常情况下，使用指针比使用数组”更有效率“这个说法是错误的。</font>现代的编译器常常会对代码进行优化，两种访问方式所产生的代码不具有显著的差别。但不管怎样，数组下标是定义在指针的基础上的，所以编译器常常将它转换为更有效率的指针表达式形式。</p><p><strong><em>C语言把数组下标改写成指针加偏移量的形式的根本原因是：<font color="red">指针和偏移量是底层硬件所使用的基本模型。</font></em></strong></p><hr><h4 id="作为函数参数的数组名等同于指针"><a href="#作为函数参数的数组名等同于指针" class="headerlink" title="作为函数参数的数组名等同于指针"></a>作为函数参数的数组名等同于指针</h4><p>我们首先解释两个术语：</p><blockquote><ul><li>实参：在实际调用一个函数时传递给它的值</li><li>形参：它是一个变量，在函数定义或函数声明中定义</li></ul></blockquote><p>当用一个数组名作为参数时，由于效率原因，编译器只向该函数传递数组的地址，而不是整个数组的拷贝。</p><hr><h3 id="数组形参是如何被引用的？"><a href="#数组形参是如何被引用的？" class="headerlink" title="数组形参是如何被引用的？"></a>数组形参是如何被引用的？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun(<span class="keyword">char</span> p[]);</span><br><span class="line">fun(<span class="keyword">char</span> *p);</span><br></pre></td></tr></table></figure><p>假设编译器符号表显示p可以取地址，从堆栈指针偏移一定位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从堆栈指针偏移一定位置的地方找到函数的活动记录（栈桢），取出实参，假设为1024</span><br><span class="line">取得i的值，并与1024相加</span><br><span class="line">取出地址（1024 + i）中的内容</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br>[C专家编程][Peter Van Der Linden]</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组名&quot;&gt;&lt;a href=&quot;#数组名&quot; class=&quot;headerlink&quot; title=&quot;数组名&quot;&gt;&lt;/a&gt;数组名&lt;/h3&gt;&lt;p&gt;说起数组名？绝大多数初学者是感到非常疑惑的，甚至哪怕是学习了好几年自以为懂的人，恐怕也不能够说得明明白白、清清楚楚。那么，它到底是个什么东西呢？&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="https://yaoer.me/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>将Vim打造成一个C/C++IDE</title>
    <link href="https://yaoer.me/2018/10/22/vim-IDE/"/>
    <id>https://yaoer.me/2018/10/22/vim-IDE/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-22T15:25:46.400Z</updated>
    
    <content type="html"><![CDATA[<p>当你不知从哪里听过Vim的鼎鼎大名而信心满满的去安装它后，你打开Vim的界面后是这样的：什么也没有，就是一个黑框框。然后你想尝试打几个字，结果发现终端一直在嘟嘟的响。这时你的心里一定会大失所望，这都是什么啊。<br><a id="more"></a></p><p><img src="https://github.com/yaomer/pictures/blob/master/v2.png?raw=true" alt=""></p><p>但请不要就此放弃，你可以把Vim看作一匹充满野性的烈马，需要你付出许多努力去驯服它，从而让它乖乖地为你服务，成为你的好帮手。</p><p>实际上，Vim最大的特性就是它的<code>可定制性和可扩展性</code>。因此，当你与它初次相遇时，它就是一块未经打磨的璞玉，一柄未经开封的利刃。你需要自己去打磨它，磨亮它。让它成为一把编辑器中的<code>瑞士军刀</code>。真正的无愧于它编辑器之神的称号。</p><p>之后我推荐你去看Vim最好的入门教程，它只需花费你半小时不到的时间，然后就可以进入下面的打造之路了。</p><p><code>$ vimtutor</code></p><hr><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>我们写代码的基本需求就是要有一点语法高亮，最起码不能是那样的丑陋吧，然后可能还要有对应的行号等等这样一些基本的需求，然后我们写代码可能就会好受一些了。</p><p>这些基本配置包括后面提到的所有插件都需要用到一个叫做<code>.vimrc</code>的文件，顾名思义，这就是Vim的配置文件。在Unix/Linux系统中，它一般在家目录下，你可以使用<code>$ ls -a | grep &quot;.vimrc&quot;</code>命令检查一下，如果没有的话，就自己创建一个。</p><p>然后我们加入一些最简单、最基本的配置，Vim的模样就会变得不一样了，最起码是有点颜色了。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">filetype</span> <span class="keyword">on</span>           <span class="comment">" 开启文件类型检测</span></span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="keyword">on</span>.   <span class="comment">" 设置加载对应文件类型的插件              </span></span><br><span class="line"><span class="keyword">colorscheme</span> desert    <span class="comment">" 语法高亮主题</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>             <span class="comment">" 开启语法高亮</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>            <span class="comment">" 显示行号</span></span><br><span class="line"><span class="keyword">set</span> noerrorbells      <span class="comment">" 关闭出错响铃</span></span><br><span class="line"><span class="keyword">set</span> autoindent        <span class="comment">" 自动缩进</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span>           <span class="comment">" 使用C/C++的自动缩进方式</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span>         <span class="comment">" 将tab设置为4个空格</span></span><br><span class="line"><span class="keyword">set</span> expandtab         <span class="comment">" 将tab扩展为空格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>      <span class="comment">" 每一级缩进为4个空格</span></span><br></pre></td></tr></table></figure><p>然后在重新打开你的Vim，你就会感到有所惊喜了。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v1.png?raw=true" alt=""></p><p>当然这些配置只是最基本的，Vim还有许多别的有用的配置，这就要根据你自己的需要去配置了。在本文最后，我会给出我的<code>.vimrc</code>，大家可以略作参考。</p><p>然后我们正式进入主题。</p><hr><h3 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h3><p>在谈下面的内容之前，我们首先需要选择一款插件管理器，随着我们安装插件数量的增多，为了方便我们管理也为了以后更方便地安装新插件，这都是我们必须要做的。</p><p>我极力推荐大家使用<code>Plug</code>，它是一款极简主义的Vim插件管理器，与老旧的<code>Vundle</code>相比，它的最大优点是超高速并行安装。除此之外，它还可以延迟加载插件，从而加快Vim的启动速度，这个我们最后会提到的。</p><p><img src="https://raw.githubusercontent.com/junegunn/i/master/vim-plug/installer.gif" alt=""></p><p>运行如下命令安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>它的用法也很简单。首先在你的vimrc中加入以下两行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">'~/.vim/plugged'</span>)</span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure><p>如果你要安装一个插件，就<code>Plug &#39;插件名&#39;</code>，然后把这行加到那两行中间即可，之后在Vim中运行<code>:PlugInstall</code>即可自动安装。</p><p>因此，以下提到的插件我不再说明安装方法，都是以这种方式安装的。</p><hr><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><h4 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h4><p>Vim本身自带了一些语法高亮主题，这些主题文件一般在<code>/usr/share/vim/vim80/colors/</code>目录下。你可以自己分别尝试下，不过这些高亮都相对来说比较简单，对于函数、运算符之类的都无法高亮。</p><p>这里我想推荐大家使用的是<code>monokai</code>主题，用过sublime的人应该会对它印象深刻。这个主题用的人应该来说相当多，你也可以根据自己的审美喜好对它进行个性化的定制。</p><p>定制非常简单。比如说monokai中函数默认的配色是<code>green</code>。如果你想更换为别的颜色，你只需修改对应的颜色字段即可。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> <span class="variable">s:h</span>(<span class="string">"Function"</span>, &#123; <span class="string">"fg"</span>: <span class="variable">s:green</span> &#125;)</span><br></pre></td></tr></table></figure><p>如果你想要除了已有的颜色之外的其他颜色，那么你只需要根据自己的需要查询<code>Vim颜色表</code>去修改诸如<code>&quot;186&quot;</code>这样的颜色值即可。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s:yellow</span> = &#123; <span class="string">"gui"</span>: <span class="string">"#E6DB74"</span>, <span class="string">"cterm"</span>: <span class="string">"186"</span> &#125;</span><br></pre></td></tr></table></figure><p>对于monokai主题，我推荐大家安装<code>crusoexia/vim-monokai</code>这个插件，因为vim-monokai可能不止一个。这个插件的代码结构是比较清晰的，易于我们阅读，也易于修改。</p><h4 id="语法高亮增强"><a href="#语法高亮增强" class="headerlink" title="语法高亮增强"></a>语法高亮增强</h4><p>对于C的语法高亮，这个主题是足以胜任的。但对于C++的一些STL，它还不能够高亮。但通过一个插件，就可以弥补这个缺陷。</p><p>这个插件是<code>&#39;octol/vim-cpp-enhanced-highlight&#39;</code>，它提供了对C++语法高亮的增强。除此之外，还可以高亮运算符，只不过需要简单的设置。</p><p>找到<code>c.vim</code>这个文件，取消下面这些行的注释即可。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">"  Additional optional highlighting</span></span><br><span class="line"><span class="comment">" -----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Operators</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>\(&lt;&lt;\|&gt;&gt;\|[-+*/%&amp;^|&lt;&gt;!=]\)=<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>&lt;&lt;\|&gt;&gt;\|&amp;&amp;\|||\|++\|--\|-&gt;<span class="comment">"</span></span><br><span class="line">" syn match cOperator"[.!~*&amp;%&lt;&gt;^|=,;?:+-]"</span><br><span class="line"><span class="string">" syn match cOperator"</span>/[^/*=]<span class="comment">"me=e-1</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>/$<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator  "</span>&amp;&amp;\|||<span class="comment">"</span></span><br><span class="line"><span class="string">" syn match cOperator"</span>[][]<span class="comment">"</span></span><br></pre></td></tr></table></figure><h4 id="彩虹括号"><a href="#彩虹括号" class="headerlink" title="彩虹括号"></a>彩虹括号</h4><p>当代码中出现多级嵌套的时候，<code>kien/rainbow_parentheses.vim</code>这个插件会很有用。它可以很明显的显示出不同括号内的代码层次。</p><p>这里我上一张我修改过的代码高亮配色的图吧。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v3.png?raw=true" alt=""></p><p>配置如下。其中我删除了几种不太易辨认的颜色，如深蓝色、黑色。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:rbpt_colorpairs</span> = [</span><br><span class="line">    \ [<span class="string">'darkgreen'</span>,   <span class="string">'firebrick3'</span>],</span><br><span class="line">    \ [<span class="string">'red'</span>,         <span class="string">'firebrick3'</span>],</span><br><span class="line">    \ [<span class="string">'darkmagenta'</span>, <span class="string">'DarkOrchid3'</span>],</span><br><span class="line">    \ [<span class="string">'darkcyan'</span>,    <span class="string">'RoyalBlue3'</span>],</span><br><span class="line">    \ [<span class="string">'darkgreen'</span>,   <span class="string">'RoyalBlue3'</span>],</span><br><span class="line">    \ [<span class="string">'darkmagenta'</span>, <span class="string">'DarkOrchid3'</span>],</span><br><span class="line">    \ [<span class="string">'darkcyan'</span>,    <span class="string">'SeaGreen3'</span>],</span><br><span class="line">    \ ]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:rbpt_max</span> = <span class="number">16</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:rbpt_loadcmd_toggle</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">au</span> VimEnter * RainbowParenthesesToggle</span><br><span class="line"><span class="keyword">au</span> Syntax * RainbowParenthesesLoadRound</span><br><span class="line"><span class="keyword">au</span> Syntax * RainbowParenthesesLoadSquare</span><br><span class="line"><span class="keyword">au</span> Syntax * RainbowParenthesesLoadBraces</span><br></pre></td></tr></table></figure><hr><h3 id="漂亮的状态栏"><a href="#漂亮的状态栏" class="headerlink" title="漂亮的状态栏"></a>漂亮的状态栏</h3><p>作为一名颜值党，暂且不提Vim别的功能，最起码要看来漂亮动人才行吧。那么没有一个好看的状态栏怎么行呢！而<code>vim-airline/vim-airline</code>正是这样一款优秀的状态栏插件，现在它基本上已经取代了<code>powerline</code>。</p><p>它的配色非常多，可以说是只要你想要的，应该都能找到，我这里给出几个我觉得漂亮的吧。</p><p><img src="https://github.com/vim-airline/vim-airline/wiki/screenshots/demo.gif" alt=""></p><p><img src="https://user-images.githubusercontent.com/9622/45275524-52f45c00-b48b-11e8-8b83-a66240b10747.gif" alt=""></p><p>更多的大家自己去看吧。</p><p>还有一个需要顺带下载的插件是它的主题<code>&#39;vim-airline/vim-airline-themes&#39;</code>，我当初就是把它主题下的所有主题都试了一遍，才找到自己喜欢的。<code>^0^</code>希望大家不要像我一样o。</p><p>airline由于要显示一些图形字符，所以它需要使用一些<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">特定的字体</a>。</p><hr><h3 id="自动补全括号"><a href="#自动补全括号" class="headerlink" title="自动补全括号"></a>自动补全括号</h3><p>当我们码代码的时候，如果每次输入一个<code>(</code>之后，稍后还得记得输入另一个配对的<code>)</code>是不是很麻烦，而且有时候还会忘记另一个<code>)</code>。</p><p><code>jiangmiao/auto-pairs</code>插件的作用就是自动补全另一个配对的括号。</p><hr><h3 id="代码自动补全"><a href="#代码自动补全" class="headerlink" title="代码自动补全"></a>代码自动补全</h3><p>代码自动补全首推YCM了，具体的安装配置过程可以参照我的另一篇博客<a href="https://yaoer.me/2018/10/21/YCM/#more">Mac安装配置YCM</a>，在Unix/Linux下过程应该是差不多的。</p><hr><h3 id="函数参数列表补全"><a href="#函数参数列表补全" class="headerlink" title="函数参数列表补全"></a>函数参数列表补全</h3><p>如果你YCM安装成功了，在你体验着它便利的同时，你应该会有另一个棘手的问题：<strong><em>对于函数参数无法补全</em></strong>。</p><p>在补全列表中是可以看到参数列表的，当当你键入<code>(</code>后，参数列表就消失了。对于一些常见的函数，我们可能不依赖于函数参数补全。但对于一个稍显生僻的函数或者参数表特别长的函数，我们显而易见需要参数补全，因为我们可能会忘掉参数或者搞错参数顺序。</p><p><code>tenfyzhong/CompleteParameter.vim</code>正是这样一个与YCM完美配合的插件。</p><p><img src="https://camo.githubusercontent.com/5ff72790ae3d6bf6c964cf3b59bdc0985268b190/687474703a2f2f7778342e73696e61696d672e636e2f6d773639302f36393437323232336779316668796a76726a68723367323068733061307162792e676966" alt=""></p><p>一旦你键入<code>(</code>后，它会将该函数的参数列表显示出来，和一般IDE的补全是没有什么两样的，填完一个参数后，你可以使用<code>ctr + j</code>跳转到下一个参数，直到填完所有参数，最后跳到<code>)</code>外面。</p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;expr&gt;</span> ( complete_parameter#pre_complete(<span class="string">"()"</span>)</span><br><span class="line"><span class="keyword">smap</span> <span class="symbol">&lt;c-j&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_next_parameter)</span><br><span class="line"><span class="keyword">imap</span> <span class="symbol">&lt;c-j&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_next_parameter)</span><br><span class="line"><span class="keyword">smap</span> <span class="symbol">&lt;c-k&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_previous_parameter)</span><br><span class="line"><span class="keyword">imap</span> <span class="symbol">&lt;c-k&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(complete_parameter#goto_previous_parameter)</span><br></pre></td></tr></table></figure><hr><h3 id="跳转到声明或定义处"><a href="#跳转到声明或定义处" class="headerlink" title="跳转到声明或定义处"></a>跳转到声明或定义处</h3><p>这里我们不使用<code>ctags</code>，因为对于C/C++来说，YCM原生支持这些操作，而且使用起来非常方便。</p><p>在你的vimrc中加入下面这一句：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" 跳转到声明或定义处</span></span><br><span class="line"><span class="string">nnoremap &lt;silent&gt;&lt;leader&gt;j :YcmCompleter GoToDefinitionElseDeclaration&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><p>具体的键位映射需要你根据自己的方便设置。</p><hr><h3 id="树形目录"><a href="#树形目录" class="headerlink" title="树形目录"></a>树形目录</h3><p><code>scrooloose/nerdtree</code>插件可以显示树形目录。</p><p><code>tiagofumo/vim-nerdtree-syntax-highlight</code>插件可以高亮nerdtree显示的文件类型。</p><p><code>xuyuanp/nerdtree-git-plugin</code>插件可以显示git状态。</p><p>这三个插件大家可以一起配套下载使用。</p><p><img src="https://github.com/yaomer/pictures/blob/master/v4.png?raw=true" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" nerdtree</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span>n :NERDTreeToggle<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeFileExtensionHighlightFullName</span>    = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeExactMatchHighlightFullName</span>       = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreePatternMatchHighlightFullName</span>     = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeHighlightFolders</span>                  = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeHighlightFoldersFullName</span>          = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeDirArrowExpandable</span>                = <span class="string">'▷'</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeDirArrowCollapsible</span>               = <span class="string">'▼'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" nerdtree-git-plugin</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeIndicatorMapCustom</span> = &#123;</span><br><span class="line">            \ <span class="string">"Modified"</span>  : <span class="string">"✹"</span>,</span><br><span class="line">            \ <span class="string">"Staged"</span>    : <span class="string">"✚"</span>,</span><br><span class="line">            \ <span class="string">"Untracked"</span> : <span class="string">"✭"</span>,</span><br><span class="line">            \ <span class="string">"Renamed"</span>   : <span class="string">"➜"</span>,</span><br><span class="line">            \ <span class="string">"Unmerged"</span>  : <span class="string">"═"</span>,</span><br><span class="line">            \ <span class="string">"Deleted"</span>   : <span class="string">"✖"</span>,</span><br><span class="line">            \ <span class="string">"Dirty"</span>     : <span class="string">"✗"</span>,</span><br><span class="line">            \ <span class="string">"Clean"</span>     : <span class="string">"✔︎"</span>,</span><br><span class="line">            \ <span class="string">'Ignored'</span>   : <span class="string">'☒'</span>,</span><br><span class="line">            \ <span class="string">"Unknown"</span>   : <span class="string">"?"</span></span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="显示类、方法、变量"><a href="#显示类、方法、变量" class="headerlink" title="显示类、方法、变量"></a>显示类、方法、变量</h3><p><code>majutsushi/tagbar</code>插件可以让我们整体把握整个文件的结构。</p><p><img src="https://camo.githubusercontent.com/fc85311154723793776aed28488befdfaab36c42/68747470733a2f2f692e696d6775722e636f6d2f5366394c7332722e706e67" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:tagbar_width</span> = <span class="number">30</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span>t :TagbarToggle<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="快速代码注释"><a href="#快速代码注释" class="headerlink" title="快速代码注释"></a>快速代码注释</h3><p>当我们在debug时，经常需要注释一段可能会出错的代码来查看程序的运行行为，这个时候，<code>scrooloose/nerdcommenter</code>插件就非常有用，它可以让我们非常方便的注释或者反注释代码段。</p><p>它的简单用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;leader&gt;cc         注释一行</span><br><span class="line">&lt;leader&gt;cu         取消注释</span><br><span class="line">&lt;leader&gt;cm         注释(Visual)选中的一段代码</span><br></pre></td></tr></table></figure><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDSpaceDelims</span>               = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDCompactSexyComs</span>           = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDDefaultAlign</span>              = <span class="string">'left'</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDCommentEmptyLines</span>         = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTrimTrailingWhitespace</span>    = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDToggleCheckAllLines</span>       = <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h3 id="文件模糊搜索"><a href="#文件模糊搜索" class="headerlink" title="文件模糊搜索"></a>文件模糊搜索</h3><p>文件模糊查找在我们日常工作应该经常要用到，与其使用速度较慢的<code>find</code>命令，<code>Yggdroot/LeaderF</code>插件可以帮助我们在大型项目中快速定位文件。而且除过模糊查找之外，它还有很多其他功能，我这里就不多说了。</p><p><img src="https://github.com/Yggdroot/Images/raw/master/leaderf/leaderf_1.gif" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> :LeaderfFile<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_WildIgnore</span> = &#123;</span><br><span class="line">            \ <span class="string">'dir'</span>: [<span class="string">'.svn'</span>,<span class="string">'.git'</span>,<span class="string">'.hg'</span>,<span class="string">'.vscode'</span>,<span class="string">'.wine'</span>,<span class="string">'.deepinwine'</span>,<span class="string">'.oh-my-zsh'</span>],</span><br><span class="line">            \ <span class="string">'file'</span>: [<span class="string">'*.sw?'</span>,<span class="string">'~$*'</span>,<span class="string">'*.bak'</span>,<span class="string">'*.exe'</span>,<span class="string">'*.o'</span>,<span class="string">'*.so'</span>,<span class="string">'*.py[co]'</span>]</span><br><span class="line">            \&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_UseCache</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h3 id="更快速高效地移动"><a href="#更快速高效地移动" class="headerlink" title="更快速高效地移动"></a>更快速高效地移动</h3><p>Vim本身已经为我们提供了许多有用的组合键来帮助我们快速高效的移动，但那些大多是小范围的局部移动，而且也并不太准确。</p><p><code>easymotion/vim-easymotion</code>插件可以帮助我们快速准确的定位，让我们的移动一击即中。</p><p><img src="https://camo.githubusercontent.com/d5f800b9602faaeccc2738c302776a8a11797a0e/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f333739373036322f323033393335392f61386539333864362d383939662d313165332d383738392d3630303235656138333635362e676966" alt=""></p><p>配置如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;Leader&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-prefix)</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:EasyMotion_do_mapping</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">j</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">j</span>)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">k</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">k</span>)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>h <span class="symbol">&lt;Plug&gt;</span>(easymotion-linebackward)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">l</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-lineforward)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>s <span class="symbol">&lt;Plug&gt;</span>(easymotion-s)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">w</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">bd</span>-<span class="keyword">w</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="延迟加载Vim插件"><a href="#延迟加载Vim插件" class="headerlink" title="延迟加载Vim插件"></a>延迟加载Vim插件</h3><p>随着我们安装插件的增多，Vim的启动速度不可避免的会变慢，当达到某个临界点之后，这种略显卡顿的启动就不是我们能接受的了。它会非常影响我们编辑文本的心情。</p><p>当幸运的是，Vim的最新版本提供了延迟加载插件的机制，这可以帮助我们将那些在初打开文件时不用的且较重的插件延迟加载，即打开文件后再加载。这样就能显著提高Vim的启动速度了。</p><p>具体操作如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" 延迟加载YCM</span></span><br><span class="line"><span class="string">Plug 'Valloric/YouCompleteMe', &#123; 'on': [] &#125;             </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 100ms后调用LoadPlug，且只调用一次</span><br><span class="line">call timer_start(100, <span class="string">'LoadPlug'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>! LoadPlug(timer) abort</span><br><span class="line">    call plug<span class="comment">#load('YouCompleteMe')</span></span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你不知从哪里听过Vim的鼎鼎大名而信心满满的去安装它后，你打开Vim的界面后是这样的：什么也没有，就是一个黑框框。然后你想尝试打几个字，结果发现终端一直在嘟嘟的响。这时你的心里一定会大失所望，这都是什么啊。&lt;br&gt;
    
    </summary>
    
      <category term="vim" scheme="https://yaoer.me/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac安装配置YCM</title>
    <link href="https://yaoer.me/2018/10/21/YCM/"/>
    <id>https://yaoer.me/2018/10/21/YCM/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-10-21T12:37:24.995Z</updated>
    
    <content type="html"><![CDATA[<p>YCM的大名在这里就不消多说了。下面我们就来说说如何安装吧。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>YCM算是Vim插件中比较重的了，而且与其他插件不同的是，它是一个带有编译组件的插件。因此也就导致了在安装过程可能会出现各种意想不到的问题。<br><a id="more"></a></p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>在正式安装YCM之前需要安装一些依赖工具。</p><h4 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h4><p>可以说是homebrew使得Mac的软件生态变得完整，因为它是一个非常好用的包管理工具。我们下面提到的一些依赖都可以通过它很方便地安装。</p><p>可以在终端运行以下ruby脚本安装brew:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>它的用法很简单，比如说安装Vim。</p><p><code>$ brew install vim</code></p><p>运行<code>brew uninstall vim</code>即可卸载。</p><h4 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h4><p>确保你的Vim版本是最新的，且要支持py2或py3。Mac系统自带的Vim版本比较老，你最好使用brew安装最新的版本。可以通过以下命令查看：</p><p><code>$ vim --version</code></p><p>如果输出中包含<code>+python或+python3</code>，就说明你的Vim支持py2或py3。</p><p>如果你的Vim不支持python，那么你可能就需要<a href="https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source" target="_blank" rel="noopener">从源码编译安装Vim</a>了，不过别担心，它的过程很简单。</p><h4 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h4><p><code>$ brew install CMake</code></p><h4 id="Command-Line-Tools"><a href="#Command-Line-Tools" class="headerlink" title="Command Line Tools"></a>Command Line Tools</h4><p>如果你需要C-Family语言补全的话，你就需要安装以上命令行工具。它们在你第一次运行clang时自动安装，也可以通过手工安装：</p><p><code>$ xcode-select --install</code></p><h4 id="pythen-dev"><a href="#pythen-dev" class="headerlink" title="pythen-dev"></a>pythen-dev</h4><p>Mac系统已经默认安装。不过这里需要注意的是：</p><blockquote><p><strong><em>你千万不要在私下去安装一个新的python2，不然会导致YCM在安装和编译中使用不同的python2版本，从而会产生冲突。</em></strong></p></blockquote><p>如果你已经使用brew安装了，那么你可能需要卸载它。这或许会使你的问题得到解决。</p><p><code>$ brew uninstall python@2</code></p><h3 id="YCM"><a href="#YCM" class="headerlink" title="YCM"></a>YCM</h3><p>安装YCM这里推荐使用Plug安装，当然你使用Vundle也可以。</p><p>在你的.vimrc中加入以下代码段。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call plug<span class="comment">#begin('~/.vim/plugged')</span></span><br><span class="line">Plug <span class="string">'Valloric/YouCompleteMe'</span></span><br><span class="line">call plug<span class="comment">#end()</span></span><br></pre></td></tr></table></figure><p>然后在Vim中输入<code>:PlugInstall</code>等待自动安装结束即可。这个过程可能会有点久，需要耐心等待。</p><p>如果你不是使用Plug或Vundle安装的，那么你就需要保证YCM安装包的完整性。可以运行下列命令检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>安装成功后，接下来就需要进入编译环节了。编译过程实际上很简单，运行一个脚本就行了。但如果在脚本运行过程中出了点问题，那么你可能就需要完整地一步一步地编译YCM了。</p><hr><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="直接运行安装脚本"><a href="#直接运行安装脚本" class="headerlink" title="直接运行安装脚本"></a>直接运行安装脚本</h3><p>如果你需要C-Family语言补全，则运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.vim/Plug/YouCompleteMe</span><br><span class="line">$ ./install.py --clang-completer</span><br></pre></td></tr></table></figure><p>否则，直接运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.vim/Plug/YouCompleteMe</span><br><span class="line">$ ./install.py</span><br></pre></td></tr></table></figure><p>如果你幸运的编译成功了，那么直接跳转到配置过程中。否则，进入下一步。</p><h3 id="一步一步编译"><a href="#一步一步编译" class="headerlink" title="一步一步编译"></a>一步一步编译</h3><p>如果你和我当初一样失败了，那么可能就需要进行下面这些比较繁琐的安装过程了。</p><p>如果你关心C-Family语言语义支持，完成下面步骤：</p><h4 id="下载最新版本的libclang"><a href="#下载最新版本的libclang" class="headerlink" title="下载最新版本的libclang"></a>下载最新版本的libclang</h4><p>libclang它提供的库用于为这些语言提供YCM语义完成引擎。</p><p>只有在你确定它是3.9或更高版本时才可以使用系统libclang，否则不能。但即使它是，YCM官方也建议尽可能使用<a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener">llvm.org</a>的官方二进制文件。这确保为你的操作系统下载正确的存档文件。</p><h4 id="编译ycm-core"><a href="#编译ycm-core" class="headerlink" title="编译ycm_core"></a>编译ycm_core</h4><p>这个库是YCM用来获得快速补全的C++引擎。</p><p>在这里，我假设你使用Plug安装了YCM。这意味着YCM的顶级目录在<code>~/.vim/Plug/YouCompleteMe</code>。</p><p>我们将创建一个新文件夹，其中将放置构建文件。运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ mkdir ycm_build</span><br><span class="line">$ cd ycm_build</span><br></pre></td></tr></table></figure><p>现在我们需要生成Makefile。如果你不关心C-Family语言的语义支持，就请在ycm_build 目录中运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -G &quot;Unix Makefiles&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</span><br></pre></td></tr></table></figure><p>如果你关心C-Family语言的语义支持，那么CMake的调用就会更复杂些。我们假设你在llvm.org中下载的LLVM + Clang的二进制发行版，你提取的存档文件放到了文件夹<code>~/ycm_temp/llvm_root_dir</code>中。</p><p>然后在<code>ycm_build</code>目录中运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -G &quot;Unix Makefiles&quot; -DPATH_TO_LLVM_ROOT=~/ycm_temp/llvm_root_dir . ~/.vim/Plug/YouCompleteMe/third_party/ycmd/cpp</span><br></pre></td></tr></table></figure><p>现在已经生成了配置文件，使用以下命令编译库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build . --target ycm_core</span><br></pre></td></tr></table></figure><p>至此YCM就已经安装完成了，<code>ycm_build</code>和<code>ycm_temp</code>目录都可以删除了，不影响使用。</p><p>如果你中间还是出现了一些问题，那么请你仔细按照以上过程重新尝试安装。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置过程需要编辑两个文件：<code>vimrc</code>和<code>.ycm_extra_conf.py</code>。</p><p>在你的终端运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo | clang -v -E -x c++ -</span><br></pre></td></tr></table></figure><p>将输出结果中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;...&quot; search starts here:</span><br><span class="line">#include &lt;...&gt; search starts here:</span><br></pre></td></tr></table></figure><p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">End of search list.z</span><br></pre></td></tr></table></figure></p><p>之间的部分添加到<code>.ycm_extra_conf.py</code>中的<code>-isystem</code>后。</p><p>然后将一下代码段加入到你的vimrc中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> g:ycm_server_python_interpreter=<span class="string">'/usr/bin/python'</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_global_ycm_extra_conf = <span class="string">'~/.vim/plugged/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py'</span></span><br><span class="line"><span class="string">" 让vim的补全菜单行为与一般IDE一致</span></span><br><span class="line"><span class="string">set completeopt=longest,menu</span></span><br><span class="line"><span class="string">"</span> 触发(符号)补全时需要键入的字符数</span><br><span class="line"><span class="built_in">let</span> g:ycm_min_num_of_chars_for_completion = 1</span><br><span class="line"><span class="string">" 补全候选项的最小字符数</span></span><br><span class="line"><span class="string">let g:ycm_min_num_identifier_candidate_chars = 0</span></span><br><span class="line"><span class="string">"</span> 关闭诊断显示功能(已经使用了ale进行异步语法检查)</span><br><span class="line"><span class="built_in">let</span> g:ycm_show_diagnostics_ui = 0</span><br><span class="line"><span class="string">" 在字符串和注释中仍会触发补全</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_comments = 1</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_strings = 1</span></span><br><span class="line"><span class="string">"</span> 禁止缓存匹配项，每次重新生成匹配项</span><br><span class="line"><span class="built_in">let</span> g:ycm_cache_omnifunc = 0</span><br><span class="line"><span class="string">" 在用户接受提供的完成字符串后自动关闭窗口</span></span><br><span class="line"><span class="string">let g:ycm_autoclose_preview_window_after_completion = 0</span></span><br><span class="line"><span class="string">"</span> 跳转到声明或定义处</span><br><span class="line">nnoremap &lt;silent&gt;&lt;leader&gt;gj :YcmCompleter GoToDefinitionElseDeclaration&lt;cr&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">" 自动触发语义补全</span></span><br><span class="line"><span class="string">let g:ycm_semantic_triggers =  &#123;</span></span><br><span class="line"><span class="string">            \ 'c,cpp,python,java,go,erlang,perl': ['re!\w&#123;1&#125;'],</span></span><br><span class="line"><span class="string">            \ 'cs,lua,javascript': ['re!\w&#123;1&#125;'],</span></span><br><span class="line"><span class="string">            \ &#125;</span></span><br><span class="line"><span class="string">"</span> 遇到下列文件时才会开启YCM</span><br><span class="line"><span class="built_in">let</span> g:ycm_filetype_whitelist = &#123;</span><br><span class="line">            \ <span class="string">"c"</span>:1,</span><br><span class="line">            \ <span class="string">"cpp"</span>:1,</span><br><span class="line">            \ <span class="string">"python"</span>:1,</span><br><span class="line">            \ <span class="string">"sh"</span>:1,</span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure><p>接下来你就可以享受YCM带来的如丝般柔滑地补全了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;YCM的大名在这里就不消多说了。下面我们就来说说如何安装吧。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;YCM算是Vim插件中比较重的了，而且与其他插件不同的是，它是一个带有编译组件的插件。因此也就导致了在安装过程可能会出现各种意想不到的问题。&lt;br&gt;
    
    </summary>
    
      <category term="vim" scheme="https://yaoer.me/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树的基本操作</title>
    <link href="https://yaoer.me/2018/10/21/bst/"/>
    <id>https://yaoer.me/2018/10/21/bst/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-10-23T06:27:25.789Z</updated>
    
    <content type="html"><![CDATA[<p>顾名思义，二叉搜索树就是以二叉树来组织的。而二叉树是一颗有根树，它的每个节点至多有两个子节点。</p><p>二叉搜索树的每个节点通常是这样组织的：<strong><em>一个指向左子树的指针、一个指向右子树的指针、关键字以及卫星数据</em></strong>。在某些情况下，还可以对树节点作一些更改，比如增加一个指向父节点的指针，这样做的目的是有助于更好地完成某些操作。</p><a id="more"></a><p>二叉搜索树也叫二叉排序树，它具有如下性质：</p><blockquote><p>设x是二叉搜索树中的一个节点。如果y是x的左子树中的一个节点，那么总有y.key &lt; x.key；如果y是x的右子树中的一个节点，那么总有y.key &gt; x.key。</p></blockquote><p>换句话说，就是<strong><em>对于任意一个节点来说，它的左子树中的所有节点的关键字都小于它自身的关键字，它的右子树中的所有节点的关键字都大于它自身的关键字。</em></strong></p><p>还有一点需要注意的就是 <strong><em>树中具有相同关键字的节点不能重复出现</em></strong>。要想解决这个问题其实也很容易，只需在树节点中增加一个<strong>count域</strong>，插入时如果遇见相同的节点，就将count加1，删除时类似。我们下面的讨论假设所有的元素都是互异的。</p><p>接下来，我们会发现二叉搜索树和快排是多么的相似。<font color="purple">^o\^</font></p><p><img src="https://github.com/yaomer/pictures/blob/master/bst.png?raw=true" alt=""></p><hr><p>下面我们给出一些二叉搜索树的基本操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> &#123;</span>     <span class="comment">/*  树节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; Tnode;</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><blockquote><p>查找操作通常需要返回指向树中具有某个关键字的节点的指针，如果不存在则返回NULL。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  search_tree函数（递归版本）：在树中查找某个值  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">search_tree</span><span class="params">(Tnode *p, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || val == p-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; p-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> search_tree(p-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> search_tree(p-&gt;right, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于树本身是递归定义的，所以这种递归操作是如此的容易，以至于让很多人不厌其烦地使用它。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  search_tree函数（迭代版本）：在树中查找某个值  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">search_tree</span><span class="params">(Tnode *p, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; val != p-&gt;val)</span><br><span class="line">        <span class="keyword">if</span> (val &lt; p-&gt;val)</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; p-&gt;val)</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>迭代版本也是简单而直接的，只需展开递归即可。对于绝大多数计算机来说，迭代版本的效率要更高一些。</p></blockquote><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>二叉搜索树的遍历根据何时输出子树根的关键字可分为三种：</p><blockquote><ul><li>先序遍历：输出的子树根的关键字在其左右子树的关键字之前</li><li>中序遍历：输出的子树根的关键字在其左右子树的关键字之间</li><li>后序遍历：输出的子树根的关键字在其左右子树的关键字之后</li></ul></blockquote><p><strong><em>所谓中序遍历，就是先遍历左子树，然后是当前结点(子树根节点)，最后是右子树</em></strong>。其他两种遍历操作类似。不过中序遍历常常是有用的，因为它从小到大输出树中所有节点的关键字。</p><p>在表达式树中，这三种遍历方法通常产生三种表达式：即前缀表达式、中缀表达式和后缀表达式。</p><blockquote><p><code>应当注意的是</code>：<strong><em>树的遍历需要花费O(n)的时间，而不是像其他操作一样花费O(log n)的时间。这是因为它需要遍历树的每一个节点。</em></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  travel_pre函数：先序遍历  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel_pre</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;val);</span><br><span class="line">        travel_pre(p-&gt;left);</span><br><span class="line">        travel_pre(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  travel_in函数：中序遍历  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel_in</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        travel_in(p-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;val);</span><br><span class="line">        travel_in(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  travel_post函数：后序遍历  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel_post</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        travel_post(p-&gt;left);</span><br><span class="line">        travel_post(p-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回最大关键字元素和最小关键字元素"><a href="#返回最大关键字元素和最小关键字元素" class="headerlink" title="返回最大关键字元素和最小关键字元素"></a>返回最大关键字元素和最小关键字元素</h3><blockquote><p>由于二叉搜索树自身的性质，这两种操作也是相当简单的。我们一种用递归实现，一种用迭代实现。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  mintree函数：返回树中的最小节点  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">mintree</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> mintree(p-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  maxtree函数：返回树中的最大节点  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">maxtree</span><span class="params">(Tnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><blockquote><p>插入和删除操作会引起由二叉搜索树表示的动态集合的变化，因此我们要对树做一些修改来维护树本身的性质。插入一个节点要相对简单些，而删除的处理则有些复杂。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  addtree函数：在树中插入一个节点  */</span></span><br><span class="line"><span class="function">Tnode *<span class="title">addtree</span><span class="params">(Tnode *p, <span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;   <span class="comment">/*  找到了插入位置  */</span></span><br><span class="line">        <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tnode))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;val = new_val;</span><br><span class="line">        p-&gt;left = p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (new_val &lt; p-&gt;val)</span><br><span class="line">        p-&gt;left = addtree(p-&gt;left, new_val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (new_val &gt; p-&gt;val)</span><br><span class="line">        p-&gt;right = addtree(p-&gt;right, new_val);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>对于删除二叉搜索树中的一个节点，可能有如下三种情况：</p><blockquote><ul><li>没有子节点，它可以立即被删除</li><li>只有一个子节点，可以通过调整其父节点中的指针，使指针绕过该节点后而被删除</li><li>有两个子节点，下面作详细说明</li></ul></blockquote><p>第一种情况其实是可以归结到第二种情况中的。比较令人棘手的问题就是第三种情况的处理了。虽然它看起来是比较复杂的，但是由于二叉搜索树本身的性质，我们可以用一种简单的方法来处理它。即 <strong><em><font color="red">用待删除节点的后继节点中的数据来替换待删除节点中的数据，然后再删除其后继节点。</font></em></strong><br><strong><em>由于在这种情况下，待删除节点的右子树非空，所以其后继节点即为其右子树中的最小节点。</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tnode *<span class="title">deltree</span><span class="params">(Tnode *p, <span class="keyword">int</span> old_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tnode *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (old_val &lt; p-&gt;val)</span><br><span class="line">        p-&gt;left = deltree(p-&gt;left, old_val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (old_val &gt; p-&gt;val)</span><br><span class="line">        p-&gt;right = deltree(p-&gt;right, old_val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;left &amp;&amp; p-&gt;right) &#123;   <span class="comment">/*  待删除节点有两个孩子  */</span></span><br><span class="line">        tmp = mintree(p-&gt;right);   <span class="comment">/*  找到其后继节点  */</span></span><br><span class="line">        p-&gt;val = tmp-&gt;val;    <span class="comment">/*  用后继节点中的数据来替换待删除节点中的数据  */</span></span><br><span class="line">        p-&gt;right = deltree(p-&gt;right, p-&gt;val);    <span class="comment">/*  删除后继节点  */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">/*  待删除节点有0个或1个孩子  */</span></span><br><span class="line">        tmp = p;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        tmp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们用图解详细说明一下删除过程：</p><blockquote><p><code>case 1：有0个或1个子节点</code></p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/bst1.png?raw=true" alt=""></p><blockquote><p>4是要待删除的节点，我们只需要把指针绕过4，然后释放该节点即可完成删除。</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/bst2.png?raw=true" alt=""></p><blockquote><p><code>case 2：有2个子节点</code></p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/bst3.png?raw=true" alt=""></p><blockquote><p>2是要待删除的节点，我们从节点2开始，找到它的后继节点3， 然后用3来替代2，然后我们删除其后继节点3。即这种方法并不是真正的删除想要删除的节点，只是间接删除。要想真正删除待删除节点，情况就比较复杂了，算法导论中有相关的描述，大家可以去看看。</p></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/bst4.png?raw=true" alt=""></p><p>我们上面描述的删除算法将会使得左子树比右子树更深，因为我们总是用右子树中的一个节点来代替需要删除的节点。在进行大量随机的<strong>insert / delete</strong>操作后，树或许会变得很不平衡。<br>如果输入的数据是已排好序的，那么二叉搜索树就会退化为线性表，多次<strong>insert</strong>操作将会花费O(n^2)的时间。这无疑不是我们所期望的。</p><p><img src="https://github.com/yaomer/pictures/blob/master/bst5.png?raw=true" alt=""><br>有一些二叉搜索树的变种可以解决这些问题，我们以后会提到的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;顾名思义，二叉搜索树就是以二叉树来组织的。而二叉树是一颗有根树，它的每个节点至多有两个子节点。&lt;/p&gt;
&lt;p&gt;二叉搜索树的每个节点通常是这样组织的：&lt;strong&gt;&lt;em&gt;一个指向左子树的指针、一个指向右子树的指针、关键字以及卫星数据&lt;/em&gt;&lt;/strong&gt;。在某些情况下，还可以对树节点作一些更改，比如增加一个指向父节点的指针，这样做的目的是有助于更好地完成某些操作。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>巧判机器的大小端</title>
    <link href="https://yaoer.me/2018/10/21/endian/"/>
    <id>https://yaoer.me/2018/10/21/endian/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-10-22T15:26:03.947Z</updated>
    
    <content type="html"><![CDATA[<p>大小端的命名来自于《格列佛游记》中一个有关吃鸡蛋先磕鸡蛋的大端还是小端的故事，大家有兴趣的话可以去了解一下。</p><p>那么什么是大端、什么是小端呢？</p><blockquote><ul><li>大端：即高位有效字节在低位地址，低位有效字节在高位地址。</li><li>小端：即高位有效字节在高位地址，低位有效字节在低位地址。</li></ul></blockquote><a id="more"></a><p>我们举个例子来说明一下：<code>char a = 1;</code></p><p>它在内存中的表示如下图：</p><blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/endian.png?raw=true" alt=""></p></blockquote><p>那么如何用C语言来判断自己所使用机器的大小端呢？<br>通常有两种方法，其本质都是依赖于<strong><em>大小端的概念。</em></strong></p><p>一种方法是借助联合的特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125; port;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    port.a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (port.b == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们知道，在联合中 <strong><em>多个成员变量共用一段内存</em></strong>。在执行完<code>port.a = 1</code>后，内存中的情况是这样的：<code>00000000 00000000 00000000 00000001</code>。它到底是如何存放的，我们目前并不清楚。当我们访问<code>port.b</code>时，我们只会访问到位于该段内存中最低地址的那一字节的内容。如果<code>port.b == 1</code>，显然我们访问到的是<code>00000001</code>这一字节的内容，即低位有效字节在低位地址，所以是<code>little-endian</code>模式。<code>big-endian</code>模式同理。</p></blockquote><p>另一种方法就是根据大小端的概念直接判断了，相比于第一种更直接点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endian</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">char</span> *)&amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (endian())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>a是一个<code>int</code>类型的整数，所以<code>&amp;a</code>可以看作一个<code>int *</code>类型的指针。如果对<code>&amp;a</code>进行解引用操作，则编译器会将其解释为：<strong><em>从当前地址开始往后数4个字节，然后取出这4个字节中的内容</em></strong>。如果我们将<code>&amp;a</code>强制类型转换为<code>char *</code>类型后再进行解引用操作，那么编译器就会将其解释为：<strong><em>取出当前地址所在的那个字节中的内容</em></strong>。这个地址一定是之前那4个内存地址中的最低位地址。通过查看该地址中的值是什么我们就能确定该机器的大小端了。</p></blockquote><p>显然，两种方法的本质都是相同的，都是通过<strong><em>查看低位地址中的内容</em></strong>来判断大小端模式的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大小端的命名来自于《格列佛游记》中一个有关吃鸡蛋先磕鸡蛋的大端还是小端的故事，大家有兴趣的话可以去了解一下。&lt;/p&gt;
&lt;p&gt;那么什么是大端、什么是小端呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;大端：即高位有效字节在低位地址，低位有效字节在高位地址。&lt;/li&gt;
&lt;li&gt;小端：即高位有效字节在高位地址，低位有效字节在低位地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="server" scheme="https://yaoer.me/categories/server/"/>
    
    
  </entry>
  
  <entry>
    <title>单链表的基本操作</title>
    <link href="https://yaoer.me/2018/10/20/sll/"/>
    <id>https://yaoer.me/2018/10/20/sll/</id>
    <published>2018-10-19T16:00:00.000Z</published>
    <updated>2018-10-21T12:36:41.627Z</updated>
    
    <content type="html"><![CDATA[<p>由于单链表是链表的一种，所以我们首先来介绍一下链表。</p><p>链表是一种线性表，通常由一连串节点组成，每个节点包含任意的实例数据，和一个或两个用于指向上一个或下一个节点的指针。</p><p>使用链表的优点是：</p><blockquote><ul><li>克服了数组需要预先知道数据大小的缺点</li><li>可以充分利用计算机的内存空间，实现灵活的动态内存管理</li></ul></blockquote><a id="more"></a><p>缺点是：</p><blockquote><ul><li>失去了数组随机读取的优点</li><li>由于增加了节点的指针域，空间开销比较大。</li></ul></blockquote><p>单链表是一种单向链接的链表，对链表的访问只能从表头开始，在表的末尾有一个特殊的结束标记，通常为NULL。</p><p>下面我们给出单链表的具体实现，涉及到它的一些基本操作，如创建、插入、删除等。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> &#123;</span>    <span class="comment">/*  表节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">next</span>;</span>    <span class="comment">/*  指向下一个节点的指针  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建一个单链表通常有两种方法：<strong><em>头插法和尾插法</em></strong></p><blockquote><ul><li>所谓头插法：就是将最先创建的那个节点作为尾节点，然后不断向前延伸。这种方法对数据的存储顺序和你的输入顺序是相反的。</li><li>所谓尾插法：与头插法相反，它将最先创建的那个节点作为头节点，然后不断向后延伸，这应该比较符合我们一般的思维习惯。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  create_head_sll函数：用头插法创建一个长度为size的单链表  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">create_head_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((head = <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="keyword">new</span>-&gt;val);</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;head-&gt;val);</span><br><span class="line">        head-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span> = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  create_tail_sll函数：用尾插法创建一个长度为size的单链表  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">create_tail_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">pre</span>, *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pre = head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist ))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre-&gt;val);</span><br><span class="line">    pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="keyword">new</span>-&gt;val);</span><br><span class="line">        pre-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pre = <span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><blockquote><p>单链表的插入操作通常要分好几种情况讨论，但只要我们细心观察它们，就会发现它们之间的共性，即<font color="red">每个节点都有一个指向它的指针</font>，头节点也不例外。从这种角度来看，头指针也不过是指向一个节点的普通指针而已。因此，我们在这里使用二级指针，能极大地简化操作，并使代码简洁优雅。<font color="red">而在遍历单链表的过程中，我们只需要保存每个指向next域的指针即可，这样就将所有可能的情况转化成一种通用的情况。</font></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  insert_sll函数：在有序单链表中插入一个节点，这里假定是按升序排列的  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sll</span><span class="params">(struct nlist **nextp, <span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nlist))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;val = new_val;</span><br><span class="line">    <span class="comment">/*  寻找插入位置  */</span></span><br><span class="line">    <span class="keyword">while</span> (*nextp != <span class="literal">NULL</span> &amp;&amp; (*nextp)-&gt;val &lt; new_val)</span><br><span class="line">        nextp = &amp;(*nextp)-&gt;next;   <span class="comment">/*  每次得到指向next域的指针  */</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = *nextp;</span><br><span class="line">    *nextp = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>删除操作同插入操作的方法类似，每次也只需保存指向前一个节点的next域的指针即可，原因也很简单，因为前一个节点中的next指针指向当前节点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  delete_sll函数：在单链表中删除一个节点  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_sll</span><span class="params">(struct nlist **nextp, <span class="keyword">int</span> old_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*nextp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*nextp)-&gt;val == old_val) &#123;</span><br><span class="line">            tmp = (*nextp)-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(*nextp);</span><br><span class="line">            *nextp = tmp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextp = &amp;(*nextp)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆置"><a href="#逆置" class="headerlink" title="逆置"></a>逆置</h3><p>单链表的逆置通常有三种方法：</p><blockquote><ol><li>利用头插法创建一个单链表的思想，我们从头遍历整个链表，然后用头插法重新链接每个节点，自然就将链表逆置过来了</li><li>就地逆置，也叫三指针法，改变每个节点的next域，完成逆置过程</li><li>递归的方法</li></ol></blockquote><h4 id="头插法逆置"><a href="#头插法逆置" class="headerlink" title="头插法逆置"></a>头插法逆置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct nlist * <span class="title">reverse_cll</span><span class="params">(struct nlist *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">head</span>, *<span class="title">pre</span>;</span></span><br><span class="line"></span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        head = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="就地逆置"><a href="#就地逆置" class="headerlink" title="就地逆置"></a>就地逆置</h4><blockquote><p>我们用pre指向前一个节点，new指向后一个节点，而*nextp则是head指针，指向当前需要改变的节点，我们用它来遍历整个链表。<strong><em>每次我们先让new指向下一个需要改变的节点，然后再让当前结点的next指针指向之前的节点，最后我们更新pre的值。</em></strong> 至于这里用不用二级指针就随你喜欢了。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_sll</span><span class="params">(struct nlist **nextp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">pre</span>, *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (pre = <span class="literal">NULL</span>; *nextp != <span class="literal">NULL</span>; *nextp = <span class="keyword">new</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> = (*nextp)-&gt;next;</span><br><span class="line">        (*nextp)-&gt;next = pre;</span><br><span class="line">        pre = *nextp;</span><br><span class="line">    &#125;</span><br><span class="line">    *nextp = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找、求长、打印"><a href="#查找、求长、打印" class="headerlink" title="查找、求长、打印"></a>查找、求长、打印</h3><blockquote><p>单链表的查找、求长以及打印操作主要涉及到的都只是 <strong><em>遍历链表的方法</em></strong>，所以应该都很简单。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  search_sll函数：在单链表中查找一个值  */</span></span><br><span class="line"><span class="function">struct nlist *<span class="title">search_sll</span><span class="params">(struct nlist *head, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; head != <span class="literal">NULL</span>; head = head-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == val)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  length_sll函数：计算单链表的长度  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_sll</span><span class="params">(struct nlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; head != <span class="literal">NULL</span>; len++)</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  print_sll函数：打印单链表  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sll</span><span class="params">(struct nlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; head != <span class="literal">NULL</span>; head = head-&gt;next)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, head-&gt;val);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>这里销毁单链表之所以使用二级指针，我是这么想的：</p><blockquote><p><strong><em>如果我们只是简单的传回head指针，虽然它指向的节点被释放了，但它本身的值是不会改变的。</em></strong> 为了避免之后错误地引用已经被释放的head指针，我们需要将它置空，使用二级指针可以很容易做到这一点，虽然在main函数中我们可以在destruct之后手动置空head，但我认为这样更好一些。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  destruct_sll函数：销毁单链表  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destruct_sll</span><span class="params">(struct nlist **nextp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( ; *nextp != <span class="literal">NULL</span>; *nextp = tmp) &#123;</span><br><span class="line">        tmp = (*nextp)-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(*nextp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于单链表是链表的一种，所以我们首先来介绍一下链表。&lt;/p&gt;
&lt;p&gt;链表是一种线性表，通常由一连串节点组成，每个节点包含任意的实例数据，和一个或两个用于指向上一个或下一个节点的指针。&lt;/p&gt;
&lt;p&gt;使用链表的优点是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;克服了数组需要预先知道数据大小的缺点&lt;/li&gt;
&lt;li&gt;可以充分利用计算机的内存空间，实现灵活的动态内存管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>队列的基本操作</title>
    <link href="https://yaoer.me/2018/10/20/queue/"/>
    <id>https://yaoer.me/2018/10/20/queue/</id>
    <published>2018-10-19T16:00:00.000Z</published>
    <updated>2018-10-23T06:27:33.669Z</updated>
    
    <content type="html"><![CDATA[<p>和栈一样，队列也是一种操作受限制的表。<strong><em>它只允许在表头（队头）执行删除操作（出队），在表尾（队尾）执行插入操作（入队）。</em></strong> 同样的，队列也可以分别由数组和链表实现。</p><p>队列的链表实现正如我们所描述的那样是直接而鲜明的，这里就不多加描述了。而队列的数组实现是有几点需要说明的。</p><a id="more"></a><p>关于顺序队列中的溢出问题</p><blockquote><ul><li>对空队列执行出队操作，称为下溢，是一种正常现象，常用作程序控制转移的条件</li><li>对满队列执行入队操作，称为“真上溢“，这是一种错误，应设法避免</li><li>由于入队和出队操作中， <strong><em><font color="red">头尾指针只增加不减小，致使被删除元素的空间永远无法重新利用。当队列中实际的元素个数远远小于队列空间的规模时，也可能是由于尾指针已超越队列空间的上界而不能做入队操作，就会发生“假上溢“</font></em></strong> </li></ul></blockquote><p><img src="https://github.com/yaomer/pictures/blob/master/a.png?raw=true" alt=""></p><blockquote><p>如上图所示，浅蓝色区域中的元素是被删除过的，它们所占有的空间本来是能够重新利用的，但对于顺序队列却无法做到。<strong><em>因为我们无法访问到之前被删除的元素所占有的空间。我们只能向队尾走，队列很快就会满，这样会导致队列中也许只存在很少的元素。</em></strong> 例如上述顺序队列再入队一次就会满，而队列中的实际元素只有3个。</p></blockquote><p>避免上述假上溢问题的简单的解决方法是：<strong><em>只要head或tail指针到达数组末尾，就让它们又绕回开头，</em></strong> 即队列的循环数组实现，也称为<font color="red">循环队列</font></p><p>当然，对于队列的链表实现，是不存在溢出问题的。</p><hr><h4 id="队列的链表实现"><a href="#队列的链表实现" class="headerlink" title="队列的链表实现"></a>队列的链表实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>    <span class="comment">/*  队列节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Queue *front;</span><br><span class="line"><span class="keyword">static</span> Queue *rear;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initqueue函数：初始化队列  */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initqueue</span><span class="params">(<span class="keyword">int</span> new_val)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Queue *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    p-&gt;val = new_val; </span><br><span class="line">    front = rear = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* enqueue函数：入队操作 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> new_val)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Queue *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    p-&gt;val = new_val;</span><br><span class="line">    rear-&gt;next = p;</span><br><span class="line">    rear = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* dequeue函数：出队操作 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dequeue</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Queue *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isempty()) &#123;</span><br><span class="line">        tmp = front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(front);</span><br><span class="line">        front = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  headqueue函数：返回队头元素  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">headqueue</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> front-&gt;val;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* isfull函数：判断队列是否已满 */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">/*  因为是用链表实现的，所以队列不会满 */</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* isempty函数：判断队列是否为空 */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> front == <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* clear函数：销毁队列 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (!isempty()) </span><br><span class="line">        dequeue(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h4><p>对于队列的数组实现我们需要说明几个问题：</p><blockquote><ul><li>如何实现回绕呢？<ul><li>很简单，就是利用取余运算的特性</li></ul></li><li>如何判断队列为空，如何判断队列已满呢？<ul><li>队列为空很简单，头尾指针重合时即表明队列为空</li><li><strong><em>我们初始化队列时，让head和tail都指向数组的第一个元素的位置。当进行若干次入队和出队操作后，队头和队尾只相差一个位置，如果再进行一次入队操作后，tail和head重合，这就表明队列中已没有可用的空间了，说明队列已满</em></strong></li></ul></li></ul></blockquote><hr><p>下图所展示的队列就已满了，当再进行一次入队操作后，tail就和head重合了。所以判断队列是否已满的条件是：<code>head == (tail + 1) % MAXVAL</code></p><p><img src="https://github.com/yaomer/pictures/blob/master/b.png?raw=true" alt=""></p><p>很显然，这样会浪费一个空间，但是这样保证了判断队列为空和队列已满的条件是不同的。</p><p>入队和出队操作都很简单，这里就不多说了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val[MAXVAL];    <span class="comment">/*  队列空间  */</span></span><br><span class="line">    <span class="keyword">int</span> head;     <span class="comment">/*  头指针  */</span></span><br><span class="line">    <span class="keyword">int</span> tail;     <span class="comment">/*  尾指针  */</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  initqueue函数：初始化队列  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initqueue</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;head = Q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  enqueue函数：入队  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Queue *Q, <span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull(Q)) &#123;</span><br><span class="line">    Q-&gt;val[Q-&gt;tail] = new_val;</span><br><span class="line">        Q-&gt;tail = (Q-&gt;tail + <span class="number">1</span>) % MAXVAL;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  dequeue函数：出队  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isempty(Q)) &#123;</span><br><span class="line">        tmp = Q-&gt;val[Q-&gt;head];</span><br><span class="line">        Q-&gt;head = (Q-&gt;head + <span class="number">1</span>) % MAXVAL;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  headqueue函数：返回队头元素  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">headqueue</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty(Q))</span><br><span class="line">        <span class="keyword">return</span> Q-&gt;val[Q-&gt;head];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isfull函数：检查队列是否已满  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;head == (Q-&gt;tail + <span class="number">1</span>) % MAXVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isempty函数：检查队列是否为空  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(Queue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;head == Q-&gt;tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;和栈一样，队列也是一种操作受限制的表。&lt;strong&gt;&lt;em&gt;它只允许在表头（队头）执行删除操作（出队），在表尾（队尾）执行插入操作（入队）。&lt;/em&gt;&lt;/strong&gt; 同样的，队列也可以分别由数组和链表实现。&lt;/p&gt;
&lt;p&gt;队列的链表实现正如我们所描述的那样是直接而鲜明的，这里就不多加描述了。而队列的数组实现是有几点需要说明的。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>栈的基本操作</title>
    <link href="https://yaoer.me/2018/10/20/stack/"/>
    <id>https://yaoer.me/2018/10/20/stack/</id>
    <published>2018-10-19T16:00:00.000Z</published>
    <updated>2018-10-23T06:27:15.597Z</updated>
    
    <content type="html"><![CDATA[<p>栈是限制插入和删除只能在一个位置上进行的表，这个位置叫做栈顶。对空栈进行<strong>pop或top</strong>操作一般被认为是栈ADT的错误，而当运行<strong>push</strong>时栈空间用尽则是一个实现错误，不是栈ADT的错误。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Data_stack.svg/200px-Data_stack.svg.png" alt=""></p><a id="more"></a><p>栈的特点是 <strong><em>后进先出</em></strong>，因此栈特别适用于 <strong><em>保存和恢复调用现场</em></strong>。栈有许多重要应用，我们简单列举几例：</p><blockquote><ul><li>函数调用（尤其是递归的实现）</li><li>平衡符号</li><li>表达式转换</li><li>……</li></ul></blockquote><p>栈的基本操作很简单，主要有如下几种</p><blockquote><ul><li>push操作（入栈）</li><li>pop操作（出栈）</li><li>top操作（访问栈顶值）</li></ul></blockquote><p>根据你自身的需要，你还可以添加别的操作。比如：清空栈等。</p><p>下面我们给出栈的两种实现方法：数组和链表。</p><hr><h4 id="栈的数组实现"><a href="#栈的数组实现" class="headerlink" title="栈的数组实现"></a>栈的数组实现</h4><p>数组实现的唯一缺点就是：<strong><em>栈空间可能会用尽。</em></strong> 但在绝大多数情况下，只要稍加注意，是不会出现栈空间用尽的情况的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVAL 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val[MAXVAL];    <span class="comment">/*  值栈  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp = <span class="number">-1</span>;    <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将c压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isfull())</span><br><span class="line">        val[++sp] = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is full\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出并返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp--];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> val[sp];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  clear函数：清空栈  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sp = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isfull函数：判断栈是否已满  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == MAXVAL - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isempty函数：判断栈是否为空  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="栈的链表实现"><a href="#栈的链表实现" class="headerlink" title="栈的链表实现"></a>栈的链表实现</h4><p>由于栈自身的特点，特别适合于用单链表去实现。我们只需在表头进行<strong>push和pop</strong>操作即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>    <span class="comment">/*  表节点  */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Node *sp;   <span class="comment">/*  栈顶指针  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  push函数：将new_val压入栈中  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    p-&gt;val = new_val;</span><br><span class="line">    p-&gt;next = sp;</span><br><span class="line">    sp = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  pop函数：弹出栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isempty()) &#123;</span><br><span class="line">        tmp = sp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(sp);</span><br><span class="line">        sp = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  top函数：返回栈顶值  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isempty())</span><br><span class="line">        <span class="keyword">return</span> sp-&gt;val;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  clear函数：清空栈  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!isempty())</span><br><span class="line">pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isfull函数：判断栈是否已满  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isfull</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  isempty函数：判断栈是否为空  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isempty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;栈是限制插入和删除只能在一个位置上进行的表，这个位置叫做栈顶。对空栈进行&lt;strong&gt;pop或top&lt;/strong&gt;操作一般被认为是栈ADT的错误，而当运行&lt;strong&gt;push&lt;/strong&gt;时栈空间用尽则是一个实现错误，不是栈ADT的错误。&lt;br&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Data_stack.svg/200px-Data_stack.svg.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://yaoer.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
</feed>
